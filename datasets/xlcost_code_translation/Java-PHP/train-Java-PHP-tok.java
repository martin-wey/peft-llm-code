import java . io . * ; class GFG { static boolean isEven ( int arr [ ] , int n , int r ) { if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; } else { int oddCount = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 } ; int n = arr . length ; int r = 2 ; if ( isEven ( arr , n , r ) ) System . out . println ( " Even " ) ; else System . out . println ( " Odd " ) ; } }
import java . io . * ; class GFG { static void solve ( int a [ ] , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; boolean evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 1 , 2 , 1 } ; int n = a . length ; solve ( a , n ) ; } }
import java . io . * ; class GFG { static void CreateArray ( int N , int even , int odd ) { int EvenPreSums = 1 ; int temp = - 1 ; int OddPreSums = 0 ; for ( int i = 0 ; i <= N + 1 ; i ++ ) { if ( i * ( ( N + 1 ) - i ) == odd ) { temp = 0 ; OddPreSums = i ; break ; } } if ( temp == - 1 ) { System . out . println ( temp ) ; } else { EvenPreSums = ( ( N + 1 ) - OddPreSums ) ; int e = 1 ; int o = 0 ; int CurrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( CurrSum % 2 == 0 ) { if ( e < EvenPreSums ) { e ++ ; System . out . print ( "0 ▁ " ) ; } else { o ++ ; System . out . print ( "1 ▁ " ) ; CurrSum ++ ; } } else { if ( e < EvenPreSums ) { e ++ ; System . out . print ( "1 ▁ " ) ; CurrSum ++ ; } else { o ++ ; System . out . print ( "0 ▁ " ) ; } } } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int N = 15 ; int even = 60 , odd = 60 ; CreateArray ( N , even , odd ) ; } }
class GFG { static int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; } public static void main ( String [ ] args ) { int A = 2 , B = 3 ; int X = findX ( A , B ) ; System . out . println ( " X ▁ = ▁ " + X + " , ▁ Sum ▁ = ▁ " + ( ( A ^ X ) + ( B ^ X ) ) ) ; } }
import java . io . * ; class GFG { static boolean isSumEqual ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 10 } ; int n = arr . length ; if ( isSumEqual ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static double perfectSquares ( int a , int b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; } static double countOnes ( int arr [ ] , int n ) { return perfectSquares ( 1 , n ) ; } public static void main ( String [ ] args ) { int N = 10 ; int arr [ ] = { 0 } ; System . out . println ( countOnes ( arr , N ) ) ; } }
class GFG { static void printPosition ( int A [ ] , int B [ ] , int sizeOfA , int sizeOfB ) { for ( int i = 1 ; i < sizeOfA ; i ++ ) { A [ i ] += A [ i - 1 ] ; } for ( int i = 0 ; i < sizeOfB ; i ++ ) { int row = lower_bound ( A , 0 , A . length , B [ i ] ) ; int boxNumber = ( row >= 1 ) ? B [ i ] - A [ row - 1 ] : B [ i ] ; System . out . print ( row + 1 + " , ▁ " + boxNumber + "NEW_LINE"); } } private static int lower_bound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) { low = middle + 1 ; } else { high = middle ; } } return low ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 2 , 2 , 2 } ; int B [ ] = { 1 , 2 , 3 , 4 } ; int sizeOfA = A . length ; int sizeOfB = B . length ; printPosition ( A , B , sizeOfA , sizeOfB ) ; } }
class GFG { static void primeFactors ( int n , int freq [ ] ) { int cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } freq [ 2 ] = cnt ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } freq [ i ] = cnt ; } if ( n > 2 ) freq [ n ] = 1 ; } static int getMaximumPower ( int n , int m ) { int freq1 [ ] = new int [ n + 1 ] , freq2 [ ] = new int [ m + 1 ] ; primeFactors ( n , freq1 ) ; primeFactors ( m , freq2 ) ; int maxi = 0 ; for ( int i = 2 ; i <= m ; i ++ ) { if ( freq1 [ i ] == 0 && freq2 [ i ] == 0 ) continue ; if ( freq2 [ i ] > freq1 [ i ] ) return 0 ; if ( freq2 [ i ] != 0 ) { maxi = Math . max ( maxi , freq1 [ i ] / freq2 [ i ] ) ; } } return maxi ; } public static void main ( String [ ] args ) { int n = 48 , m = 4 ; System . out . println ( getMaximumPower ( n , m ) ) ; } }
class GFG { static void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( div [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int n = 10 ; findDivisors ( n ) ; } }
class GFG { static int decideWinner ( int [ ] a , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; } public static void main ( String args [ ] ) { int [ ] a = { 4 , 8 , 5 , 9 } ; int n = a . length ; if ( decideWinner ( a , n ) == 1 ) System . out . print ( " X ▁ wins " ) ; else System . out . print ( " Y ▁ wins " ) ; } }
class GFG { public static int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int n = 7 ; int x = 2 ; System . out . print ( CntDivbyX ( arr , n , x ) ) ; } }
class GFG { public static int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; } public static void main ( String [ ] args ) { int K = 7 ; System . out . print ( numLen ( K ) ) ; } }
class GFGq { static int max_Element = ( int ) ( 1e6 + 5 ) ; static int sum1 [ ] = new int [ max_Element ] , sum2 [ ] = new int [ max_Element ] , sum3 [ ] = new int [ max_Element ] ; static void precomputation ( int arr [ ] , int n ) { for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( int i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( int i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( sum3 [ arr [ i ] ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 5 , 6 } ; int n = arr . length ; precomputation ( arr , n ) ; } }
class GFG { static int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } static int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } public static void main ( String [ ] args ) { int l = 4 , r = 8 ; System . out . println ( calculateSum ( l , r ) ) ; } }
class GFG { static void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( int i = 1 ; i <= a ; i ++ ) System . out . print ( " ( ( " ) ; for ( int i = 1 ; i <= c ; i ++ ) System . out . print ( " ) ( " ) ; for ( int i = 1 ; i <= d ; i ++ ) System . out . print ( " ) ) " ) ; for ( int i = 1 ; i <= b ; i ++ ) System . out . print ( " ( ) " ) ; } else System . out . print ( - 1 ) ; } public static void main ( String args [ ] ) { int a = 3 , b = 1 , c = 4 , d = 3 ; printBalancedExpression ( a , b , c , d ) ; } }
import java . io . * ; class GFG { static int factorial ( int f ) { int fact = 1 ; for ( int i = 2 ; i <= f ; i ++ ) fact *= ( int ) i ; return fact ; } static int findPermutation ( int N , int M ) { int permutation = factorial ( N + M - 1 ) / ( factorial ( N ) * factorial ( M - 1 ) ) ; return permutation ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 ; System . out . println ( findPermutation ( N , M ) ) ; } }
class GFG { static int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . print ( maxValue ( n ) ) ; } }
class GFG { static void findCount ( int n ) { long a = 1 , b = 0 , c = 0 ; int x = n / 60 ; a = ( long ) Math . pow ( 32 , x ) ; x = 60 * x ; for ( int i = x + 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { b += a ; a = 0 ; } if ( i % 5 == 0 ) { c += b ; b = 0 ; } if ( i % 12 == 0 ) { a += ( 2 * c ) ; c = 0 ; } } System . out . println ( " a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } public static void main ( String [ ] args ) { int n = 72 ; findCount ( n ) ; } }
class GFG { static int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : factorial ( n - 1 ) * n ; } static int gcdOfFactorial ( int [ ] arr , int n ) { int minm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minm = minm > arr [ i ] ? arr [ i ] : minm ; return factorial ( minm ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 9 , 12 , 122 , 34 , 15 } ; int n = arr . length ; System . out . println ( gcdOfFactorial ( arr , n ) ) ; } }
class GFG { static long sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( long ) Math . pow ( n , n ) + sum ( n - 1 ) ) ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( sum ( n ) ) ; } }
class GFG { static final int mod = 1000000007 ; static long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( ( n & 1 ) == 1 ) p = ( p * a ) % mod ; return p ; } static int countPermutations ( int n ) { if ( n == 1 ) { return 0 ; } return ( ( int ) power ( 2 , n - 1 ) - 2 ) % mod ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( countPermutations ( n ) ) ; } }
class GFG { static long numbers ( int n ) { return ( long ) ( Math . pow ( 2 , n + 1 ) ) - 2 ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( numbers ( n ) ) ; } }
class GFG { static long NumberofWays ( int n ) { long x = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; long y = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) ; return ( 1l * x * y ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( NumberofWays ( n ) ) ; } }
class GFG { public static int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( nthTerm ( N ) ) ; } }
class GFG { static void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { System . out . print ( ( ( 2 * i ) - 1 ) + " ▁ " ) ; i ++ ; } } public static void main ( String args [ ] ) { int n = 3 ; findNumbers ( n ) ; } }
class GFG { static void findMissingNums ( int even [ ] , int sizeEven , int odd [ ] , int sizeOdd ) { int minEven = Integer . MAX_VALUE ; int maxEven = Integer . MIN_VALUE ; int minOdd = Integer . MAX_VALUE ; int maxOdd = Integer . MIN_VALUE ; int sumEvenArr = 0 , sumOddArr = 0 ; for ( int i = 0 ; i < sizeEven ; i ++ ) { minEven = Math . min ( minEven , even [ i ] ) ; maxEven = Math . max ( maxEven , even [ i ] ) ; sumEvenArr += even [ i ] ; } for ( int i = 0 ; i < sizeOdd ; i ++ ) { minOdd = Math . min ( minOdd , odd [ i ] ) ; maxOdd = Math . max ( maxOdd , odd [ i ] ) ; sumOddArr += odd [ i ] ; } int totalTerms = 0 , reqSum = 0 ; totalTerms = minEven / 2 ; int evenSumMin = ( totalTerms * ( totalTerms + 1 ) ) ; totalTerms = maxEven / 2 ; int evenSumMax = ( totalTerms * ( totalTerms + 1 ) ) ; reqSum = evenSumMax - evenSumMin + minEven ; System . out . println ( " Even ▁ = ▁ " + ( reqSum - sumEvenArr ) ) ; totalTerms = ( minOdd / 2 ) + 1 ; int oddSumMin = totalTerms * totalTerms ; totalTerms = ( maxOdd / 2 ) + 1 ; int oddSumMax = totalTerms * totalTerms ; reqSum = oddSumMax - oddSumMin + minOdd ; System . out . println ( " Odd ▁ = ▁ " + ( reqSum - sumOddArr ) ) ; } public static void main ( String [ ] args ) { int even [ ] = { 6 , 4 , 8 , 14 , 10 } ; int sizeEven = even . length ; int odd [ ] = { 7 , 5 , 3 , 11 , 13 } ; int sizeOdd = odd . length ; findMissingNums ( even , sizeEven , odd , sizeOdd ) ; } }
import java . io . * ; class GFG { static int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; } public static void main ( String [ ] args ) { int x = 6 , y = 5 ; System . out . println ( findMinimum ( x , y ) ) ; } }
class GFG { static int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; } static int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 == 0 ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int l = 1000 , r = 6000 ; System . out . println ( countNumbers ( l , r ) ) ; } }
class GfG { static int findMinSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 7 , 8 } ; int n = arr . length ; System . out . println ( findMinSum ( arr , n ) ) ; } }
class GFG { static int maxLenSubArr ( int a [ ] , int n ) { int count , j ; int cm = 1 , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( int i = 0 ; i < n - 1 ; ) { count = 1 ; if ( a [ i ] == a [ i + 1 ] && a [ i ] == max ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] == max ) { count ++ ; i ++ ; } else break ; } if ( count > cm ) cm = count ; } else i ++ ; } return cm ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 1 , 6 , 6 , 0 } ; int n = arr . length ; System . out . println ( maxLenSubArr ( arr , n ) ) ; } }
class GFG { static int minSum ( int arr [ ] , int n , int x ) { int sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; int sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 5 , 5 , 5 , 6 } ; int n = arr . length ; int x = 3 ; System . out . println ( minSum ( arr , n , x ) ) ; } }
class GfG { static int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } } public static void main ( String [ ] args ) { int L = 1 , R = 632 ; System . out . println ( maxAND ( L , R ) ) ; } }
class GFG { static boolean checkSpecialPrime ( boolean [ ] sieve , int num ) { while ( num > 0 ) { if ( sieve [ num ] ) { return false ; } num /= 10 ; } return true ; } static void findSpecialPrime ( int N ) { boolean [ ] sieve = new boolean [ N * 10 + 1 ] ; sieve [ 0 ] = sieve [ 1 ] = true ; for ( int i = 2 ; i <= N * 10 ; i ++ ) { if ( ! sieve [ i ] ) { for ( int j = i * i ; j <= N * 10 ; j += i ) { sieve [ j ] = true ; } } } while ( true ) { if ( checkSpecialPrime ( sieve , N ) ) { System . out . println ( N ) ; break ; } else N ++ ; } } public static void main ( String [ ] args ) { int N = 379 ; findSpecialPrime ( N ) ; N = 100 ; findSpecialPrime ( N ) ; } }
class GFG { static int minMoves ( int n ) { String s = Integer . toString ( n ) ; int ans = Integer . MAX_VALUE ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { for ( int j = 0 ; j < len ; ++ j ) { if ( i == j ) continue ; char t [ ] = s . toCharArray ( ) ; int cur = 0 ; for ( int k = i ; k < len - 1 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } for ( int k = j - ( ( j > i ) ? 1 : 0 ) ; k < len - 2 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } int pos = - 1 ; for ( int k = 0 ; k < len ; ++ k ) { if ( t [ k ] != '0' ) { pos = k ; break ; } } for ( int k = pos ; k > 0 ; -- k ) { swap ( t , k , k - 1 ) ; ++ cur ; } long nn = Integer . parseInt ( String . valueOf ( t ) ) ; if ( nn % 25 == 0 ) ans = Math . min ( ans , cur ) ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; } static void swap ( char t [ ] , int i , int j ) { char temp = t [ i ] ; t [ i ] = t [ j ] ; t [ j ] = temp ; } public static void main ( String [ ] args ) { int n = 509201 ; System . out . println ( minMoves ( n ) ) ; } }
import java . io . * ; class GFG { static int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 10 , c = 3 ; System . out . println ( getMaxNum ( a , b , c ) ) ; } }
class GFG { static int countSquares ( int row , int column ) { int topLeft = Math . min ( row , column ) - 1 ; int bottomRight = 8 - Math . max ( row , column ) ; int topRight = Math . min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - Math . max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; } public static void main ( String [ ] args ) { int row = 4 , column = 4 ; System . out . println ( countSquares ( row , column ) ) ; } }
class GFG { static boolean canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; } public static void main ( String [ ] args ) { int bishopX = 5 , bishopY = 5 ; int pawnX = 1 , pawnY = 1 ; if ( canTakeDown ( bishopX , bishopY , pawnX , pawnY ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int N = 1000005 ; static int primeFactors [ ] = new int [ N ] ; static void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; } public static void main ( String [ ] args ) { findPrimeFactors ( ) ; int a = 6 , b = 3 ; System . out . println ( primeFactors [ a ] - primeFactors [ b ] ) ; } }
class GFG { static int digitSum ( int n ) { int ans = 0 ; while ( n != 0 ) { ans += n % 10 ; n /= 10 ; } return ans ; } static int findInt ( int n , int m ) { int minDigit = ( int ) Math . floor ( ( double ) ( m / 9 ) ) ; int start = ( int ) Math . pow ( 10 , minDigit ) - ( int ) Math . pow ( 10 , minDigit ) % n ; while ( start < Integer . MAX_VALUE ) { if ( digitSum ( start ) == m ) return start ; else start += n ; } return - 1 ; } static public void main ( String args [ ] ) { int n = 13 , m = 32 ; System . out . print ( findInt ( n , m ) ) ; } }
import java . io . * ; class GFG { static double smallestDivisor ( int n ) { double mx = Math . sqrt ( n ) ; for ( int i = 2 ; i <= mx ; i ++ ) if ( n % i == 0 ) return i ; return n ; } static double maxSum ( int n ) { long res = n ; while ( n > 1 ) { double divi = smallestDivisor ( n ) ; n /= divi ; res += n ; } return res ; } public static void main ( String [ ] args ) { int n = 34 ; System . out . println ( maxSum ( n ) ) ; } }
import java . io . * ; class GFG { static boolean isPossible ( int n , int k , int arr [ ] ) { int sum = arr [ 0 ] ; int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; } public static void main ( String [ ] args ) { int k = 8 ; int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; if ( isPossible ( n , k , arr ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = Math . max ( maxVal , x + y + ( int ) z ) ; } } return maxVal ; } public static void main ( String args [ ] ) { int n = 10 , a = 5 , b = 3 , c = 4 ; System . out . println ( maxResult ( n , a , b , c ) ) ; } }
class GFG { static boolean EqualNumbers ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] /= 2 ; } while ( a [ i ] % 3 == 0 ) { a [ i ] /= 3 ; } if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int a [ ] = { 50 , 75 , 150 } ; int n = a . length ; if ( EqualNumbers ( a , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class GFG { static long max_gcd ( long n , long p ) { int count = 0 ; long gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= ( long ) Math . pow ( 2 , count / n ) ; for ( long i = 3 ; i <= Math . sqrt ( p ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = p / i ; } if ( count > 0 ) { gcd *= ( long ) Math . pow ( i , count / n ) ; } } if ( p > 2 ) gcd *= ( long ) Math . pow ( p , 1 / n ) ; return gcd ; } public static void main ( String [ ] args ) { long n = 3 ; long p = 80 ; System . out . println ( max_gcd ( n , p ) ) ; } }
import java . io . * ; import java . math . * ; public class GFG { int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) { return c ; } int x = ( ( b / c ) * c ) + c ; return x ; } public static void main ( String args [ ] ) { int a = 2 ; int b = 4 ; int c = 4 ; GFG g = new GFG ( ) ; System . out . println ( g . getMinNum ( a , b , c ) ) ; } }
class GFG { public static int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countPairs ( n ) ) ; } }
class GFG { static boolean checkSub ( String sub , String s ) { int j = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( sub . charAt ( j ) == s . charAt ( i ) ) j ++ ; return j == sub . length ( ) ; } static int getMultiple ( String s ) { for ( int i = 0 ; i < 1E3 ; i += 8 ) { if ( checkSub ( Integer . toString ( i ) , s ) ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { String s = "3454" ; System . out . println ( getMultiple ( s ) ) ; } }
import java . io . * ; class GFG { float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; } public static void main ( String args [ ] ) { GFG g = new GFG ( ) ; System . out . println ( g . sum ( 8 ) ) ; System . out . print ( g . sum ( 10 ) ) ; } }
import java . util . * ; class GFG { static ArrayList < Integer > findingValues ( int m , int n , int mth , int nth ) { int d = ( Math . abs ( mth - nth ) ) / Math . abs ( ( m - 1 ) - ( n - 1 ) ) ; int a = mth - ( ( m - 1 ) * d ) ; ArrayList < Integer > res = new ArrayList < Integer > ( ) ; res . add ( a ) ; res . add ( d ) ; return res ; } static int findSum ( int m , int n , int mth , int nth , int p ) { ArrayList < Integer > ad = findingValues ( m , n , mth , nth ) ; int a = ad . get ( 0 ) ; int d = ad . get ( 1 ) ; int sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 ; return sum ; } public static void main ( String [ ] args ) { int m = 6 , n = 10 , mTerm = 12 , nTerm = 20 , p = 5 ; System . out . println ( findSum ( m , n , mTerm , nTerm , p ) ) ; } }
import java . util . * ; import java . lang . Math ; class GfG { static void powerfulIntegers ( int x , int y , int bound ) { Set < Integer > s = new HashSet < > ( ) ; ArrayList < Integer > powersOfY = new ArrayList < > ( ) ; int i ; powersOfY . add ( 1 ) ; for ( i = y ; i < bound && y != 1 ; i = i * y ) powersOfY . add ( i ) ; i = 0 ; while ( true ) { int xPowI = ( int ) Math . pow ( ( double ) x , ( double ) i ) ; for ( int j = 0 ; j < powersOfY . size ( ) ; ++ j ) { int num = xPowI + powersOfY . get ( j ) ; if ( num <= bound ) s . add ( num ) ; else break ; } if ( xPowI >= bound x == 1 ) break ; i ++ ; } Iterator itr = s . iterator ( ) ; while ( itr . hasNext ( ) ) { System . out . print ( itr . next ( ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int x = 2 , y = 1 , bound = 10 ; powerfulIntegers ( x , y , bound ) ; } }
class GFG { static void candies ( int n , int k ) { int count = 0 ; int ind = 1 ; int [ ] arr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; while ( n > 0 ) { int f1 = ( ind - 1 ) * k ; int f2 = ind * k ; int sum1 = ( f1 * ( f1 + 1 ) ) / 2 ; int sum2 = ( f2 * ( f2 + 1 ) ) / 2 ; int res = sum2 - sum1 ; if ( res <= n ) { count ++ ; n -= res ; ind ++ ; } { int i = 0 ; int term = ( ( ind - 1 ) * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ i ++ ] = term ; n -= term ; term ++ ; } else { arr [ i ++ ] = n ; n = 0 ; } } } } for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 10 , k = 3 ; candies ( n , k ) ; } }
class GFG { static void candies ( int n , int k ) { int count = 0 ; int ind = 1 ; int [ ] arr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; int low = 0 , high = n ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; int sum = ( mid * ( mid + 1 ) ) >> 1 ; if ( sum <= n ) { count = mid / k ; low = mid + 1 ; } else { high = mid - 1 ; } } int last = ( count * k ) ; n -= ( last * ( last + 1 ) ) / 2 ; int j = 0 ; int term = ( count * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ j ++ ] = term ; n -= term ; term ++ ; } else { arr [ j ] += n ; n = 0 ; } } for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 7 , k = 4 ; candies ( n , k ) ; } }
import java . util . Arrays ; public class GFG { static int printSmallest ( int a [ ] ) { int sum , sum1 ; Arrays . sort ( a ) ; int i , j , k , num ; for ( i = 0 ; i < 3 ; i ++ ) { if ( a [ i ] % 3 == 0 ) { return a [ i ] ; } } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { num = ( a [ i ] * 10 ) + a [ j ] ; if ( num % 3 == 0 ) { return num ; } } } return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 7 , 1 } ; System . out . println ( printSmallest ( arr ) ) ; } }
public class GFG { static void updateMatrix ( int n , int q [ ] [ ] , int mat [ ] [ ] ) { int i , j ; for ( i = 0 ; i < q . length ; i ++ ) { int X1 = q [ i ] [ 0 ] ; int Y1 = q [ i ] [ 1 ] ; int X2 = q [ i ] [ 2 ] ; int Y2 = q [ i ] [ 3 ] ; mat [ X1 ] [ Y1 ] ++ ; if ( Y2 + 1 < n ) mat [ X2 ] [ Y2 + 1 ] -- ; else if ( X2 + 1 < n ) mat [ X2 + 1 ] [ 0 ] -- ; } int sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { sum += mat [ i ] [ j ] ; System . out . print ( sum + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 5 ; int mat [ ] [ ] = new int [ n ] [ n ] ; int q [ ] [ ] = { { 0 , 0 , 1 , 2 } , { 1 , 2 , 3 , 4 } , { 1 , 4 , 3 , 4 } } ; updateMatrix ( n , q , mat ) ; } }
import java . util . * ; class GFG { static void printArr ( float arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void replaceMax ( float arr [ ] , int n ) { float max = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } float min = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } float range = max - min ; float coeffOfRange = range / ( max + min ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max ) { arr [ i ] = coeffOfRange ; break ; } } printArr ( arr , n ) ; } public static void main ( String args [ ] ) { float arr [ ] = { 15 , 16 , 10 , 9 , 6 , 7 , 17 } ; int n = arr . length ; replaceMax ( arr , n ) ; } }
import java . util . * ; class solution { static void divide ( int a , int b ) { for ( int i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } System . out . println ( " A ▁ = ▁ " + a + " , ▁ B ▁ = ▁ " + b ) ; } public static void main ( String args [ ] ) { int A = 10 , B = 15 ; divide ( A , B ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void commDiv ( int a , int b ) { int n = gcd ( a , b ) ; a = a / n ; b = b / n ; System . out . println ( " A ▁ = ▁ " + a + " , ▁ B ▁ = ▁ " + b ) ; } public static void main ( String [ ] args ) { int a = 10 , b = 15 ; commDiv ( a , b ) ; } }
class GFG { static int minAbsDiff ( int n ) { int left = 1 << ( ( int ) Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( minAbsDiff ( n ) ) ; } }
import java . util . * ; import java . text . DecimalFormat ; class solution { static double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; } public static void main ( String args [ ] ) { double p = 1 , q = 2 , r = 1 , s = 2 ; DecimalFormat dec = new DecimalFormat ( " # 0.000000000" ) ; System . out . println ( dec . format ( find_probability ( p , q , r , s ) ) ) ; } }
import java . util . Arrays ; public class GfG { public static void FindAllElements ( int n , int k ) { int sum = k ; int [ ] A = new int [ k ] ; Arrays . fill ( A , 0 , k , 1 ) ; for ( int i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { System . out . print ( " Impossible " ) ; } else { for ( int i = 0 ; i < k ; ++ i ) System . out . print ( A [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 12 ; int k = 6 ; FindAllElements ( n , k ) ; } }
public class GfG { public static int removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } return res ; } public static boolean isEqual ( int a , int b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; } public static void main ( String [ ] args ) { int a = 105 , b = 106 ; if ( isEqual ( a , b ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class Geeks { public static void sumArray ( int arr [ ] , int n ) { int leftSum [ ] = new int [ n ] ; int rightSum [ ] = new int [ n ] ; int Sum [ ] = new int [ n ] ; int i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( Sum [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 6 , 4 , 8 , 9 } ; int n = arr . length ; sumArray ( arr , n ) ; } }
import java . util . * ; class solution { static int minimumX ( int n , int k ) { int mini = Integer . MAX_VALUE ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; } public static void main ( String args [ ] ) { int n = 4 , k = 6 ; System . out . println ( minimumX ( n , k ) ) ; n = 5 ; k = 5 ; System . out . println ( minimumX ( n , k ) ) ; } }
class Solution { static int minimumX ( int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; } public static void main ( String args [ ] ) { int n = 4 , k = 6 ; System . out . println ( minimumX ( n , k ) ) ; n = 5 ; k = 5 ; System . out . println ( minimumX ( n , k ) ) ; } }
import java . util . * ; class GFG { static int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( getHermiteNumber ( n ) ) ; } }
public class GFG { static void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { System . out . print ( " a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b ) ; } else System . out . println ( - 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; find ( n ) ; } }
class GFG { static boolean isPerfect ( int N ) { if ( ( Math . sqrt ( N ) - Math . floor ( Math . sqrt ( N ) ) ) != 0 ) return false ; return true ; } static void getClosestPerfectSquare ( int N ) { if ( isPerfect ( N ) ) { System . out . println ( N + " ▁ " + "0" ) ; return ; } int aboveN = - 1 , belowN = - 1 ; int n1 ; n1 = N + 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } int diff1 = aboveN - N ; int diff2 = N - belowN ; if ( diff1 > diff2 ) System . out . println ( belowN + " ▁ " + diff2 ) ; else System . out . println ( aboveN + " ▁ " + diff1 ) ; } public static void main ( String args [ ] ) { int N = 1500 ; getClosestPerfectSquare ( N ) ; } }
import java . util . * ; class GFG { static int den3 , num3 ; static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void lowest ( ) { int common_factor = gcd ( num3 , den3 ) ; den3 = den3 / common_factor ; num3 = num3 / common_factor ; } static void addFraction ( int num1 , int den1 , int num2 , int den2 ) { den3 = gcd ( den1 , den2 ) ; den3 = ( den1 * den2 ) / den3 ; num3 = ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ; lowest ( ) ; } public static void main ( String [ ] args ) { int num1 = 1 , den1 = 500 , num2 = 2 , den2 = 1500 ; addFraction ( num1 , den1 , num2 , den2 ) ; System . out . printf ( "%d/%d + %d/%d is equal to %d/%dNEW_LINE", num1, den1, num2, den2, num3, den3); } }
public class GFG { static int findLargestDivisor ( int n ) { for ( int i = 2 ; i < Math . sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; } public static void main ( String args [ ] ) { int n = 12 ; System . out . println ( findLargestDivisor ( n ) ) ; n = 97 ; System . out . println ( findLargestDivisor ( n ) ) ; } }
import java . util . Arrays ; class GFG { static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = arr . length ; if ( checkIsAP ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static boolean isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 120 ; if ( isTriPerfect ( n ) ) System . out . println ( n + " ▁ is ▁ a ▁ Triperfect ▁ number " ) ; } }
public class GFG { static int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; } public static void main ( String [ ] args ) { int N = 14 ; int X = 3 , Y = 5 ; System . out . println ( sum ( N , X , Y ) ) ; } }
import java . io . * ; class GFG { static int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int l = 1 , r = 10 ; System . out . println ( findTwoThreePrime ( l , r ) ) ; } }
import java . io . * ; class GFG { static String getNumber ( String s ) { int number_of_digits = s . length ( ) ; int freq [ ] = new int [ 10 ] ; for ( int i = 0 ; i < number_of_digits ; i ++ ) { if ( s . charAt ( i ) == '1' || s . charAt ( i ) == '2' || s . charAt ( i ) == '3' || s . charAt ( i ) == '5' || s . charAt ( i ) == '7' ) { freq [ s . charAt ( i ) - 48 ] += 1 ; } if ( s . charAt ( i ) == '4' ) { freq [ 2 ] += 2 ; freq [ 3 ] ++ ; } if ( s . charAt ( i ) == '6' ) { freq [ 5 ] ++ ; freq [ 3 ] ++ ; } if ( s . charAt ( i ) == '8' ) { freq [ 7 ] ++ ; freq [ 2 ] += 3 ; } if ( s . charAt ( i ) == '9' ) { freq [ 7 ] ++ ; freq [ 3 ] += 2 ; freq [ 2 ] ++ ; } } String t = " " ; if ( freq [ 1 ] == number_of_digits || freq [ 0 ] == number_of_digits || ( freq [ 0 ] + freq [ 1 ] ) == number_of_digits ) { return s ; } else { for ( int i = 9 ; i >= 2 ; i -- ) { int ctr = freq [ i ] ; while ( ( ctr -- ) > 0 ) { t += ( char ) ( i + 48 ) ; } } return t ; } } public static void main ( String [ ] args ) { String s = "1280" ; System . out . println ( getNumber ( s ) ) ; } }
public class GFG { static int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static void icanobifNumbers ( int N ) { int first = 0 , second = 1 ; if ( N == 1 ) System . out . print ( first ) ; else if ( N == 2 ) System . out . print ( first + " ▁ " + second ) ; else { System . out . print ( first + " ▁ " + second + " ▁ " ) ; for ( int i = 3 ; i <= N ; i ++ ) { int x = reversDigits ( first ) ; int y = reversDigits ( second ) ; System . out . print ( x + y + " ▁ " ) ; int temp = second ; second = x + y ; first = temp ; } } } public static void main ( String [ ] args ) { int N = 12 ; icanobifNumbers ( N ) ; } }
import java . io . * ; class GFG { static int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; } public static void main ( String [ ] args ) { int a = 5 , b = 3 , n = 3 ; System . out . print ( addNDigits ( a , b , n ) ) ; } }
class Solution { static int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = ( int ) Math . sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( Triplets ( n ) ) ; } }
import java . io . * ; class GFG { static int solve ( int n , int base ) { int sum = 0 ; while ( n > 0 ) { int remainder = n % base ; sum += remainder ; n = n / base ; } return sum ; } static void SumsOfDigits ( int n ) { int sum = 0 ; for ( int base = 2 ; base <= n / 2 ; ++ base ) sum += solve ( n , base ) ; System . out . println ( sum ) ; } public static void main ( String [ ] args ) { int n = 8 ; SumsOfDigits ( n ) ; } }
import java . io . * ; class GFG { static boolean checkPerfectcube ( int n ) { int d = ( int ) Math . cbrt ( n ) ; if ( d * d * d == n ) return true ; return false ; } static int largestNonPerfectcubeNumber ( int [ ] a , int n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! checkPerfectcube ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; } public static void main ( String [ ] args ) { int a [ ] = { 16 , 64 , 25 , 2 , 3 , 10 } ; int n = a . length ; System . out . print ( largestNonPerfectcubeNumber ( a , n ) ) ; } }
import java . util . * ; class solution { static void checkIfPossibleRec ( int x , int a , int b , boolean isPossible [ ] , int n ) { if ( x > n ) return ; if ( isPossible [ x ] ) return ; isPossible [ x ] = true ; checkIfPossibleRec ( x + a , a , b , isPossible , n ) ; checkIfPossibleRec ( x + b , a , b , isPossible , n ) ; } static boolean checkPossible ( int n , int a , int b ) { boolean isPossible [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) isPossible [ i ] = false ; checkIfPossibleRec ( 0 , a , b , isPossible , n ) ; return isPossible [ n ] ; } public static void main ( String args [ ] ) { int a = 3 , b = 7 , n = 8 ; if ( checkPossible ( a , b , n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . io . * ; class GFG { static int sumOdd ( int n ) { int terms = ( n + 1 ) / 2 ; int sum = terms * terms ; return sum ; } static int suminRange ( int l , int r ) { return sumOdd ( r ) - sumOdd ( l - 1 ) ; } public static void main ( String [ ] args ) { int l = 2 , r = 5 ; System . out . print ( " Sum ▁ of ▁ odd ▁ natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " + suminRange ( l , r ) ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int sumcommDiv ( int a , int b ) { int n = gcd ( a , b ) ; int sum = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum += i ; else sum += ( n / i ) + i ; } } return sum ; } public static void main ( String [ ] args ) { int a = 10 , b = 15 ; System . out . println ( " Sum ▁ = ▁ " + sumcommDiv ( a , b ) ) ; } }
import java . io . * ; class GFG { static String checkNumber ( int N ) { int temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp /= 1000 ; else if ( temp % 100 == 14 ) temp /= 100 ; else if ( temp % 10 == 1 ) temp /= 10 ; else { return " NO " ; } } return " YES " ; } public static void main ( String [ ] args ) { int N = 1414 ; System . out . println ( checkNumber ( N ) ) ; } }
import java . io . * ; class GFG { static int getResult ( int n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( getResult ( n ) ) ; } }
class GFG { static void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( val < 0 ) { System . out . println ( " NO " ) ; return ; } double a = ( N + Math . sqrt ( val ) ) / 2.0 ; double b = ( N - Math . sqrt ( val ) ) / 2.0 ; System . out . println ( " a ▁ = ▁ " + a ) ; System . out . println ( " b ▁ = ▁ " + b ) ; } public static void main ( String [ ] args ) { double N = 69.0 ; findAandB ( N ) ; } }
class GFG { static int minOperations ( int [ ] A , int n ) { if ( ( n & 1 ) > 0 ) return - 1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; } public static void main ( String [ ] args ) { int [ ] A = new int [ ] { 1 , 1 , 0 , 0 } ; int n = A . length ; System . out . println ( minOperations ( A , n ) ) ; } }
class GFG { static int countdig ( int m ) { if ( m == 0 ) return 0 ; else return 1 + countdig ( m / 10 ) ; } static int countSteps ( int x ) { int c = 0 ; int last = x ; while ( last > 0 ) { int digits = countdig ( last ) ; digits -= 1 ; int divisor = ( int ) Math . pow ( 10 , digits ) ; int first = last / divisor ; int lastnumber = first * divisor ; int skipped = ( last - lastnumber ) / first ; skipped += 1 ; c += skipped ; last = last - ( first * skipped ) ; } return c ; } public static void main ( String [ ] args ) { int n = 14 ; System . out . println ( countSteps ( n ) ) ; } }
import java . util . * ; class Solution { static long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long powerGCD ( long a , long b , long n ) { long e = power ( a , n , b ) ; return gcd ( e , b ) ; } public static void main ( String args [ ] ) { long a = 5 , b = 4 , n = 2 ; System . out . print ( powerGCD ( a , b , n ) ) ; } }
public class GFG { static boolean allOddDigits ( int n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 == 0 ) return false ; n /= 10 ; } return true ; } static int largestNumber ( int n ) { if ( n % 2 == 0 ) n -- ; for ( int i = n ; ; i -= 2 ) if ( allOddDigits ( i ) ) return i ; } public static void main ( String [ ] args ) { int N = 23 ; System . out . println ( largestNumber ( N ) ) ; } }
import java . util . * ; class solution { static int countNumbers ( int N ) { return ( int ) Math . sqrt ( N ) - 1 ; } public static void main ( String args [ ] ) { int N = 36 ; System . out . println ( countNumbers ( N ) ) ; } }
class GFG { static int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= ( int ) ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( countOrderedPairs ( N ) ) ; } }
class GFG { static void pairwiseDifference ( int arr [ ] , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; System . out . print ( diff + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 10 , 15 , 5 , 6 } ; int n = arr . length ; pairwiseDifference ( arr , n ) ; } }
class GFG { static long sumAP ( long n , long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; } static long sumMultiples ( long n ) { n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; } public static void main ( String [ ] args ) { long n = 20 ; System . out . println ( sumMultiples ( n ) ) ; } }
class geeksforgeeks { static int markingScheme ( int N , int answerKey [ ] , int studentAnswer [ ] ) { int positive = 0 , negative = 0 , notattempt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( studentAnswer [ i ] == 0 ) notattempt ++ ; else if ( answerKey [ i ] == studentAnswer [ i ] ) positive ++ ; else if ( answerKey [ i ] != studentAnswer [ i ] ) negative ++ ; } return ( positive * 3 ) + ( negative * - 1 ) ; } public static void main ( String args [ ] ) { int answerKey [ ] = { 1 , 2 , 3 , 4 , 1 } ; int studentAnswer [ ] = { 1 , 2 , 3 , 4 , 0 } ; int N = answerKey . length ; int marking_Scheme = markingScheme ( N , answerKey , studentAnswer ) ; System . out . println ( marking_Scheme ) ; } }
class GFG { static int MAX = 10000 ; static boolean [ ] prime = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { prime [ 1 ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } } static int solve ( int n ) { int count = 0 , num = 1 ; int prod = 1 ; while ( count < n ) { if ( ! prime [ num ] ) { prod *= num ; count ++ ; } num ++ ; } return prod ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 5 ; System . out . println ( solve ( n ) ) ; } }
class GFG { static boolean Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; } public static void main ( String [ ] args ) { int l = 30 , r = 70 , k = 10 ; if ( Check_is_possible ( l , r , k ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . util . * ; class GFG { static int nth_group ( int n ) { return n * ( 2 * ( int ) Math . pow ( n , 2 ) + 1 ) ; } public static void main ( String arr [ ] ) { int N = 5 ; System . out . println ( nth_group ( N ) ) ; } }
import java . io . * ; class GFG { static void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 4 , c = 2 ; printPossible ( a , b , c ) ; } }
import java . io . * ; class GFG { static void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; System . out . println ( r ) ; } public static void main ( String [ ] args ) { int N = 5 ; Sum_upto_nth_Term ( N ) ; } }
import java . util . * ; class GFG { static int CalculateDifference ( int arr [ ] , int n ) { int max_val = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_val ) max_val = arr [ i ] ; } boolean [ ] prime = new boolean [ max_val + 1 ] ; for ( int i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int S1 = 0 , S2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return Math . abs ( S2 - S1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 10 , 15 , 7 } ; int n = arr . length ; System . out . println ( CalculateDifference ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int numberOfDivisors ( int num ) { int c = 0 ; for ( int i = 1 ; i <= num ; i ++ ) { if ( num % i == 0 ) { c += 1 ; } } return c ; } static int countNumbers ( int n ) { int c = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( numberOfDivisors ( i ) == 9 ) c += 1 ; } return c ; } public static void main ( String [ ] args ) { int n = 1000 ; System . out . print ( countNumbers ( n ) ) ; } }
import java . io . * ; class GFG { static int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( numberOfDistinct ( n ) ) ; } }
public class GFG { static int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; } public static void main ( String args [ ] ) { int n = 3 , m = 3 ; System . out . println ( NumberOfRectangles ( n , m ) ) ; } }
public class GFG { static long findNumUtil ( long res , int a , int aCount , int b , int bCount , int n ) { if ( res > 1e11 ) return ( long ) 1e11 ; if ( aCount == bCount && res >= n ) return res ; return Math . min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) ; } static int findNum ( int n , int a , int b ) { int result = 0 ; int aCount = 0 ; int bCount = 0 ; return ( int ) findNumUtil ( result , a , aCount , b , bCount , n ) ; } public static void main ( String args [ ] ) { int N = 4500 ; int A = 4 ; int B = 7 ; System . out . println ( findNum ( N , A , B ) ) ; } }
public class Improve { public static void main ( String args [ ] ) { int n = 7 ; int k = 3 ; if ( n % k == 0 ) System . out . println ( n / k + " ▁ " + n / k ) ; else System . out . println ( ( n - ( n % k ) ) / k + " ▁ " + ( ( ( n - ( n % k ) ) / k ) + 1 ) ) ; } }
import java . io . * ; class GFG { public static void main ( String [ ] args ) { float m = 50 , n = 5 , x = 67 , h = 2927 ; int z = ( int ) ( Math . ceil ( h / 60 * 1.0 ) ) ; if ( z <= n ) System . out . println ( z * m ) ; else System . out . println ( n * m + ( z - n ) * x ) ; } }
public class GFG { static double sumProductDifference ( int a , int b , int c , int d , int e ) { double rootSum = ( double ) ( - 1 * b ) / a ; double rootProduct = ( double ) e / a ; return Math . abs ( rootSum - rootProduct ) ; } public static void main ( String args [ ] ) { System . out . println ( sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + ( n ^ x ) ) ++ c ; return c ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . print ( numberOfSolutions ( n ) ) ; } }
public class GFG { static int minimumLectures ( int m , int n ) { int ans = 0 ; if ( n < ( int ) Math . ceil ( 0.75 * m ) ) ans = ( int ) Math . ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; } public static void main ( String [ ] args ) { int M = 9 , N = 1 ; System . out . println ( minimumLectures ( M , N ) ) ; } }
import java . io . * ; class GFG { static int countNumbers ( int N ) { return ( int ) ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countNumbers ( n ) ) ; } }
import java . io . * ; class GFG { static int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( " Sum ▁ = ▁ " + calculateSum ( n ) ) ; } }
public class GFG { static void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) System . out . println ( "2 ▁ solutions " ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) System . out . println ( "1 ▁ solution " ) ; else System . out . println ( " No ▁ solutions " ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 5 , c = 2 ; checkSolution ( a , b , c ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; class GFG { static BigInteger Bits ( int kilobytes ) { BigInteger Bits = new BigInteger ( "0" ) ; BigInteger kilo = BigInteger . valueOf ( kilobytes ) ; Bits = kilo . multiply ( BigInteger . valueOf ( 8192 ) ) ; return Bits ; } static BigInteger Bytes ( int kilobytes ) { BigInteger Bytes = new BigInteger ( "0" ) ; BigInteger kilo = BigInteger . valueOf ( kilobytes ) ; Bytes = kilo . multiply ( BigInteger . valueOf ( 1024 ) ) ; return Bytes ; } public static void main ( String args [ ] ) { int kilobytes = 1 ; System . out . print ( kilobytes + " ▁ Kilobytes ▁ = ▁ " + Bytes ( kilobytes ) + " ▁ Bytes ▁ and ▁ " + Bits ( kilobytes ) + " ▁ Bits . " ) ; } }
public class GFG { public static void main ( String args [ ] ) { int n = 3 ; int a [ ] = { 1 , 2 , 3 } ; int i = 0 ; long sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } long x = sum / n ; if ( x * n == sum ) System . out . println ( x ) ; else System . out . println ( " - 1" ) ; } }
import java . io . * ; class GFG { static double findSum ( long n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; } public static void main ( String [ ] args ) { long n = 10 ; System . out . println ( findSum ( n ) ) ; } }
public class GFG { static int sum ( int x , int y , int n ) { int sum1 = ( int ) ( ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ) ; int sum2 = ( int ) ( ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; return sum1 + sum2 ; } public static void main ( String args [ ] ) { int x = 2 , y = 2 , n = 2 ; System . out . println ( sum ( x , y , n ) ) ; } }
import java . io . * ; class GFG { static void printPair ( int g , int l ) { System . out . print ( g + " ▁ " + l ) ; } public static void main ( String [ ] args ) { int g = 3 , l = 12 ; printPair ( g , l ) ; } }
import java . io . * ; class GFG { static int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( int ) ( Math . pow ( r , n ) - 1 ) / ( r - 1 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( " Sum ▁ = ▁ " + calculateSum ( n ) ) ; } }
import java . util . * ; class GFG { static boolean ispower ( long n ) { if ( n < 125 ) { return ( n == 1 n == 5 n == 25 ) ; } if ( n % 125 != 0 ) { return false ; } else { return ispower ( n / 125 ) ; } } static long number ( String s , int i , int j ) { long ans = 0 ; for ( int x = i ; x < j ; x ++ ) { ans = ans * 2 + ( s . charAt ( x ) - '0' ) ; } return ans ; } static int minCuts ( String s , int n ) { int [ ] dp = new int [ n + 1 ] ; Arrays . fill ( dp , n + 1 ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( s . charAt ( i - 1 ) == '0' ) { continue ; } for ( int j = 0 ; j < i ; j ++ ) { if ( s . charAt ( j ) == '0' ) { continue ; } long num = number ( s , j , i ) ; if ( ! ispower ( num ) ) { continue ; } dp [ i ] = Math . min ( dp [ i ] , dp [ j ] + 1 ) ; } } return ( ( dp [ n ] < n + 1 ) ? dp [ n ] : - 1 ) ; } public static void main ( String [ ] args ) { String s = "101101101" ; int n = s . length ( ) ; System . out . println ( minCuts ( s , n ) ) ; } }
class GFG { static int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; } public static void main ( String [ ] args ) { int num = 15 ; System . out . println ( MinOfCubed ( num ) ) ; } }
class GFG { static int MinOfCubedDP ( int k ) { int [ ] DP = new int [ k + 1 ] ; int j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = Integer . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; } public static void main ( String [ ] args ) { int num = 15 ; System . out . println ( MinOfCubedDP ( num ) ) ; } }
class GFG { static int maxSum ( int [ ] a , int n ) { int ans = 0 ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int [ ] [ ] dp = new int [ n + 1 ] [ 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = Math . max ( ans , dp [ i ] [ 0 ] ) ; ans = Math . max ( ans , dp [ i ] [ 1 ] ) ; ans = Math . max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { - 5 , 3 , 2 , 7 , - 8 , 3 , 7 , - 9 , 10 , 12 , - 6 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int MinimumCost ( int a [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = Math . min ( a [ i ] , 2 * a [ i - 1 ] ) ; } int ind = 0 ; int sum = 0 ; while ( x > 0 ) { if ( x != 0 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; } public static void main ( String [ ] args ) { int a [ ] = { 20 , 50 , 60 , 90 } ; int x = 7 ; int n = a . length ; System . out . println ( MinimumCost ( a , n , x ) ) ; } }
class GFG { static int countWays ( int n , int l , int r ) { int tL = l , tR = r ; int [ ] L = new int [ 3 ] ; int [ ] R = new int [ 3 ] ; L [ l % 2 ] = l ; R [ r % 2 ] = r ; l ++ ; r -- ; if ( l <= tR && r >= tL ) { L [ l % 2 ] = l ; R [ r % 2 ] = r ; } int cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] > 0 && L [ 0 ] > 0 ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] > 0 && L [ 1 ] > 0 ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; int [ ] [ ] dp = new int [ n + 1 ] [ 3 ] ; dp [ 1 ] [ 0 ] = cnt0 ; dp [ 1 ] [ 1 ] = cnt1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) ; } return dp [ n ] [ 0 ] ; } public static void main ( String [ ] args ) { int n = 2 , l = 1 , r = 3 ; System . out . println ( countWays ( n , l , r ) ) ; } }
class GFG { static int M = 1001 ; static int MOD = 998244353 ; static int [ ] [ ] dp = new int [ M ] [ M ] ; static int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 , K = 0 ; for ( int i = 0 ; i <= M ; i ++ ) for ( int j = 0 ; j <= M ; j ++ ) dp [ i ] [ j ] = - 1 ; System . out . println ( ( M * solve ( 2 , 0 , N , M , K ) ) ) ; } }
class GFG { static int N = 3 ; static int maxPathSum ( int tri [ ] [ ] ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; } public static void main ( String [ ] args ) { int tri [ ] [ ] = { { 1 , 5 , 3 } , { 4 , 8 , 0 } , { 1 , 0 , 0 } } ; System . out . println ( maxPathSum ( tri ) ) ; } }
import java . util . * ; class GFG { static int subsetXOR ( int arr [ ] , int n , int K ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 ) ) - 1 ; int [ ] [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) dp [ i ] [ j ] [ k ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( k != 0 ) { dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] ; } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int k = 1 ; int n = arr . length ; System . out . println ( subsetXOR ( arr , n , k ) ) ; } }
class GFG { static int get_max_splits ( String num_String ) { int count = 0 , current_num ; int running_sum = 0 ; for ( int i = 0 ; i < num_String . length ( ) ; i ++ ) { current_num = num_String . charAt ( i ) - '0' ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; } public static void main ( String [ ] args ) { System . out . print ( get_max_splits ( "12345" ) + "NEW_LINE"); } }
class Solution { static int findMinimumCost ( int n , int x , int y ) { int dp [ ] = new int [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; } public static void main ( String args [ ] ) { int n = 4 , x = 2 , y = 1 ; System . out . println ( findMinimumCost ( n , x , y ) ) ; } }
public class GFG { static int nCr ( int n , int r ) { int ans = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; i ++ ) { ans *= ( n - i ) ; ans /= ( i + 1 ) ; } return ans ; } static int countDerangements ( int n ) { int der [ ] = new int [ n + 3 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; } static int countPermutations ( int n , int k ) { int ans = 0 ; for ( int i = n - k ; i <= n ; i ++ ) { int ways = nCr ( n , i ) ; ans += ( ways * countDerangements ( n - i ) ) ; } return ans ; } public static void main ( String [ ] args ) { int n = 5 , k = 3 ; System . out . println ( countPermutations ( n , k ) ) ; } }
class GFG { static int squares ( int i ) { if ( ( i & 1 ) == 1 ) return i / 4 * 2 + 1 ; else return ( i - 1 ) / 4 * 2 + 2 ; } static long bishop_placements ( int n , int k ) { if ( k > 2 * n - 1 ) return 0 ; long [ ] [ ] dp = new long [ n * 2 ] [ k + 1 ] ; for ( int i = 0 ; i < n * 2 ; i ++ ) dp [ i ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n * 2 ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) dp [ i ] [ j ] = dp [ i - 2 ] [ j ] + dp [ i - 2 ] [ j - 1 ] * ( squares ( i ) - j + 1 ) ; } long ans = 0 ; for ( int i = 0 ; i <= k ; i ++ ) { ans += dp [ n * 2 - 1 ] [ i ] * dp [ n * 2 - 2 ] [ k - i ] ; } return ans ; } public static void main ( String [ ] args ) { int n = 2 ; int k = 2 ; long ans = bishop_placements ( n , k ) ; System . out . println ( ans ) ; } }
import java . util . * ; class GFG { static int countStaircases ( int N ) { int [ ] [ ] memo = new int [ N + 5 ] [ N + 5 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { memo [ i ] [ j ] = 0 ; } } memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 ; for ( int i = 5 ; i <= N ; i ++ ) { for ( int j = 2 ; j <= i ; j ++ ) { if ( j == 2 ) { memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 ; } else { memo [ i ] [ j ] = memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ; } } } int answer = 0 ; for ( int i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N ] [ i ] ; return answer ; } public static void main ( String [ ] args ) { int N = 7 ; System . out . println ( countStaircases ( N ) ) ; } }
import java . lang . * ; import java . util . * ; class GFG { public int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; } public static void main ( String args [ ] ) { GFG g = new GFG ( ) ; int n = 5 , m = 5 ; System . out . println ( g . countPaths ( n , m ) ) ; } }
class GFG { static int countPaths ( int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; } public static void main ( String [ ] args ) { int n = 5 ; int m = 5 ; System . out . println ( countPaths ( n , m ) ) ; } }
class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( catalan ( n ) ) ; } }
import java . io . * ; class GFG { static void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; System . out . print ( f1 + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) System . out . print ( f3 + " ▁ " ) ; f1 = f2 ; f2 = f3 ; } } public static void main ( String [ ] args ) { int N = 15 ; alternateFib ( N ) ; } }
import java . io . * ; class GFG { static int totalWays ( int N , int M , int X ) { int dp [ ] [ ] = new int [ N + 1 ] [ 2 ] ; if ( X == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; } public static void main ( String [ ] args ) { int N = 4 , M = 3 , X = 2 ; System . out . println ( totalWays ( N , M , X ) ) ; } }
import java . io . * ; class GFG { static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( fib ( n ) ) ; } }
import java . io . * ; class GFG { static int MAX = 100 ; static int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static int sumOfproduct ( int n ) { return binomialCoeff ( 2 * n , n - 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( sumOfproduct ( n ) ) ; } }
import java . io . * ; class GFG { static void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) System . out . print ( a + " ▁ " ) ; if ( n >= 1 ) System . out . print ( b + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; System . out . print ( c + " ▁ " ) ; a = b ; b = c ; } } public static void main ( String [ ] args ) { fib ( 9 ) ; } }
class GFG { static int pre_compute ( int a [ ] , int n , int index , int k ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = a . length ; int index = 4 , k = 6 ; System . out . println ( pre_compute ( a , n , index , k ) ) ; } }
class GFG { static int gen ( int n ) { int [ ] S = new int [ n + 1 ] ; S [ 0 ] = 0 ; if ( n != 0 ) S [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) S [ i ] = 4 * S [ i / 2 ] ; else S [ i ] = 4 * S [ i / 2 ] + 1 ; } return S [ n ] ; } static void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( gen ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( " First ▁ " + n + " ▁ terms ▁ of ▁ " + " Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ " ) ; moserDeBruijn ( n ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int LCSubStr ( String X , String Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int result = 0 ; int [ ] [ ] len = new int [ 2 ] [ n ] ; int currRow = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { len [ currRow ] [ j ] = len [ ( 1 - currRow ) ] [ ( j - 1 ) ] + 1 ; result = Math . max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; } public static void main ( String args [ ] ) { String X = " GeeksforGeeks " ; String Y = " GeeksQuiz " ; System . out . print ( LCSubStr ( X , Y ) ) ; } }
import java . util . * ; class GFG { static int minimalSteps ( String s , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = Integer . MAX_VALUE ; String s1 = " " , s2 = " " ; dp [ 0 ] = 1 ; s1 += s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s . charAt ( i ) ; s2 = s . substring ( i + 1 , i + 1 ) ; dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; } public static void main ( String args [ ] ) { String s = " aaaaaaaa " ; int n = s . length ( ) ; System . out . println ( minimalSteps ( s , n ) / 2 ) ; } }
import java . util . * ; class GFG { public static void printGolomb ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 1 ] = 1 ; System . out . print ( dp [ 1 ] + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; System . out . print ( dp [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 9 ; printGolomb ( n ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { public static int findLength ( String str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str . charAt ( i ) == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; } public static void main ( String [ ] args ) { String str = "11000010001" ; int n = str . length ( ) ; System . out . println ( findLength ( str , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int DP_s = 9 ; static int getNumStrictMonotone ( int len ) { int [ ] [ ] DP = new int [ len ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( getNumStrictMonotone ( n ) ) ; } }
import java . io . * ; class GFG { static int chordCnt ( int A ) { int n = 2 * A ; int [ ] dpArray = new int [ n + 1 ] ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; } public static void main ( String [ ] args ) { int N ; N = 2 ; System . out . println ( chordCnt ( N ) ) ; N = 1 ; System . out . println ( chordCnt ( N ) ) ; N = 4 ; System . out . println ( chordCnt ( N ) ) ; } }
class GFG { static boolean isPath ( int arr [ ] [ ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 0 , 0 , 0 , - 1 , 0 } , { - 1 , 0 , 0 , - 1 , - 1 } , { 0 , 0 , 0 , - 1 , 0 } , { - 1 , 0 , - 1 , 0 , - 1 } , { 0 , 0 , - 1 , 0 , 0 } } ; if ( isPath ( arr ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( nswp ( n ) ) ; } }
import java . util . * ; class GFG { public static int nswpn ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( nswpn ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { static int lcs ( char [ ] X , char [ ] Y , int m , int n ) { int [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 2 * ( X [ i - 1 ] - '0' ) ; else L [ i ] [ j ] = L [ i - 1 ] [ j ] > L [ i ] [ j - 1 ] ? L [ i - 1 ] [ j ] : L [ i ] [ j - 1 ] ; } } return L [ m ] [ n ] ; } static int findMinCost ( char X [ ] , char Y [ ] ) { int m = X . length , n = Y . length ; int cost = 0 ; for ( int i = 0 ; i < m ; ++ i ) cost += X [ i ] - '0' ; for ( int i = 0 ; i < n ; ++ i ) cost += Y [ i ] - '0' ; return cost - lcs ( X , Y , m , n ) ; } public static void main ( String argc [ ] ) { char X [ ] = ( "3759" ) . toCharArray ( ) ; char Y [ ] = ( "9350" ) . toCharArray ( ) ; System . out . println ( " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings " + " ▁ identical ▁ is ▁ = ▁ " + findMinCost ( X , Y ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static boolean isSubSeqDivisible ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; int arr [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = ( int ) ( str . charAt ( i - 1 ) - '0' ) ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; } public static void main ( String args [ ] ) { String str = "3144" ; if ( isSubSeqDivisible ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int maxLength ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s . charAt ( i ) == ' ( ' && s . charAt ( i + 1 ) == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s . charAt ( i ) == ' ( ' && s . charAt ( j ) == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { String s = " ( ) ( ( ( ( ( ( ) " ; int n = s . length ( ) ; System . out . println ( maxLength ( s , n ) ) ; } }
class GFG { static int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = 2147483647 ; int min_so_far = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 } ; int n = arr . length ; System . out . print ( " Smallest ▁ sum : ▁ " + smallestSumSubarr ( arr , n ) ) ; } }
class GFG { static long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = ( int ) total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; } public static void main ( String [ ] args ) { int n = 3 , k = 2 ; System . out . println ( countWays ( n , k ) ) ; } }
import java . util . Arrays ; public class GFG { public static long sumOfSubstrings ( String num ) { long sum = 0 ; long mf = 1 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { sum += ( num . charAt ( i ) - '0' ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; } public static void main ( String [ ] args ) { String num = "6759" ; System . out . println ( sumOfSubstrings ( num ) ) ; } }
class Test { static int maxSumWithK ( int a [ ] , int n , int k ) { int maxSum [ ] = new int [ n ] ; maxSum [ 0 ] = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; maxSum [ i ] = curr_max ; } int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += a [ i ] ; int result = sum ; for ( int i = k ; i < n ; i ++ ) { sum = sum + a [ i ] - a [ i - k ] ; result = Math . max ( result , sum ) ; result = Math . max ( result , sum + maxSum [ i - k ] ) ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , - 10 , - 3 } ; int k = 4 ; System . out . println ( maxSumWithK ( arr , arr . length , k ) ) ; ; } }
class Gfg { static int arr [ ] = { 1 , 5 , 6 } ; static int countWays ( int N ) { int count [ ] = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; } public static void main ( String [ ] args ) { int N = 7 ; System . out . println ( " Total ▁ number ▁ of ▁ ways ▁ = ▁ " + countWays ( N ) ) ; } }
class Sequences { static int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; } public static void main ( String [ ] args ) { int m = 10 ; int n = 4 ; System . out . println ( " Total ▁ number ▁ of ▁ possible ▁ sequences ▁ " + getTotalNumberOfSequences ( m , n ) ) ; } }
class Sequences { static int getTotalNumberOfSequences ( int m , int n ) { int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; } public static void main ( String [ ] args ) { int m = 10 ; int n = 4 ; System . out . println ( " Total ▁ number ▁ of ▁ possible ▁ sequences ▁ " + getTotalNumberOfSequences ( m , n ) ) ; } }
class GFG { static int lis ( int arr [ ] , int n ) { int result = 0 ; int [ ] lis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < lis [ i ] ) result = lis [ i ] ; return result ; } static int minimumNumberOfDeletions ( int arr [ ] , int n ) { int len = lis ( arr , n ) ; return ( n - len ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 } ; int n = arr . length ; System . out . println ( " Minimum ▁ number ▁ of " + " ▁ deletions ▁ = ▁ " + minimumNumberOfDeletions ( arr , n ) ) ; } }
class GFG { static int lps ( String str ) { int n = str . length ( ) ; int L [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Integer . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; } static int minimumNumberOfDeletions ( String str ) { int n = str . length ( ) ; int len = lps ( str ) ; return ( n - len ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . println ( " Minimum ▁ number ▁ " + " of ▁ deletions ▁ = ▁ " + minimumNumberOfDeletions ( str ) ) ; } }
import java . io . * ; class GFG { static int offeringNumber ( int n , int templeHeight [ ] ) { for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . max ( right , left ) + 1 ; } return sum ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 2 , 2 } ; System . out . println ( offeringNumber ( 3 , arr1 ) ) ; int arr2 [ ] = { 1 , 4 , 3 , 6 , 2 , 1 } ; System . out . println ( offeringNumber ( 6 , arr2 ) ) ; } }
import java . util . Arrays ; class GFG { static boolean modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; boolean DP [ ] = new boolean [ m ] ; Arrays . fill ( DP , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; boolean temp [ ] = new boolean [ m ] ; Arrays . fill ( temp , false ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; } public static void main ( String arg [ ] ) { int arr [ ] = { 1 , 7 } ; int n = arr . length ; int m = 5 ; if ( modularSum ( arr , n , m ) ) System . out . print ( "YESNEW_LINE"); else System . out . print ( "NONEW_LINE"); } }
class GFG { static int maxSum ( int tri [ ] [ ] , int n ) { if ( n > 1 ) tri [ 1 ] [ 1 ] = tri [ 1 ] [ 1 ] + tri [ 0 ] [ 0 ] ; tri [ 1 ] [ 0 ] = tri [ 1 ] [ 0 ] + tri [ 0 ] [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { tri [ i ] [ 0 ] = tri [ i ] [ 0 ] + tri [ i - 1 ] [ 0 ] ; tri [ i ] [ i ] = tri [ i ] [ i ] + tri [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j < i ; j ++ ) { if ( tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] >= tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ) tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] ; else tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ; } } int max = tri [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < tri [ n - 1 ] [ i ] ) max = tri [ n - 1 ] [ i ] ; } return max ; } public static void main ( String [ ] args ) { int tri [ ] [ ] = { { 1 } , { 2 , 1 } , { 3 , 3 , 2 } } ; System . out . println ( maxSum ( tri , 3 ) ) ; } }
import java . io . * ; class GFG { static int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 , 4 , 5 } ; int N = arr . length ; System . out . println ( maximumDifferenceSum ( arr , N ) ) ; } }
class GFG { static final int N = 8 ; static int dx [ ] = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 } ; static int dy [ ] = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 } ; static boolean inside ( int x , int y ) { return ( x >= 0 && x < N && y >= 0 && y < N ) ; } static double findProb ( int start_x , int start_y , int steps ) { double dp1 [ ] [ ] [ ] = new double [ N ] [ N ] [ steps + 1 ] ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) dp1 [ i ] [ j ] [ 0 ] = 1 ; for ( int s = 1 ; s <= steps ; ++ s ) { for ( int x = 0 ; x < N ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) { double prob = 0.0 ; for ( int i = 0 ; i < 8 ; ++ i ) { int nx = x + dx [ i ] ; int ny = y + dy [ i ] ; if ( inside ( nx , ny ) ) prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 ; } dp1 [ x ] [ y ] [ s ] = prob ; } } } return dp1 [ start_x ] [ start_y ] [ steps ] ; } public static void main ( String [ ] args ) { int K = 3 ; System . out . println ( findProb ( 0 , 0 , K ) ) ; } }
import java . util . * ; class GFG { static int countSubarray ( int arr [ ] , int n , int k ) { int s = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } s += ( ( count * ( count + 1 ) ) / 2 ) ; } return ( n * ( n + 1 ) / 2 - s ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int k = 2 ; int n = arr . length ; System . out . print ( countSubarray ( arr , n , k ) ) ; } }
import java . io . * ; class GFG { static int nCr ( int n , int k ) { int C [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } static double resultOfAllSubsets ( int arr [ ] , int N ) { double result = 0.0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( int n = 1 ; n <= N ; n ++ ) result += ( double ) ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 } ; int N = arr . length ; System . out . println ( resultOfAllSubsets ( arr , N ) ) ; } }
import java . util . Arrays ; class GFG { static int arr [ ] = { 100 , 1000 , 100 , 1000 , 1 } ; static int sum [ ] = new int [ 10000 ] ; static int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; } public static void main ( String [ ] args ) { int n = arr . length ; Arrays . fill ( sum , - 1 ) ; System . out . println ( maxSumWO3Consec ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; Arrays . sort ( arr ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = arr . length ; int K = 4 ; System . out . println ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) ; } }
import java . io . * ; class GFG { static int countGroups ( int position , int previous_sum , int length , String num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num . charAt ( i ) - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; } public static void main ( String [ ] args ) { String num = "1119" ; int len = num . length ( ) ; System . out . println ( countGroups ( 0 , 0 , len , num ) ) ; } }
import java . io . * ; class GFG { static int count ( String a , String b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; } public static void main ( String [ ] args ) { String a = " GeeksforGeeks " ; String b = " Gks " ; System . out . println ( count ( a , b ) ) ; } }
class GFG { public static int lcs ( String X , String Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ ] [ ] = new int [ 2 ] [ n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; } public static void main ( String [ ] args ) { String X = " AGGTAB " ; String Y = " GXTXAYB " ; System . out . println ( " Length ▁ of ▁ LCS ▁ is ▁ " + lcs ( X , Y ) ) ; } }
class GFG { static int subsetXOR ( int [ ] arr , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 ) ) - 1 ; if ( k > m ) { return 0 ; } int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; } public static void main ( String arg [ ] ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int k = 4 ; int n = arr . length ; System . out . println ( " Count ▁ of ▁ subsets ▁ is ▁ " + subsetXOR ( arr , n , k ) ) ; } }
import java . io . * ; class GFG { static int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; } public static void main ( String [ ] args ) { int coeff [ ] = { 2 , 2 , 5 } ; int rhs = 4 ; int n = coeff . length ; System . out . println ( countSol ( coeff , 0 , n - 1 , rhs ) ) ; } }
import java . io . * ; class GFG { static int steps ( int source , int step , int dest ) { if ( Math . abs ( source ) > ( dest ) ) return Integer . MAX_VALUE ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . min ( pos , neg ) ; } public static void main ( String [ ] args ) { int dest = 11 ; System . out . println ( " No . ▁ of ▁ steps ▁ required " + " ▁ to ▁ reach ▁ " + dest + " ▁ is ▁ " + steps ( 0 , 0 , dest ) ) ; } }
class GFG { static String X , Y ; static int lcs ( int i , int j , int count ) { if ( i == 0 j == 0 ) { return count ; } if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . max ( count , Math . max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; } public static void main ( String [ ] args ) { int n , m ; X = " abcdxyz " ; Y = " xyzabcd " ; n = X . length ( ) ; m = Y . length ( ) ; System . out . println ( lcs ( n , m , 0 ) ) ; } }
import java . util . * ; class GFG { static int no_of_characters ( int M ) { int k = 1 ; while ( true ) { if ( ( int ) Math . pow ( 2 , k + 1 ) - 2 < M ) k ++ ; else break ; } return k ; } static void print_string ( int M ) { int k , num , N ; k = no_of_characters ( M ) ; N = M - ( ( int ) Math . pow ( 2 , k ) - 2 ) ; while ( k > 0 ) { num = ( int ) Math . pow ( 2 , k - 1 ) ; if ( num >= N ) System . out . print ( " A " ) ; else { System . out . print ( " B " ) ; N -= num ; } k -- ; } System . out . println ( ) ; } public static void main ( String args [ ] ) { int M ; M = 30 ; print_string ( M ) ; M = 55 ; print_string ( M ) ; M = 100 ; print_string ( M ) ; } }
class GFG { static String updateString ( String S , String A , String B ) { int l = A . length ( ) ; for ( int i = 0 ; i + l <= S . length ( ) ; i ++ ) { String curr = S . substring ( i , i + l ) ; if ( curr . equals ( A ) ) { String new_string = S . substring ( 0 , i ) + B + S . substring ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } else { String new_string = S . substring ( 0 , i ) + A + S . substring ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } } return S ; } public static void main ( String [ ] args ) { String S = " aab " ; String A = " aa " ; String B = " bb " ; System . out . println ( updateString ( S , A , B ) ) ; } }
class GFG { static void printPattern ( int n , int m ) { if ( m > 2 * ( n + 1 ) m < n - 1 ) { System . out . print ( " - 1" ) ; } else if ( Math . abs ( n - m ) <= 1 ) { while ( n > 0 && m > 0 ) { System . out . print ( "01" ) ; n -- ; m -- ; } if ( n != 0 ) { System . out . print ( "0" ) ; } if ( m != 0 ) { System . out . print ( "1" ) ; } } else { while ( m - n > 1 && n > 0 ) { System . out . print ( "110" ) ; m = m - 2 ; n = n - 1 ; } while ( n > 0 ) { System . out . print ( "10" ) ; n -- ; m -- ; } while ( m > 0 ) { System . out . print ( "1" ) ; m -- ; } } } public static void main ( String [ ] args ) { int n = 4 , m = 8 ; printPattern ( n , m ) ; } }
import java . io . * ; class GFG { static int countDecreasing ( int A [ ] , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } public static void main ( String [ ] args ) { int A [ ] = { 100 , 3 , 1 , 13 } ; int n = A . length ; System . out . println ( countDecreasing ( A , n ) ) ; } }
import java . io . * ; class GFG { static int minimumChar ( String S1 , String S2 ) { int n = S1 . length ( ) ; int m = S2 . length ( ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 . charAt ( j ) != S2 . charAt ( i + j ) ) { minRemovedChar ++ ; } } ans = Math . min ( minRemovedChar , ans ) ; } return ans ; } public static void main ( String [ ] args ) { String S1 = " abc " ; String S2 = " paxzk " ; System . out . println ( minimumChar ( S1 , S2 ) ) ; } }
class GFG { static int countFreq ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; } static public void main ( String [ ] args ) { String txt = " dhimanman " ; String pat = " man " ; System . out . println ( countFreq ( pat , txt ) ) ; } }
class GFG { static void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; { System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } public static void main ( String [ ] args ) { String txt = " ABCEABCDABCEABCD " ; String pat = " ABCD " ; search ( pat , txt ) ; } }
class GFG { static void printMatrix ( int n , int m ) { if ( n < 5 m < 5 ) { System . out . print ( - 1 ) ; return ; } char [ ] s = " aeiou " . toCharArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { System . out . print ( s [ j % 5 ] + " ▁ " ) ; } System . out . println ( ) ; char c = s [ 0 ] ; for ( int k = 0 ; k < 4 ; k ++ ) { s [ k ] = s [ k + 1 ] ; } s [ 4 ] = c ; } } public static void main ( String [ ] args ) { int n = 5 , m = 5 ; printMatrix ( n , m ) ; } }
class GFG { static int minOperations ( int n , String a , String b , String c ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char x = a . charAt ( i ) ; char y = b . charAt ( i ) ; char z = c . charAt ( i ) ; if ( x == y && y == z ) ; else if ( x == y y == z x == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; } public static void main ( String [ ] args ) { String a = " place " ; String b = " abcde " ; String c = " plybe " ; int n = a . length ( ) ; System . out . print ( minOperations ( n , a , b , c ) ) ; } }
class GFG { static boolean check ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i + 1 ) ) return true ; } return false ; } public static void main ( String args [ ] ) { String s = " geeksforgeeks " ; if ( check ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int countSubStr ( String str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; } public static void main ( String [ ] args ) { String str = " abcabc " ; int n = str . length ( ) ; char x = ' c ' ; System . out . println ( countSubStr ( str , n , x ) ) ; } }
import java . util . * ; class GFG { static int countSubStr ( String str , int n ) { int len = str . length ( ) ; return ( len - n + 1 ) ; } public static void main ( String args [ ] ) { String str = " geeksforgeeks " ; int n = 5 ; System . out . print ( countSubStr ( str , n ) ) ; } }
class GFG { static int countSubstrings ( String s , char c ) { int n = s . length ( ) ; int cnt = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; } public static void main ( String [ ] args ) { String s = " baa " ; char c = ' b ' ; System . out . println ( countSubstrings ( s , c ) ) ; } }
class GFG { static boolean isPalindrome ( String s ) { int i = 0 ; int j = s . length ( ) - 1 ; while ( i < j ) { if ( s . charAt ( i ) != s . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; } static int getIndex ( String S1 , String S2 , int n ) { String S = " " ; for ( int i = 0 ; i < n ; i ++ ) { S = S + S1 . charAt ( i ) ; String Temp = " " ; for ( int j = i + 1 ; j < n ; j ++ ) Temp += S2 . charAt ( j ) ; if ( isPalindrome ( S + Temp ) ) { return i ; } } return - 1 ; } public static void main ( String [ ] args ) { String S1 = " abcdf " , S2 = " sfgba " ; int n = S1 . length ( ) ; System . out . println ( getIndex ( S1 , S2 , n ) ) ; } }
import java . util . * ; class GFG { static boolean valid ( int [ ] cnt ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( cnt [ i ] >= 2 ) return false ; } return true ; } static String getGoodString ( String ss , int n ) { char [ ] s = ss . toCharArray ( ) ; if ( n < 26 ) return " - 1" ; int [ ] cnt = new int [ 27 ] ; for ( int i = 25 ; i < n ; i ++ ) { for ( int j = i ; j >= i - 25 ; j -- ) { if ( s [ j ] != ' ? ' ) cnt [ ( ( int ) s [ j ] - ( int ) ' a ' ) ] ++ ; } if ( valid ( cnt ) ) { int cur = 0 ; while ( cnt [ cur ] > 0 ) cur ++ ; for ( int j = i - 25 ; j <= i ; j ++ ) { if ( s [ j ] == ' ? ' ) { s [ j ] = ( char ) ( cur + ( int ) ( ' a ' ) ) ; cur ++ ; while ( cnt [ cur ] > 0 ) cur ++ ; } } return new String ( s ) ; } } return " - 1" ; } public static void main ( String [ ] args ) { String s = " abcdefghijkl ? nopqrstuvwxy ? " ; int n = s . length ( ) ; System . out . println ( getGoodString ( s , n ) ) ; } }
class GFG { static boolean isVowel ( char c ) { c = Character . toLowerCase ( c ) ; if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) { return true ; } return false ; } static String swapRepeated ( char str [ ] ) { for ( int i = 0 ; i < str . length - 1 ; i ++ ) { char c = 0 ; if ( ( isVowel ( str [ i ] ) && isVowel ( str [ i + 1 ] ) ) || ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i + 1 ] ) ) ) { c = str [ i ] ; str [ i ] = str [ i + 1 ] ; str [ i + 1 ] = c ; } } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . println ( swapRepeated ( str . toCharArray ( ) ) ) ; } }
class GFG { static String largestPalinSub ( String s ) { String res = " " ; char mx = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) mx = ( char ) Math . max ( ( int ) mx , ( int ) s . charAt ( i ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == mx ) res += s . charAt ( i ) ; return res ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; System . out . println ( largestPalinSub ( s ) ) ; } }
class GFG { static void printString ( char [ ] str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; boolean used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = true ; for ( int j = 0 ; j < ones ; j ++ ) System . out . print ( "1" ) ; } if ( str [ i ] != '1' ) System . out . print ( str [ i ] ) ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) System . out . print ( "1" ) ; } public static void main ( String [ ] args ) { String str = "100210" ; int n = str . length ( ) ; printString ( str . toCharArray ( ) , n ) ; } }
import java . util . * ; class solution { static int findPermutation ( String str , int k ) { boolean [ ] has = new boolean [ 26 ] ; Arrays . fill ( has , false ) ; int cnt = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! has [ str . charAt ( i ) - ' a ' ] ) { cnt ++ ; has [ str . charAt ( i ) - ' a ' ] = true ; } } int ans = 1 ; for ( int i = 2 ; i <= cnt ; i ++ ) ans *= i ; for ( int i = cnt - k ; i > 1 ; i -- ) ans /= i ; return ans ; } public static void main ( String args [ ] ) { String str = " geeksforgeeks " ; int k = 4 ; System . out . println ( findPermutation ( str , k ) ) ; } }
class GFG { static int product ( int x ) { int prod = 1 ; while ( x > 0 ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; } static int findNumber ( int l , int r ) { String b = Integer . toString ( r ) ; int ans = r ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) { if ( b . charAt ( i ) == '0' ) continue ; char [ ] curr = b . toCharArray ( ) ; curr [ i ] = ( char ) ( ( ( int ) ( curr [ i ] - ( int ) '0' ) - 1 ) + ( int ) ( '0' ) ) ; for ( int j = i + 1 ; j < curr . length ; j ++ ) curr [ j ] = '9' ; int num = 0 ; for ( int j = 0 ; j < curr . length ; j ++ ) num = num * 10 + ( curr [ j ] - '0' ) ; if ( num >= l && product ( ans ) < product ( num ) ) ans = num ; } return ans ; } public static void main ( String [ ] args ) { int l = 1 , r = 10 ; System . out . println ( findNumber ( l , r ) ) ; l = 51 ; r = 62 ; System . out . println ( findNumber ( l , r ) ) ; } }
class GFG { static void constructBinString ( int a , int b , int x ) { int d , i ; d = x / 2 ; if ( x % 2 == 0 && x / 2 != a ) { d -- ; System . out . print ( "0" ) ; a -- ; } for ( i = 0 ; i < d ; i ++ ) System . out . print ( "10" ) ; a = a - d ; b = b - d ; for ( i = 0 ; i < b ; i ++ ) { System . out . print ( "1" ) ; } for ( i = 0 ; i < a ; i ++ ) { System . out . print ( "0" ) ; } } public static void main ( String [ ] args ) { int a = 4 , b = 3 , x = 2 ; constructBinString ( a , b , x ) ; } }
public class GFG { static boolean matchPattern ( String s ) { int count = 0 ; int n = s . length ( ) ; int i = 0 ; while ( i < n ) { while ( i < n && s . charAt ( i ) == ' a ' ) { count ++ ; i ++ ; } while ( i < n && s . charAt ( i ) == ' b ' ) { count -- ; i ++ ; } if ( count != 0 ) return false ; } return true ; } public static void main ( String [ ] args ) { String s = " bb " ; if ( matchPattern ( s ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int maximum_one ( String s , int n ) { int cnt_one = 0 ; int max_cnt = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { cnt_one ++ ; temp ++ ; } else { max_cnt = Math . max ( max_cnt , temp ) ; temp = 0 ; } } max_cnt = Math . max ( max_cnt , temp ) ; int [ ] left = new int [ n ] ; int right [ ] = new int [ n ] ; if ( s . charAt ( 0 ) == '1' ) left [ 0 ] = 1 ; else left [ 0 ] = 0 ; if ( s . charAt ( n - 1 ) == '1' ) right [ n - 1 ] = 1 ; else right [ n - 1 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) left [ i ] = left [ i - 1 ] + 1 ; else left [ i ] = 0 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '1' ) right [ i ] = right [ i + 1 ] + 1 ; else right [ i ] = 0 ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) == '0' ) { int sum = left [ i - 1 ] + right [ i + 1 ] ; if ( sum < cnt_one ) max_cnt = Math . max ( max_cnt , sum + 1 ) ; else max_cnt = Math . max ( max_cnt , sum ) ; } } return max_cnt ; } public static void main ( String [ ] args ) { String s = "111011101" ; System . out . println ( maximum_one ( s , s . length ( ) ) ) ; } }
import java . io . * ; class GFG { static int maxFreq ( String s , int a , int b ) { int fre [ ] = new int [ 10 ] ; int n = s . length ( ) ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } for ( int i = 0 ; i < n ; i ++ ) fre [ s . charAt ( i ) - '0' ] ++ ; if ( fre [ a ] == 0 && fre [ b ] == 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; } public static void main ( String [ ] args ) { int a = 4 , b = 7 ; String s = "47744" ; System . out . print ( maxFreq ( s , a , b ) ) ; } }
import java . util . * ; class solution { static void convert ( int n , String a , String b ) { int [ ] l = new int [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) l [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a . charAt ( i ) != b . charAt ( i ) ) l [ i ] = 1 ; } int cc = 0 ; int vl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( l [ i ] == 0 ) { if ( vl != 0 ) cc += 1 ; vl = 0 ; } else vl += 1 ; } if ( vl != 0 ) cc += 1 ; System . out . println ( cc ) ; } public static void main ( String args [ ] ) { String a = "101010" ; String b = "110011" ; int n = a . length ( ) ; convert ( n , a , b ) ; } }
import java . io . * ; class GFG { static int countWays ( String s1 , String s2 , int n ) { int a , b , c , d ; a = b = c = d = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s2 . charAt ( i ) == '0' ) { if ( s1 . charAt ( i ) == '0' ) { c ++ ; } else { d ++ ; } } else { if ( s1 . charAt ( i ) == '0' ) { a ++ ; } else { b ++ ; } } } result = a * d + b * c + c * d ; return result ; } public static void main ( String [ ] args ) { int n = 5 ; String s1 = "01011" ; String s2 = "11001" ; System . out . println ( countWays ( s1 , s2 , n ) ) ; } }
class GfG { static int returnWinner ( String s , int l ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s . charAt ( i ) - ' a ' ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] % 2 != 0 ) cnt ++ ; } if ( ( cnt == 0 ) || ( cnt & 1 ) == 1 ) return 1 ; else return 2 ; } public static void main ( String [ ] args ) { String s = " abaaab " ; int l = s . length ( ) ; int winner = returnWinner ( s , l ) ; System . out . println ( " Player - " + winner ) ; } }
import java . io . * ; class GFG { static void maxProductSum ( String str , int m ) { int n = str . length ( ) ; int maxProd = Integer . MIN_VALUE , maxSum = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( str . charAt ( j ) - '0' ) ; sum = sum + ( str . charAt ( j ) - '0' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } System . out . println ( " Maximum ▁ Product ▁ = ▁ " + maxProd ) ; System . out . print ( " Maximum Sum = " + maxSum); } public static void main ( String [ ] args ) { String str = "3605356297" ; int m = 3 ; maxProductSum ( str , m ) ; } }
public class GFG { static int maxLength ( String s , int n ) { int right = 0 , left = 0 ; int coun = 0 , max_length = Integer . MIN_VALUE ; s = s + '1' ; for ( int i = 0 ; i <= n ; i ++ ) { if ( s . charAt ( i ) == ' o ' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s . charAt ( i ) == ' x ' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s . charAt ( i - coun - 1 ) == ' x ' ) ) left = 1 ; coun = ( int ) Math . ceil ( ( double ) coun / ( right + left ) ) ; max_length = Math . max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; } public static void main ( String args [ ] ) { String s = " oooxoooooooooxooo " ; int n = s . length ( ) ; System . out . println ( maxLength ( s , n ) ) ; } }
import java . io . * ; class GFG { static boolean areVowelsInOrder ( String s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' a ' || s . charAt ( i ) == ' e ' || s . charAt ( i ) == ' i ' || s . charAt ( i ) == ' o ' || s . charAt ( i ) == ' u ' ) { if ( s . charAt ( i ) < c ) return false ; else { c = s . charAt ( i ) ; } } } return true ; } public static void main ( String [ ] args ) { String s = " aabbbddeecc " ; if ( areVowelsInOrder ( s ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static int Remainder ( String str , int R ) { int len = str . length ( ) ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str . charAt ( i ) - '0' ) ; Rem = Num % R ; } return Rem ; } public static void main ( String [ ] args ) { String str = "13589234356546756" ; int R = 13 ; System . out . println ( Remainder ( str , R ) ) ; } }
import java . io . * ; class GFG { static int count_carry ( String a , String b ) { int carry = 0 ; int count = 0 ; int len_a = a . length ( ) , len_b = b . length ( ) ; while ( len_a != 0 len_b != 0 ) { int x = 0 , y = 0 ; if ( len_a > 0 ) { x = a . charAt ( len_a - 1 ) - '0' ; len_a -- ; } if ( len_b > 0 ) { y = b . charAt ( len_b - 1 ) - '0' ; len_b -- ; } int sum = x + y + carry ; if ( sum >= 10 ) { carry = 1 ; count ++ ; } else carry = 0 ; } return count ; } public static void main ( String [ ] args ) { String a = "9555" , b = "555" ; int count = count_carry ( a , b ) ; if ( count == 0 ) System . out . println ( "0NEW_LINE"); else if ( count == 1 ) System . out . println ( "1NEW_LINE"); else System . out . println ( count ) ; } }
class Geeks { static boolean isInGivenBase ( String str , int base ) { if ( base > 16 ) return false ; else if ( base <= 10 ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( str . charAt ( i ) >= '0' && str . charAt ( i ) < ( '0' + base ) ) ) return false ; } else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( ( str . charAt ( i ) >= '0' && str . charAt ( i ) < ( '0' + base ) ) || ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) < ( ' A ' + base - 10 ) ) ) ) return false ; } return true ; } public static void main ( String args [ ] ) { String str = " AF87" ; if ( isInGivenBase ( str , 16 ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static void printIndex ( String str , String s ) { boolean flag = false ; for ( int i = 0 ; i < str . length ( ) - s . length ( ) + 1 ; i ++ ) { if ( str . substring ( i , i + s . length ( ) ) . equals ( s ) ) { System . out . print ( i + " ▁ " ) ; flag = true ; } } if ( flag == false ) { System . out . println ( " NONE " ) ; } } public static void main ( String [ ] args ) { String str1 = " GeeksforGeeks " ; String str2 = " Geeks " ; printIndex ( str1 , str2 ) ; } }
class GFG { static int matchClosing ( char X [ ] , int start , int end , char open , char close ) { int c = 1 ; int i = start + 1 ; while ( i <= end ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i ++ ; } return i ; } static int matchingOpening ( char X [ ] , int start , int end , char open , char close ) { int c = - 1 ; int i = end - 1 ; while ( i >= start ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i -- ; } return - 1 ; } static boolean isBalanced ( char X [ ] , int n ) { int i , j = 0 , k , x , start , end ; for ( i = 0 ; i < n ; i ++ ) { if ( X [ i ] == ' ( ' ) { j = matchClosing ( X , i , n - 1 , ' ( ' , ' ) ' ) ; } else if ( X [ i ] == ' { ' ) { j = matchClosing ( X , i , n - 1 , ' { ' , ' } ' ) ; } else if ( X [ i ] == ' [ ' ) { j = matchClosing ( X , i , n - 1 , ' [ ' , ' ] ' ) ; } else { if ( X [ i ] == ' ) ' ) { j = matchingOpening ( X , 0 , i , ' ( ' , ' ) ' ) ; } else if ( X [ i ] == ' } ' ) { j = matchingOpening ( X , 0 , i , ' { ' , ' } ' ) ; } else if ( X [ i ] == ' ] ' ) { j = matchingOpening ( X , 0 , i , ' [ ' , ' ] ' ) ; } if ( j < 0 j >= i ) { return false ; } continue ; } if ( j >= n j < 0 ) { return false ; } start = i ; end = j ; for ( k = start + 1 ; k < end ; k ++ ) { if ( X [ k ] == ' ( ' ) { x = matchClosing ( X , k , end , ' ( ' , ' ) ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ) ' ) { x = matchingOpening ( X , start , k , ' ( ' , ' ) ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' { ' ) { x = matchClosing ( X , k , end , ' { ' , ' } ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' } ' ) { x = matchingOpening ( X , start , k , ' { ' , ' } ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' [ ' ) { x = matchClosing ( X , k , end , ' [ ' , ' ] ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ] ' ) { x = matchingOpening ( X , start , k , ' [ ' , ' ] ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } } } return true ; } public static void main ( String [ ] args ) { char X [ ] = " [ ( ) ] ( ) " . toCharArray ( ) ; int n = 6 ; if ( isBalanced ( X , n ) ) System . out . printf ( "YesNEW_LINE"); else System . out . printf ( "NoNEW_LINE"); char Y [ ] = " [ [ ( ) ] ] ) " . toCharArray ( ) ; n = 7 ; if ( isBalanced ( Y , n ) ) System . out . printf ( "YesNEW_LINE"); else System . out . printf ( "NoNEW_LINE"); } }
import java . util . * ; import java . lang . * ; class GFG { public static String possibleToSort ( int arr [ ] , int n , String str ) { int max_element = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str . charAt ( i ) == '0' ) { if ( max_element > i + 1 ) return " No " ; } } return " Yes " ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 5 , 3 , 4 , 6 } ; int n = arr . length ; String str = "01110" ; System . out . println ( possibleToSort ( arr , n , str ) ) ; } }
import java . io . * ; class GFG { static boolean isPrimeString ( String str ) { int len = str . length ( ) , n = 0 ; for ( int i = 0 ; i < len ; i ++ ) n += ( int ) str . charAt ( i ) ; if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } public static void main ( String [ ] args ) { String str = " geekRam " ; if ( isPrimeString ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static final int MAX = 256 ; static long fact ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int countPalinPermutations ( String str ) { int n = str . length ( ) ; int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) ] ++ ; long res = fact ( n / 2 ) ; boolean oddFreq = false ; for ( int i = 0 ; i < MAX ; i ++ ) { int half = freq [ i ] / 2 ; if ( freq [ i ] % 2 != 0 ) { if ( oddFreq == true ) return 0 ; oddFreq = true ; } res = res / fact ( half ) ; } return ( int ) res ; } public static void main ( String [ ] args ) { String str = " gffg " ; System . out . print ( countPalinPermutations ( str ) ) ; } }
import java . io . * ; class GFG { static boolean checkPalindrome ( String str ) { int n = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str . charAt ( i ) != str . charAt ( n - i - 1 ) ) ++ count ; return ( count <= 1 ) ; } public static void main ( String [ ] args ) { String str = " abccaa " ; if ( checkPalindrome ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int evenDecimalValue ( String str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) { result += ( n - i ) ; } } return result ; } public static void main ( String [ ] args ) { String str = "10010" ; int n = 5 ; System . out . println ( evenDecimalValue ( str , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int countSubstr ( String s ) { int n = s . length ( ) ; int [ ] auxArr = new int [ n ] ; if ( s . charAt ( 0 ) == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s . charAt ( i ) == '1' ) count += auxArr [ i ] ; return count ; } public static void main ( String [ ] args ) { String s = "1101" ; System . out . println ( countSubstr ( s ) ) ; } }
class GFG { static int MAX = 256 ; static boolean canMakeStr2 ( String str1 , String str2 ) { int [ ] count = new int [ MAX ] ; char [ ] str3 = str1 . toCharArray ( ) ; for ( int i = 0 ; i < str3 . length ; i ++ ) count [ str3 [ i ] ] ++ ; char [ ] str4 = str2 . toCharArray ( ) ; for ( int i = 0 ; i < str4 . length ; i ++ ) { if ( count [ str4 [ i ] ] == 0 ) return false ; count [ str4 [ i ] ] -- ; } return true ; } static public void main ( String [ ] args ) { String str1 = " geekforgeeks " ; String str2 = " for " ; if ( canMakeStr2 ( str1 , str2 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static void finalPosition ( String move ) { int l = move . length ( ) ; int countUp = 0 , countDown = 0 ; int countLeft = 0 , countRight = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( move . charAt ( i ) == ' U ' ) countUp ++ ; else if ( move . charAt ( i ) == ' D ' ) countDown ++ ; else if ( move . charAt ( i ) == ' L ' ) countLeft ++ ; else if ( move . charAt ( i ) == ' R ' ) countRight ++ ; } System . out . println ( " Final ▁ Position : ▁ ( " + ( countRight - countLeft ) + " , ▁ " + ( countUp - countDown ) + " ) " ) ; } public static void main ( String [ ] args ) { String move = " UDDLLRUUUDUURUDDUULLDRRRR " ; finalPosition ( move ) ; } }
import java . io . * ; class GFG { static int maxbalancedprefix ( String str , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; } public static void main ( String [ ] args ) { String str = " ( ( ( ) ( ) ) ( ) ) ( ( " ; int n = str . length ( ) ; System . out . println ( maxbalancedprefix ( str , n ) ) ; } }
import java . io . * ; class GFG { static int cost ( String str ) { int len = str . length ( ) ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str . charAt ( i ) != str . charAt ( j ) ) res += Math . min ( str . charAt ( i ) , str . charAt ( j ) ) - ' a ' + 1 ; return res ; } public static void main ( String [ ] args ) { String str = " abcdef " ; System . out . println ( cost ( str ) ) ; } }
import java . io . * ; public class GFG { static int MAX_CHAR = 256 ; static boolean isPresent ( String s , String q ) { int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s . charAt ( i ) ] ++ ; for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q . charAt ( i ) ] -- ; if ( freq [ q . charAt ( i ) ] < 0 ) return false ; } return true ; } static public void main ( String [ ] args ) { String s = " abctd " ; String q = " cat " ; if ( isPresent ( s , q ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int countReduce ( String str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += Math . abs ( str . charAt ( i ) - str . charAt ( n - i - 1 ) ) ; return res ; } public static void main ( String [ ] args ) { String str = " abcd " ; System . out . println ( countReduce ( str ) ) ; } }
import java . io . * ; class GFG { static int calculate ( String s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s . charAt ( 0 ) - '0' ) c ++ ; if ( j != s . charAt ( 1 ) - '0' ) c ++ ; if ( k != s . charAt ( 2 ) - '0' ) c ++ ; if ( l != s . charAt ( 3 ) - '0' ) c ++ ; if ( m != s . charAt ( 4 ) - '0' ) c ++ ; if ( n != s . charAt ( 5 ) - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; } static public void main ( String [ ] args ) { String s = "123456" ; System . out . println ( calculate ( s ) ) ; } }
import java . util . * ; class GFG { static boolean makeAndCheckString ( Vector < String > words , String str ) { int n = words . size ( ) ; boolean first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( words . get ( i ) == str ) return true ; if ( str . charAt ( 0 ) == words . get ( i ) . charAt ( 1 ) ) first = true ; if ( str . charAt ( 1 ) == words . get ( i ) . charAt ( 0 ) ) second = true ; if ( first && second ) return true ; } return false ; } public static void main ( String [ ] args ) { String str = " ya " ; String [ ] array = { " ah " , " oy " , " to " , " ha " } ; Vector < String > words = new Vector < String > ( Arrays . asList ( array ) ) ; if ( makeAndCheckString ( words , str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static boolean sentencePalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; str = str . toLowerCase ( ) ; while ( l <= h ) { char getAtl = str . charAt ( l ) ; char getAth = str . charAt ( h ) ; if ( ! ( getAtl >= ' a ' && getAtl <= ' z ' ) ) l ++ ; else if ( ! ( getAth >= ' a ' && getAth <= ' z ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; } public static void main ( String [ ] args ) { String str = " Too ▁ hot ▁ to ▁ hoot . " ; if ( sentencePalindrome ( str ) ) System . out . println ( " Sentence ▁ is ▁ palindrome " ) ; else System . out . println ( " Sentence ▁ is ▁ not " + " ▁ " + " palindrome " ) ; } }
import java . util . * ; class CountWays { static int xorZero ( String s ) { int one_count = 0 , zero_count = 0 ; char [ ] str = s . toCharArray ( ) ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; } public static void main ( String [ ] args ) { String s = "11111" ; System . out . println ( xorZero ( s ) ) ; } }
public class GFG { static final int MAX_CHAR = 26 ; static boolean checkCorrectOrNot ( String s ) { int [ ] count = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s . charAt ( i ) - ' a ' ] ++ ; count [ s . charAt ( j ) - ' a ' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; } public static void main ( String args [ ] ) { String s = " abab " ; if ( checkCorrectOrNot ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GfG { boolean uniqueCharacters ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int bitAtIndex = str . charAt ( i ) - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) return false ; checker = checker | ( 1 << bitAtIndex ) ; } return true ; } public static void main ( String args [ ] ) { GfG obj = new GfG ( ) ; String input = " geekforgeeks " ; if ( obj . uniqueCharacters ( input ) ) System . out . println ( " The ▁ String ▁ " + input + " ▁ has ▁ all ▁ unique ▁ characters " ) ; else System . out . println ( " The ▁ String ▁ " + input + " ▁ has ▁ duplicate ▁ characters " ) ; } }
class Number { public static void isKthBitSet ( int n , int k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) System . out . print ( " SET " ) ; else System . out . print ( " NOT ▁ SET " ) ; } public static void main ( String [ ] args ) { int n = 5 , k = 1 ; isKthBitSet ( n , k ) ; } }
import java . io . * ; class GFG { static boolean isPalRec ( String str , int s , int e ) { if ( s == e ) return true ; if ( ( str . charAt ( s ) ) != ( str . charAt ( e ) ) ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } static boolean isPalindrome ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; } public static void main ( String args [ ] ) { String str = " geeg " ; if ( isPalindrome ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static final int MAX_CHAR = 26 ; static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; } public static void main ( String args [ ] ) { String s = " abcab " ; System . out . println ( countSubstringWithEqualEnds ( s ) ) ; } }
class GFG { static char maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } cur_count = 1 ; } } return res ; } public static void main ( String args [ ] ) { String str = " aaaabbaaccde " ; System . out . println ( maxRepeating ( str ) ) ; } }
import java . io . * ; public class GFG { static void query ( String s , int i , int j ) { int n = s . length ( ) ; i %= n ; j %= n ; if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } static public void main ( String [ ] args ) { String X = " geeksforgeeks " ; query ( X , 0 , 8 ) ; query ( X , 8 , 13 ) ; query ( X , 6 , 15 ) ; } }
class Test { static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; return result ; } public static void main ( String args [ ] ) { String str = " geeksforgeeks " ; System . out . println ( countPairs ( str ) ) ; } }
class GFG { static void longestString ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] , count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; } String result = " " ; { for ( int j = 1 ; j <= Math . min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result += ( char ) ( ' a ' + i ) ; } } System . out . println ( result ) ; } public static void main ( String [ ] args ) { String str1 = " geeks " , str2 = " cake " ; longestString ( str1 , str2 ) ; } }
import java . util . Arrays ; public class CountKSubStr { int countkDist ( String str , int k ) { int res = 0 ; int n = str . length ( ) ; int cnt [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; Arrays . fill ( cnt , 0 ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) - ' a ' ] == 0 ) dist_count ++ ; cnt [ str . charAt ( j ) - ' a ' ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; } public static void main ( String [ ] args ) { CountKSubStr ob = new CountKSubStr ( ) ; String ch = " abcbaa " ; int k = 3 ; System . out . println ( " Total ▁ substrings ▁ with ▁ exactly ▁ " + k + " ▁ distinct ▁ characters ▁ : ▁ " + ob . countkDist ( ch , k ) ) ; } }
import java . io . * ; class GFG { static long removeRecur ( long n ) { long prev_digit = n % 10 ; long pow = 10 ; long res = prev_digit ; while ( n > 0 ) { long curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; } public static void main ( String [ ] args ) { long n = 12224 ; System . out . println ( removeRecur ( n ) ) ; } }
import java . util . * ; class GFG { static void printTheArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; } static void generateAllBinaryStrings ( int n , int arr [ ] , int i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; } public static void main ( String args [ ] ) { int n = 4 ; int [ ] arr = new int [ n ] ; generateAllBinaryStrings ( n , arr , 0 ) ; } }
import java . io . * ; class GFG { static int firstDigit ( int n ) { while ( n >= 10 ) { n /= 10 ; } return n ; } static int getCount ( int n ) { int count = 1 ; while ( n != 0 ) { int leadDigit = firstDigit ( n ) ; n -= leadDigit ; count ++ ; } return count ; } static int getLargestNumber ( int k ) { int left = k ; int right = k * 10 ; int mid = ( left + right ) / 2 ; int len = getCount ( mid ) ; while ( len != k ) { mid = ( left + right ) / 2 ; len = getCount ( mid ) ; if ( len > k ) { right = mid ; } else { left = mid ; } } while ( len == k ) { if ( len != getCount ( mid + 1 ) ) { break ; } mid ++ ; } return ( mid ) ; } public static void main ( String [ ] args ) { int k = 3 ; System . out . println ( getLargestNumber ( k ) ) ; } }
class GFG { static void diameter ( double r ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " + " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " + 2 * r ) ; } public static void main ( String [ ] args ) { double r = 4 ; diameter ( r ) ; } }
class GfG { static double getSlope ( double m ) { return m ; } public static void main ( String [ ] args ) { double m = 2 ; System . out . println ( getSlope ( m ) ) ; } }
class GFG { public static int totalTriangles ( int h , int v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; int total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; } public static void main ( String [ ] args ) { int h = 2 , v = 2 ; System . out . print ( totalTriangles ( h , v ) ) ; } }
import java . lang . Math ; class gfg { static float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; float x = r ; float V = ( float ) ( 4 * 3.14f * Math . pow ( r , 3 ) ) / 3 ; return V ; } public static void main ( String [ ] args ) { float r = 5 , R = 8 , h = 11 ; System . out . println ( sph ( r , R , h ) ) ; } }
import java . io . * ; class GFG { static boolean checkOrtho ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int m1 , m2 ; if ( x2 - x1 == 0 && x4 - x3 == 0 ) return false ; else if ( x2 - x1 == 0 ) { m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m2 == 0 ) return true ; else return false ; } else if ( x4 - x3 == 0 ) { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; if ( m1 == 0 ) return true ; else return false ; } else { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m1 * m2 == - 1 ) return true ; else return false ; } } public static void main ( String [ ] args ) { int x1 = 0 , y1 = 4 , x2 = 0 , y2 = - 9 ; int x3 = 2 , y3 = 0 , x4 = - 1 , y4 = 0 ; if ( checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static double pentdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.22 * a ; return d ; } static public void main ( String args [ ] ) { double a = 6 ; System . out . println ( pentdiagonal ( a ) ) ; } }
import java . lang . Math ; public class GfG { public static float hexagonArea ( float d ) { return ( float ) ( ( 3 * Math . sqrt ( 3 ) * d * d ) / 8 ) ; } public static void main ( String [ ] args ) { float d = 10 ; System . out . println ( " Area ▁ of ▁ hexagon : ▁ " + hexagonArea ( d ) ) ; } }
import java . util . * ; class solution { static int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; } public static void main ( String arr [ ] ) { int n = 6 , m = 6 , a = 4 ; System . out . println ( Squares ( n , m , a ) ) ; } }
import java . util . * ; class solution { static double octadiagonal ( double a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; } public static void main ( String args [ ] ) { double a = 4 ; System . out . println ( octadiagonal ( a ) ) ; } }
import java . io . * ; class GFG { static void CalPeri ( ) { int S = 5 , Perimeter ; Perimeter = 10 * S ; System . out . println ( " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ " + Perimeter ) ; } public static void main ( String [ ] args ) { CalPeri ( ) ; } }
import java . io . * ; class GFG { static double findEdges ( double s1 , double s2 , double s3 ) { double a = Math . sqrt ( s1 * s2 / s3 ) ; double b = Math . sqrt ( s3 * s1 / s2 ) ; double c = Math . sqrt ( s3 * s2 / s1 ) ; double sum = a + b + c ; return 4 * sum ; } public static void main ( String [ ] args ) { double s1 , s2 , s3 ; s1 = 65 ; s2 = 156 ; s3 = 60 ; System . out . print ( findEdges ( s1 , s2 , s3 ) ) ; } }
import java . util . * ; class GFG { public static int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( " Max ▁ number ▁ of ▁ pieces ▁ for ▁ n ▁ = ▁ " + n + " ▁ is ▁ " + findMaximumPieces ( 3 ) ) ; } }
public class GFG { static void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) System . out . println ( " Coplanar " ) ; else System . out . println ( " Not ▁ Coplanar " ) ; } public static void main ( String [ ] args ) { int x1 = 3 ; int y1 = 2 ; int z1 = - 5 ; int x2 = - 1 ; int y2 = 4 ; int z2 = - 3 ; int x3 = - 3 ; int y3 = 8 ; int z3 = - 5 ; int x4 = - 3 ; int y4 = 2 ; int z4 = 1 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; } }
import java . io . * ; import java . lang . Math ; class GFG { static void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = ( float ) Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = ( float ) Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = ( float ) 3.14159 ; float A = ( 180 / pi ) * ( float ) ( Math . acos ( d ) ) ; System . out . println ( " Angle ▁ is ▁ " + A + " ▁ degree " ) ; } public static void main ( String [ ] args ) { float a1 = 1 ; float b1 = 1 ; float c1 = 2 ; float d1 = 1 ; float a2 = 2 ; float b2 = - 1 ; float c2 = 1 ; float d2 = - 4 ; distance ( a1 , b1 , c1 , a2 , b2 , c2 ) ; } }
import java . io . * ; class GFG { static void mirror_point ( int a , int b , int c , int d , int x1 , int y1 , int z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; System . out . print ( " x3 ▁ = ▁ " + x3 + " ▁ " ) ; System . out . print ( " y3 ▁ = ▁ " + y3 + " ▁ " ) ; System . out . print ( " z3 ▁ = ▁ " + z3 + " ▁ " ) ; } public static void main ( String [ ] args ) { int a = 1 ; int b = - 2 ; int c = 0 ; int d = 0 ; int x1 = - 1 ; int y1 = 3 ; int z1 = 4 ; mirror_point ( a , b , c , d , x1 , y1 , z1 ) ; } }
import java . io . * ; class GFG { static int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; } public static void main ( String [ ] args ) { int radius = 2 ; int totalRectangles ; totalRectangles = countRectangles ( radius ) ; System . out . println ( totalRectangles + " ▁ rectangles ▁ can ▁ be ▁ " + " cut ▁ from ▁ a ▁ circle ▁ of " + " ▁ Radius ▁ " + radius ) ; } }
import java . util . * ; class GFG1 { static int simi_aaa ( int a1 [ ] , int a2 [ ] ) { Arrays . sort ( a1 ) ; Arrays . sort ( a2 ) ; if ( a1 [ 0 ] == a2 [ 0 ] && a1 [ 1 ] == a2 [ 1 ] && a1 [ 2 ] == a2 [ 2 ] ) return 1 ; else return 0 ; } static int simi_sas ( int s1 [ ] , int s2 [ ] , int a1 [ ] , int a2 [ ] ) { Arrays . sort ( a1 ) ; Arrays . sort ( a2 ) ; Arrays . sort ( s1 ) ; Arrays . sort ( s2 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] ) { if ( a1 [ 2 ] == a2 [ 2 ] ) return 1 ; } if ( s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] ) { if ( a1 [ 0 ] == a2 [ 0 ] ) return 1 ; } if ( s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) { if ( a1 [ 1 ] == a2 [ 1 ] ) return 1 ; } return 0 ; } static int simi_sss ( int s1 [ ] , int s2 [ ] ) { Arrays . sort ( s1 ) ; Arrays . sort ( s2 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] && s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] && s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) return 1 ; return 0 ; } public static void main ( String args [ ] ) { int s1 [ ] = { 2 , 3 , 3 } ; int s2 [ ] = { 4 , 6 , 6 } ; int a1 [ ] = { 80 , 60 , 40 } ; int a2 [ ] = { 40 , 60 , 80 } ; int aaa = simi_aaa ( a1 , a2 ) ; int sss = simi_sss ( s1 , s2 ) ; int sas = simi_sas ( s1 , s2 , a1 , a2 ) ; if ( aaa == 1 sss == 1 sas == 1 ) { System . out . print ( " Triangles ▁ are ▁ " + " similar ▁ by ▁ " ) ; if ( aaa == 1 ) System . out . print ( " AAA ▁ " ) ; if ( sss == 1 ) System . out . print ( " SSS ▁ " ) ; if ( sas == 1 ) System . out . print ( " SAS . " ) ; } else System . out . println ( " Triangles ▁ are ▁ " + " not ▁ similar " ) ; } }
import java . io . * ; class GFG { static long center_pentadecagonal_num ( long n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; } public static void main ( String [ ] args ) { long n = 3 ; System . out . print ( n + " th ▁ number ▁ : ▁ " ) ; System . out . println ( center_pentadecagonal_num ( n ) ) ; n = 10 ; System . out . print ( n + " th ▁ number ▁ : ▁ " ) ; System . out . println ( center_pentadecagonal_num ( n ) ) ; } }
import java . io . * ; class GFG { static int center_nonadecagon_num ( int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . print ( n + " th ▁ centered ▁ " + " nonadecagonal ▁ number ▁ : ▁ " ) ; System . out . println ( center_nonadecagon_num ( n ) ) ; n = 7 ; System . out . print ( n + " th ▁ centered ▁ " + " nonadecagonal ▁ number ▁ : ▁ " ) ; System . out . println ( center_nonadecagon_num ( n ) ) ; } }
import java . io . * ; class GFG { static int hendecagonal_num ( int n ) { return ( 9 * n * n - 7 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( n + " rd ▁ Hendecagonal ▁ " + " number : ▁ " ) ; System . out . println ( hendecagonal_num ( n ) ) ; n = 10 ; System . out . print ( n + " th ▁ Hendecagonal ▁ " + " number : ▁ " ) ; System . out . println ( hendecagonal_num ( n ) ) ; } }
import java . io . * ; class GFG { static int centeredoctagonalNumber ( int n ) { return 4 * n * ( n - 1 ) + 1 ; } public static void main ( String args [ ] ) { int n = 6 ; System . out . print ( n + " th ▁ centered ▁ " + " octagonal ▁ number : ▁ " ) ; System . out . println ( centeredoctagonalNumber ( n ) ) ; n = 11 ; System . out . print ( n + " th ▁ centered ▁ " + " octagonal ▁ number : ▁ " ) ; System . out . println ( centeredoctagonalNumber ( n ) ) ; } }
import java . io . * ; public class GFG { static boolean isValid ( int [ ] arr , int i , int j , int m , int c ) { if ( i == j ) return false ; int lhs = arr [ j ] ; int rhs = m * arr [ i ] + c ; return ( lhs == rhs ) ; } static int findOrderedPoints ( int [ ] arr , int n , int m , int c ) { int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int firstIndex = i , secondIndex = j ; if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) counter ++ ; } } return counter ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 2 , 3 , 4 , 2 } ; int n = arr . length ; int m = 1 , c = 1 ; System . out . print ( findOrderedPoints ( arr , n , m , c ) ) ; } }
import java . io . * ; class ring { public static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; } public static void main ( String args [ ] ) { int r = 8 , R = 4 , r1 = 2 , x1 = 6 , y1 = 0 ; if ( checkcircle ( r , R , r1 , x1 , y1 ) ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; } }
import java . io . * ; import java . util . * ; class GFG { static double surface_area_octahedron ( double side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; } public static void main ( String [ ] args ) { double side = 7 ; System . out . println ( " Surface ▁ area ▁ of ▁ octahedron ▁ = " + surface_area_octahedron ( side ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int nCk ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } public static int count_Straightlines ( int n , int m ) { return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) ; } public static void main ( String argc [ ] ) { int n = 4 , m = 3 ; System . out . println ( count_Straightlines ( n , m ) ) ; } }
import java . io . * ; class GFG { static double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; } public static void main ( String [ ] args ) { int side = 4 ; System . out . print ( " Volume ▁ of ▁ dodecahedron ▁ = ▁ " ) ; System . out . println ( vol_of_dodecahedron ( side ) ) ; } }
import java . util . * ; class GFG { static void overflow ( int H , int r , int h , int N , int R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) { System . out . println ( " Overflow " ) ; } else { System . out . println ( " Not ▁ in ▁ overflow ▁ state " ) ; } } public static void main ( String [ ] args ) { int H = 10 , r = 5 , h = 5 , N = 2 , R = 2 ; overflow ( H , r , h , N , R ) ; } }
class Number { public static float volume ( int radius , int height ) { return ( ( 22 / 7 ) * radius * radius * height ) ; } public static void check_and_print ( double required_time , double given_time ) { if ( required_time < given_time ) System . out . print ( " Overflow " ) ; else if ( required_time > given_time ) System . out . print ( " Underflow " ) ; else System . out . print ( " Filled " ) ; } public static void main ( String [ ] args ) { int radius = 5 , height = 10 , rate_of_flow = 10 ; double given_time = 70.0 ; double required_time = volume ( radius , height ) / rate_of_flow ; check_and_print ( required_time , given_time ) ; } }
class GFG { static float cal_cos ( float n ) { float accuracy = 0.0001f , x1 ; float denominator , cosx , cosval ; n = n * ( 3.142f / 180.0f ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; return cosx ; } static float third_side ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return ( float ) Math . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; } public static void main ( String [ ] args ) { float c = 49 ; int a = 5 , b = 8 ; System . out . print ( Math . round ( third_side ( a , b , c ) * 100000.0 ) / 100000.0 ) ; } }
import java . util . * ; class GFG { static void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) System . out . println ( " Fits " ) ; else System . out . println ( " Doesn ' t ▁ Fit " ) ; } public static void main ( String [ ] args ) { int R = 8 , r = 4 ; int x = 5 , y = 3 , rad = 3 ; fitOrNotFit ( R , r , x , y , rad ) ; } }
class Test { static boolean checkPolygonWithMidpoints ( int arr [ ] , int N , int midpoints ) { for ( int j = 0 ; j < midpoints ; j ++ ) { int val = 1 ; for ( int k = j ; k < N ; k += midpoints ) { val &= arr [ k ] ; } if ( val != 0 && N / midpoints > 2 ) { System . out . println ( " Polygon ▁ possible ▁ with ▁ side ▁ length ▁ " + N / midpoints ) ; return true ; } } return false ; } static void isPolygonPossible ( int arr [ ] , int N ) { int limit = ( int ) Math . sqrt ( N ) ; for ( int i = 1 ; i <= limit ; i ++ ) { if ( N % i == 0 ) { if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , ( N / i ) ) ) return ; } } System . out . println ( " Not ▁ possible " ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; isPolygonPossible ( arr , arr . length ) ; } }
class GFG { static float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001f ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } static int findMaximumHeight ( int N ) { int n = 1 + 8 * N ; int maxH = ( int ) ( - 1 + squareRoot ( n ) ) / 2 ; return maxH ; } public static void main ( String [ ] args ) { int N = 12 ; System . out . print ( findMaximumHeight ( N ) ) ; } }
import java . util . Arrays ; class GFG { static void calculateSpan ( int price [ ] , int n , int S [ ] ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } static void printArray ( int arr [ ] ) { System . out . print ( Arrays . toString ( arr ) ) ; } public static void main ( String [ ] args ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = price . length ; int S [ ] = new int [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S ) ; } }
class Main { static void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " ▁ - - ▁ " + next ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = arr . length ; printNGE ( arr , n ) ; } }
import java . util . * ; import java . io . * ; import java . math . * ; class GFG { static void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod ) { if ( n == 1 ) { System . out . println ( " Move ▁ disk ▁ 1 ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; } public static void main ( String args [ ] ) { int n = 4 ; towerOfHanoi ( n , ' A ' , ' C ' , ' B ' ) ; } }
class Test { static int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; static void printMaxOfMin ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } System . out . print ( maxOfMin + " ▁ " ) ; } } public static void main ( String [ ] args ) { printMaxOfMin ( arr . length ) ; } }
import java . util . Stack ; public class GFG { static Stack < Integer > st = new Stack < > ( ) ; static void push_digits ( int number ) { while ( number != 0 ) { st . push ( number % 10 ) ; number = number / 10 ; } } static int reverse_number ( int number ) { push_digits ( number ) ; int reverse = 0 ; int i = 1 ; while ( ! st . isEmpty ( ) ) { reverse = reverse + ( st . peek ( ) * i ) ; st . pop ( ) ; i = i * 10 ; } return reverse ; } public static void main ( String [ ] args ) { int number = 39997 ; System . out . println ( reverse_number ( number ) ) ; } }
public class HeapSort { void heapify ( int arr [ ] , int n , int i ) { int largest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ; if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ; if ( largest != i ) { int swap = arr [ i ] ; arr [ i ] = arr [ largest ] ; arr [ largest ] = swap ; heapify ( arr , n , largest ) ; } } public void sort ( int arr [ ] ) { int n = arr . length ; for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { int temp = arr [ 0 ] ; arr [ 0 ] = arr [ i ] ; arr [ i ] = temp ; heapify ( arr , i , 0 ) ; } } static void printArray ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int n = arr . length ; HeapSort ob = new HeapSort ( ) ; ob . sort ( arr ) ; System . out . println ( " Sorted ▁ array ▁ is " ) ; printArray ( arr ) ; } }
class GFG { static boolean isHeap ( int arr [ ] , int i , int n ) { if ( i >= ( n - 2 ) / 2 ) { return true ; } if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) { return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = arr . length - 1 ; if ( isHeap ( arr , 0 , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class GFG { static boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = arr . length ; if ( isHeap ( arr , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class GFG { static void generate_derangement ( int N ) { int S [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( D [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { generate_derangement ( 10 ) ; } }
class GFG { static int Profit ( int costPrice , int sellingPrice ) { int profit = ( sellingPrice - costPrice ) ; return profit ; } static int Loss ( int costPrice , int sellingPrice ) { int Loss = ( costPrice - sellingPrice ) ; return Loss ; } public static void main ( String [ ] args ) { int costPrice = 1500 , sellingPrice = 2000 ; if ( sellingPrice == costPrice ) System . out . println ( " No ▁ profit ▁ nor ▁ Loss " ) ; else if ( sellingPrice > costPrice ) System . out . println ( Profit ( costPrice , sellingPrice ) + " ▁ Profit ▁ " ) ; else System . out . println ( Loss ( costPrice , sellingPrice ) + " ▁ Loss ▁ " ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int nextPerfectSquare ( int N ) { int nextN = ( int ) Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; } public static void main ( String args [ ] ) { int n = 35 ; System . out . println ( nextPerfectSquare ( n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void printSubstrings ( int n ) { int s = ( int ) Math . log10 ( n ) ; int d = ( int ) ( Math . pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n > 0 ) { while ( d > 0 ) { System . out . println ( n / d ) ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } } public static void main ( String args [ ] ) { int n = 123 ; printSubstrings ( n ) ; } }
import java . util . * ; class GFG { static long MOD = ( long ) ( 1e9 + 7 ) ; static long powerLL ( long x , long n ) { long result = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { result = result * x % MOD ; } n = n / 2 ; x = x * x % MOD ; } return result ; } static long powerStrings ( String sa , String sb ) { long a = 0 , b = 0 ; for ( int i = 0 ; i < sa . length ( ) ; i ++ ) { a = ( a * 10 + ( sa . charAt ( i ) - '0' ) ) % MOD ; } for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { b = ( b * 10 + ( sb . charAt ( i ) - '0' ) ) % ( MOD - 1 ) ; } return powerLL ( a , b ) ; } public static void main ( String [ ] args ) { String sa = "2" , sb = "3" ; System . out . println ( powerStrings ( sa , sb ) ) ; } }
class GFG { static boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static int previousPowerOfTwo ( int n ) { while ( ( n & n - 1 ) > 1 ) { n = n & n - 1 ; } return n ; } static boolean checkSum ( int n ) { if ( n == 0 n == 1 ) return false ; else if ( isPowerOfTwo ( n ) ) { System . out . println ( n / 2 + " ▁ " + n / 2 ) ; } else { int x = previousPowerOfTwo ( n ) ; int y = n - x ; if ( isPowerOfTwo ( y ) ) { System . out . println ( x + " ▁ " + y ) ; return true ; } } return false ; } public static void main ( String [ ] argc ) { int n1 = 20 ; if ( checkSum ( n1 ) == false ) System . out . println ( " No " ) ; System . out . println ( ) ; int n2 = 11 ; if ( checkSum ( n2 ) == false ) System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int complement ( int num ) { int i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = num / 10 ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = ( int ) Math . pow ( 10 , len ) - num ; return comp ; } public static void main ( String [ ] args ) { System . out . println ( complement ( 25 ) ) ; System . out . println ( complement ( 456 ) ) ; } }
class Test { static int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
import java . io . * ; class GFG { static long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( " Sum ▁ of ▁ all ▁ elements : " + calculateSum ( n ) ) ; } }
import java . io . * ; class GFG { static int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return ( int ) ( Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ) ; } else { return ( int ) ( Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } } public static void main ( String [ ] args ) { int N = 2 ; System . out . print ( findAllSequence ( N ) ) ; } }
import java . io . * ; class GFG { static int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int n = 13 ; System . out . println ( countOnes ( n ) ) ; } }
class GFG { static int largestNum ( int a , int b ) { return a * ( ( a / b ) > 0 ? 1 : 0 ) + b * ( ( b / a ) > 0 ? 1 : 0 ) ; } public static void main ( String [ ] args ) { int a = 22 , b = 1231 ; System . out . print ( largestNum ( a , b ) ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { int c = a % b ; while ( c != 0 ) { a = b ; b = c ; c = a % b ; } return b ; } static int numberOfmeet ( int a , int b ) { int ans ; if ( a > b ) ans = a - b ; else ans = b - a ; if ( a < 0 ) a = a * ( - 1 ) ; if ( b < 0 ) b = b * ( - 1 ) ; return ans / gcd ( a , b ) ; } public static void main ( String [ ] args ) { int a = 1 , b = - 1 ; System . out . println ( numberOfmeet ( a , b ) ) ; } }
import java . io . * ; class GFG { static void printGreater ( int x , int y ) { double X = y * Math . log ( x ) ; double Y = x * Math . log ( y ) ; if ( Math . abs ( X - Y ) < 1e-9 ) { System . out . println ( " Equal " ) ; } else if ( X > Y ) { System . out . println ( x + " ^ " + y ) ; } else { System . out . println ( y + " ^ " + x ) ; } } public static void main ( String [ ] args ) { int x = 5 , y = 8 ; printGreater ( x , y ) ; } }
import java . io . * ; class Series { static int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( sumOfSeries ( n ) ) ; } }
class GFG { static double mulmod ( long a , long b , long mod ) { a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } static long findProduct ( long N ) { long product = 1 , fact = 1 ; long MOD = ( long ) ( 1e9 + 7 ) ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( long ) mulmod ( fact , i , MOD ) ; product = ( long ) mulmod ( product , fact , MOD ) ; if ( product == 0 ) return 0 ; } return product ; } public static void main ( String [ ] args ) { long N = 3 ; System . out . println ( findProduct ( N ) ) ; N = 5 ; System . out . println ( findProduct ( N ) ) ; } }
import java . math . * ; class GFG { static int divSum ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + n / i ; return sum ; } static boolean areEquivalent ( int num1 , int num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; } public static void main ( String [ ] args ) { int num1 = 559 ; int num2 = 703 ; if ( areEquivalent ( num1 , num2 ) ) System . out . println ( " Equivalent " ) ; else System . out . println ( " Not ▁ Equivalent " ) ; } }
import java . io . * ; class GFG { static int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( n + " the ▁ Dodecahedral " + " ▁ number : " ) ; System . out . println ( dodecahedral_num ( n ) ) ; } }
import java . io . * ; class GFG { static int bit ( int x ) { int ans = 0 ; while ( x > 0 ) { x /= 2 ; ans ++ ; } return ans ; } static boolean check ( int d , int x ) { if ( bit ( x / d ) <= bit ( d ) ) return true ; return false ; } static int bs ( int n ) { int l = 1 , r = ( int ) Math . sqrt ( n ) ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; } static int countDivisor ( int n ) { return n - bs ( n ) + 1 ; } static public void main ( String [ ] args ) { int n = 5 ; System . out . println ( countDivisor ( n ) ) ; } }
import java . io . * ; class GFG { static void swap ( int a , int b ) { int t = a ; a = b ; b = t ; } static boolean everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ; if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } while ( x1 >= x2 ) { if ( x1 == x2 ) return true ; x1 = x1 + v1 ; x2 = x2 + v2 ; } return false ; } public static void main ( String [ ] args ) { int x1 = 5 , v1 = 8 , x2 = 4 , v2 = 7 ; if ( everMeet ( x1 , x2 , v1 , v2 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; import java . io . * ; class GFG { static String check ( int k , int d0 , int d1 ) { int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x = 0 ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } int sum = d0 + d1 + ( ( ( k - 3 ) / 4 ) * s + x ) ; if ( sum % 3 == 0 ) return " YES " ; return " NO " ; } public static void main ( String [ ] args ) { int k , d0 , d1 ; k = 13 ; d0 = 8 ; d1 = 1 ; System . out . println ( check ( k , d0 , d1 ) ) ; k = 5 ; d0 = 3 ; d1 = 4 ; System . out . println ( check ( k , d0 , d1 ) ) ; } }
import java . io . * ; class GFG { public static void main ( String args [ ] ) { int a = 4 ; int b = 3 , val = 0 ; if ( ( a % b ) != 0 ) val = ( a / b ) + ( a % b ) ; else val = ( a / b ) ; System . out . println ( " The ▁ ceiling ▁ " + " value ▁ of ▁ 4/3 ▁ is ▁ " + val ) ; a = 6 ; b = 3 ; if ( ( a % b ) != 0 ) val = ( a / b ) + ( a % b ) ; else val = ( a / b ) ; System . out . println ( " The ▁ ceiling ▁ " + " value ▁ of ▁ 6/3 ▁ is ▁ " + val ) ; } }
import java . io . * ; class GFG { static void printCollatz ( int n ) { while ( n != 1 ) { System . out . print ( n + " ▁ " ) ; if ( ( n & 1 ) == 1 ) n = 3 * n + 1 ; else n = n / 2 ; } System . out . print ( n ) ; } public static void main ( String [ ] args ) { printCollatz ( 6 ) ; } }
import java . util . * ; class GFG { static void block ( long x ) { ArrayList < Integer > v = new ArrayList < Integer > ( ) ; System . out . print ( " Blocks ▁ for ▁ " + x + " ▁ : ▁ " ) ; while ( x > 0 ) { v . add ( ( int ) x % 2 ) ; x = x / 2 ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . get ( i ) == 1 ) { System . out . print ( i ) ; if ( i != v . size ( ) - 1 ) System . out . print ( " , ▁ " ) ; } } System . out . println ( ) ; } public static void main ( String args [ ] ) { block ( 71307 ) ; block ( 1213 ) ; block ( 29 ) ; block ( 100 ) ; } }
class GFG { static void findNumberOfDigits ( long n , int base ) { int dig = ( int ) ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; System . out . println ( " The ▁ Number ▁ of ▁ digits ▁ of ▁ Number ▁ " + n + " ▁ in ▁ base ▁ " + base + " ▁ is ▁ " + dig ) ; } public static void main ( String [ ] args ) { long n = 1446 ; int base = 7 ; findNumberOfDigits ( n , base ) ; } }
class GFG { static boolean isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; } public static void main ( String args [ ] ) { double a = 1.0 , b = 2.0 , c = 3.0 ; if ( isValidNesbitt ( a , b , c ) == true ) { System . out . print ( " Nesbitt ' s ▁ inequality " + " ▁ satisfied . " ) ; System . out . println ( " for ▁ real ▁ numbers ▁ " + a + " , ▁ " + b + " , ▁ " + c ) ; } else System . out . println ( " Nesbitts ▁ inequality " + " ▁ not ▁ satisfied " ) ; } }
class GFG { public static void printCubeFree ( int n ) { boolean [ ] cubFree = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ; for ( int i = 2 ; i * i * i <= n ; i ++ ) { if ( cubFree [ i ] ) { for ( int multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { printCubeFree ( 20 ) ; } }
class GFG { public static int isTriangular ( int num ) { if ( num < 0 ) return 0 ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return - 1 ; double root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; double root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( ( int ) ( root1 ) > 0 && ( int ) ( Math . floor ( root1 ) ) == ( int ) ( root1 ) ) return ( int ) ( root1 ) ; if ( ( int ) ( root2 ) > 0 && ( int ) ( Math . floor ( root2 ) ) == ( int ) ( root2 ) ) return ( int ) ( root2 ) ; return - 1 ; } static int isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; if ( ( sr - Math . floor ( sr ) ) == 0 ) return ( int ) ( Math . floor ( sr ) ) ; else return - 1 ; } static int findS ( int s ) { int sr = isPerfectSquare ( s ) ; if ( sr == - 1 ) return - 1 ; return isTriangular ( sr ) ; } public static void main ( String [ ] args ) { int s = 9 ; int n = findS ( s ) ; if ( n == - 1 ) System . out . println ( " - 1" ) ; else System . out . println ( n ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static int trickyCase ( String s , int index ) { int index1 = - 1 ; for ( int i = index - 1 ; i >= 0 ; i -- ) { int digit = s . charAt ( i ) - '0' ; if ( digit != 8 ) { index1 = i ; break ; } } if ( index1 == - 1 ) return 2 * ( int ) Math . pow ( 10 , s . length ( ) ) ; int num = 0 ; for ( int i = 0 ; i < index1 ; i ++ ) num = num * 10 + ( s . charAt ( i ) - '0' ) ; if ( s . charAt ( index1 ) % 2 == 0 ) num = num * 10 + ( s . charAt ( index1 ) - '0' + 2 ) ; else num = num * 10 + ( s . charAt ( index1 ) - '0' + 1 ) ; for ( int i = index1 + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 ; return num ; } static int smallestNumber ( int n ) { int num = 0 ; String s = " " ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int digit = s . charAt ( i ) - '0' ; int val = digit & 1 ; if ( val == 1 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; if ( s . charAt ( index ) == '9' ) { num = trickyCase ( s , index ) ; return num ; } for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s . charAt ( i ) - '0' ) ; num = num * 10 + ( s . charAt ( index ) - '0' + 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 ; return num ; } public static void main ( String args [ ] ) { int N = 2397 ; System . out . print ( smallestNumber ( N ) ) ; } }
import java . util . * ; import java . lang . * ; public class GFG { public static int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } } public static void main ( String [ ] args ) { System . out . print ( findNth ( 5 ) ) ; } }
class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( findSum ( n ) ) ; } }
class GFG { static int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; class GFG { static int totalSumDivisibleByNum ( int digit , int number ) { int firstnum = ( int ) Math . pow ( 10 , digit - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 , number = 7 ; System . out . println ( totalSumDivisibleByNum ( n , number ) ) ; } }
import java . io . * ; import java . lang . * ; class GFG { public static int Nth_of_AP ( int a , int d , int N ) { return ( a + ( N - 1 ) * d ) ; } public static void main ( String [ ] args ) { int a = 2 ; int d = 1 ; int N = 5 ; System . out . print ( " The ▁ " + N + " th ▁ term ▁ of ▁ the ▁ series ▁ is ▁ : ▁ " + Nth_of_AP ( a , d , N ) ) ; } }
class GFG { static boolean checkFibinnary ( int n ) { int prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; } public static void main ( String [ ] args ) { int n = 10 ; if ( checkFibinnary ( n ) == true ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( sumOfSeries ( n ) ) ; } }
import java . io . * ; class GFG { static int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( Nonagonal ( n ) ) ; } }
import java . io . * ; class GFG { static Boolean divisibleBy20 ( String num ) { int lastTwoDigits = Integer . parseInt ( num . substring ( num . length ( ) - 2 , num . length ( ) ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; } public static void main ( String [ ] args ) { String num = "63284689320" ; if ( divisibleBy20 ( num ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static boolean isDvisibleBy12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num . charAt ( i ) ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = Integer . parseInt ( num ) ; return ( number % 12 == 0 ) ; } } public static void main ( String [ ] args ) { String num = "12244824607284961224" ; if ( isDvisibleBy12 ( num ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . io . * ; class GfG { static Boolean check ( int n ) { int d = ( int ) Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } static int largestNonPerfectSquareNumber ( int a [ ] , int n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! check ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; } public static void main ( String [ ] args ) { int a [ ] = { 16 , 20 , 25 , 2 , 3 , 10 } ; int n = a . length ; System . out . println ( largestNonPerfectSquareNumber ( a , n ) ) ; } }
class GFG { static void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( curr_term + " ▁ " ) ; curr_term = curr_term + d ; } } public static void main ( String [ ] args ) { int a = 2 ; int d = 1 ; int n = 5 ; printAP ( a , d , n ) ; } }
import java . io . * ; import java . math . * ; class GFG { static void printNonSquare ( int n ) { int curr_count = 2 , num = 2 , count = 0 ; while ( count < n ) { for ( int i = 0 ; i < curr_count && count < n ; i ++ ) { System . out . print ( num + " ▁ " ) ; count ++ ; num ++ ; } num ++ ; curr_count += 2 ; } } public static void main ( String args [ ] ) { int n = 10 ; printNonSquare ( n ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int countZeroso ( int [ ] a , int n ) { int count2 = 0 , count5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] = a [ i ] / 2 ; count2 ++ ; } while ( a [ i ] % 5 == 0 ) { a [ i ] = a [ i ] / 5 ; count5 ++ ; } } return ( count2 < count5 ) ? count2 : count5 ; } public static void main ( String argc [ ] ) { int [ ] a = new int [ ] { 10 , 100 , 20 , 30 , 50 , 91 , 12 , 80 } ; int n = 8 ; System . out . println ( countZeroso ( a , n ) ) ; } }
import java . io . * ; class GFG { static int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; } public static void main ( String args [ ] ) throws IOException { System . out . println ( squareSum ( 8 ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static long [ ] pwr ; static Boolean isMunchhausen ( int n ) { long sum = 0l ; int temp = n ; while ( temp > 0 ) { int index = temp % 10 ; sum = sum + pwr [ index ] ; temp /= 10 ; } return ( sum == n ) ; } static void printMunchhausenNumbers ( int n ) { pwr = new long [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) pwr [ i ] = ( long ) Math . pow ( ( float ) i , ( float ) i ) ; for ( int i = 1 ; i <= n ; i ++ ) if ( isMunchhausen ( i ) == true ) System . out . println ( i ) ; } public static void main ( String [ ] args ) { int n = 10000 ; printMunchhausenNumbers ( n ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int kthdigit ( int a , int b , int k ) { int p = ( int ) Math . pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; } public static void main ( String argc [ ] ) { int a = 5 , b = 2 ; int k = 1 ; System . out . println ( kthdigit ( a , b , k ) ) ; } }
import java . util . * ; class GFG { static long digSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } static long PowDigSum ( long n , long x ) { long sum = digSum ( n ) ; long rem = x % 6 ; if ( ( sum == 3 sum == 6 ) && x > 1 ) return 9 ; else if ( x == 1 ) return sum ; else if ( x == 0 ) return 1 ; else if ( rem == 0 ) return digSum ( ( long ) Math . pow ( sum , 6 ) ) ; else return digSum ( ( long ) Math . pow ( sum , rem ) ) ; } public static void main ( String [ ] args ) { int n = 33333 ; int x = 332654 ; System . out . println ( PowDigSum ( n , x ) ) ; } }
import java . util . * ; class Area { public static int maxArea ( int A [ ] , int len ) { int l = 0 ; int r = len - 1 ; int area = 0 ; while ( l < r ) { area = Math . max ( area , Math . min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 5 , 4 , 3 } ; int b [ ] = { 3 , 1 , 2 , 4 , 5 } ; int len1 = 4 ; System . out . print ( maxArea ( a , len1 ) + "NEW_LINE" ); int len2 = 5 ; System . out . print ( maxArea ( b , len2 ) ) ; } }
import java . io . * ; class GFG { static int mobius ( int n ) { int p = 0 ; if ( n % 2 == 0 ) { n = n / 2 ; p ++ ; if ( n % 2 == 0 ) return 0 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; p ++ ; if ( n % i == 0 ) return 0 ; } } return ( p % 2 == 0 ) ? - 1 : 1 ; } public static void main ( String [ ] args ) { int N = 17 ; System . out . println ( " Mobius ▁ Functions " + " ▁ M ( N ) ▁ at ▁ N ▁ = ▁ " + N + " ▁ is : ▁ " + mobius ( N ) ) ; System . out . println ( " Mobius ▁ Functions " + " M ( N ) ▁ at ▁ N ▁ = ▁ " + 25 + " ▁ is : ▁ " + mobius ( 25 ) ) ; System . out . println ( " Mobius ▁ Functions " + " M ( N ) ▁ at ▁ N ▁ = ▁ " + 6 + " ▁ is : ▁ " + mobius ( 6 ) ) ; } }
class GFG { static int factorial ( int start , int end ) { int res = 1 ; for ( int i = start ; i <= end ; i ++ ) res *= i ; return res ; } static int sumofsquare ( int n ) { return factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( sumofsquare ( n ) ) ; } }
class GFG { static double PHI = 1.6180339 ; static int f [ ] = { 0 , 1 , 1 , 2 , 3 , 5 } ; static int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . round ( fn * PHI ) ; t ++ ; } return fn ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . println ( n + " th ▁ Fibonacci ▁ Number ▁ = ▁ " + fib ( n ) ) ; } }
import java . io . * ; class Euler { float func ( float x , float y ) { return ( x + y + x * y ) ; } void euler ( float x0 , float y , float h , float x ) { float temp = - 0 ; while ( x0 < x ) { temp = y ; y = y + h * func ( x0 , y ) ; x0 = x0 + h ; } System . out . println ( " Approximate ▁ solution ▁ at ▁ x ▁ = ▁ " + x + " ▁ is ▁ " + y ) ; } public static void main ( String args [ ] ) throws IOException { Euler obj = new Euler ( ) ; float x0 = 0 ; float y0 = 1 ; float h = 0.025f ; float x = 0.1f ; obj . euler ( x0 , y0 , h , x ) ; } }
import java . io . * ; class GfG { static void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( " x ▁ = ▁ " + i + " , ▁ y ▁ = ▁ " + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( " No ▁ solution " ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , n = 7 ; solution ( a , b , n ) ; } }
import java . io . * ; class GFG { static int binomialCoeffSum ( int n ) { return ( 1 << n ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( binomialCoeffSum ( n ) ) ; } }
import java . util . * ; class Eulerian { public static void precisionCompute ( int x , int y , int n ) { if ( y == 0 ) { System . out . print ( " Infinite " ) ; return ; } if ( x == 0 ) { System . out . print ( "0" ) ; return ; } if ( n <= 0 ) { System . out . print ( x / y ) ; return ; } if ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) { System . out . print ( " - " ) ; x = x > 0 ? x : - x ; y = y > 0 ? y : - y ; } int d = x / y ; for ( int i = 0 ; i <= n ; i ++ ) { System . out . print ( d ) ; x = x - ( y * d ) ; if ( x == 0 ) break ; x = x * 10 ; d = x / y ; if ( i == 0 ) System . out . print ( " . " ) ; } } public static void main ( String [ ] args ) { int x = 22 , y = 7 , n = 15 ; precisionCompute ( x , y , n ) ; } }
import java . io . * ; class GFG { static void quadrant ( int x , int y ) { if ( x > 0 && y > 0 ) System . out . println ( " lies ▁ in ▁ First ▁ quadrant " ) ; else if ( x < 0 && y > 0 ) System . out . println ( " lies ▁ in ▁ Second ▁ quadrant " ) ; else if ( x < 0 && y < 0 ) System . out . println ( " lies ▁ in ▁ Third ▁ quadrant " ) ; else if ( x > 0 && y < 0 ) System . out . println ( " lies ▁ in ▁ Fourth ▁ quadrant " ) ; else if ( x == 0 && y > 0 ) System . out . println ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) ; else if ( x == 0 && y < 0 ) System . out . println ( " lies ▁ at ▁ negative ▁ y ▁ axis " ) ; else if ( y == 0 && x < 0 ) System . out . println ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) ; else if ( y == 0 && x > 0 ) System . out . println ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) ; else System . out . println ( " lies ▁ at ▁ origin " ) ; } public static void main ( String [ ] args ) { int x = 1 , y = 1 ; quadrant ( x , y ) ; } }
import java . util . * ; class Prime { public static boolean checkDigits ( int n ) { while ( n > 0 ) { int dig = n % 10 ; if ( dig != 2 && dig != 3 && dig != 5 && dig != 7 ) return false ; n /= 10 ; } return true ; } public static boolean prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } public static boolean isFullPrime ( int n ) { return ( checkDigits ( n ) && prime ( n ) ) ; } public static void main ( String [ ] args ) { int n = 53 ; if ( isFullPrime ( n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . Arrays ; class GFG { static final int MAX = 500 ; static int nthSHN ( int n , int dp [ ] ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; } public static void main ( String [ ] args ) { int n = 6 ; int dp [ ] = new int [ MAX ] ; Arrays . fill ( dp , - 1 ) ; System . out . println ( nthSHN ( n , dp ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { static int evenSum ( int n ) { int curr = 2 , sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; } public static void main ( String argc [ ] ) { int n = 20 ; System . out . println ( " Sum ▁ of ▁ first ▁ " + n + " ▁ Even ▁ numbers ▁ is : ▁ " + evenSum ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { static int evenSum ( int n ) { return ( n * ( n + 1 ) ) ; } public static void main ( String argc [ ] ) { int n = 20 ; System . out . println ( " Sum ▁ of ▁ first ▁ " + n + " ▁ Even ▁ numbers ▁ is : ▁ " + evenSum ( n ) ) ; } }
import java . io . * ; class GFG { static double kmphTOmph ( double kmph ) { return 0.6214 * kmph ; } static double mphTOkmph ( double mph ) { return mph * 1.60934 ; } public static void main ( String [ ] args ) { double kmph = 150 ; double mph = 100 ; System . out . println ( " speed ▁ in ▁ miles / hr ▁ is ▁ " + kmphTOmph ( kmph ) ) ; System . out . println ( " speed ▁ in ▁ km / hr ▁ is ▁ " + mphTOkmph ( mph ) ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findNumber ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 2 , 4 } ; int n = arr . length ; System . out . println ( findNumber ( arr , n ) ) ; } }
import java . util . * ; class GFG { static ArrayList < Integer > primes = new ArrayList < Integer > ( ) ; static void SieveofEratosthenes ( int n ) { boolean [ ] visited = new boolean [ n * n + 2 ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) if ( ! visited [ i ] ) { for ( int j = i * i ; j <= n + 1 ; j += i ) visited [ j ] = true ; primes . add ( i ) ; } } static boolean specialPrimeNumbers ( int n , int k ) { SieveofEratosthenes ( n ) ; int count = 0 ; for ( int i = 0 ; i < primes . size ( ) ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( primes . get ( j ) + primes . get ( j + 1 ) + 1 == primes . get ( i ) ) { count ++ ; break ; } } if ( count == k ) return true ; } return false ; } public static void main ( String [ ] args ) { int n = 27 , k = 2 ; if ( specialPrimeNumbers ( n , k ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static void factorize ( long n ) { int count = 0 ; while ( ! ( n % 2 > 0 ) ) { n >>= 1 ; count ++ ; } if ( count > 0 ) { System . out . println ( "2" + " ▁ " + count ) ; } for ( long i = 3 ; i <= ( long ) Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count > 0 ) { System . out . println ( i + " ▁ " + count ) ; } } if ( n > 2 ) { System . out . println ( n + " ▁ " + "1" ) ; } } public static void main ( String [ ] args ) { long n = 1000000000000000000L ; factorize ( n ) ; } }
import java . util . * ; class GFG { static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; return __gcd ( b % a , a ) ; } static int minimumMoves ( int A [ ] , int N ) { int one = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] == 1 ) one ++ ; if ( one != 0 ) return N - one ; int minimum = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int g = A [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { g = __gcd ( A [ j ] , g ) ; if ( g == 1 ) { minimum = Math . min ( minimum , j - i ) ; break ; } } } if ( minimum == Integer . MAX_VALUE ) return - 1 ; else return N + minimum - 1 ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 4 , 3 , 9 } ; int N = A . length ; System . out . print ( minimumMoves ( A , N ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static void series ( int n , int d ) { if ( d == 0 ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( "0 ▁ " ) ; System . out . println ( ) ; return ; } if ( n % 2 == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( Math . pow ( - 1 , i ) * d + " ▁ " ) ; } System . out . println ( ) ; } else { float m = n ; float r = ( m / ( m - 1 ) ) ; float g = ( float ) ( d * ( float ) ( Math . sqrt ( r ) ) ) ; System . out . print ( "0 ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { System . out . print ( Math . pow ( - 1 , i ) * g + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String args [ ] ) { int n = 3 , d = 3 ; series ( n , d ) ; } }
class GFG { static int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { String str = String . valueOf ( i ) ; countr += str . split ( "1" , - 1 ) . length - 1 ; } return countr ; } public static void main ( String [ ] args ) { int n = 13 ; System . out . println ( countDigitOne ( n ) ) ; n = 131 ; System . out . println ( countDigitOne ( n ) ) ; n = 159 ; System . out . println ( countDigitOne ( n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class exp_sq { static long exponentiation ( long base , long exp ) { long t = 1L ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * base ) % N ; base = ( base * base ) % N ; exp /= 2 ; } return t % N ; } } public static void main ( String [ ] args ) { long base = 5 ; long exp = 100000 ; long modulo = exponentiation ( base , exp ) ; System . out . println ( modulo ) ; }
public class FactorialGCD { static int factorial ( int x ) { if ( x <= 1 ) return 1 ; int res = 2 ; for ( int i = 3 ; i <= x ; i ++ ) res = res * i ; return res ; } static int gcdOfFactorial ( int m , int n ) { int min = m < n ? m : n ; return factorial ( min ) ; } public static void main ( String [ ] args ) { int m = 5 , n = 9 ; System . out . println ( gcdOfFactorial ( m , n ) ) ; } }
import java . io . * ; class GFG { static int recDigSum ( int n ) { if ( n == 0 ) return 0 ; else { if ( n % 9 == 0 ) return 9 ; else return n % 9 ; } } static void check ( int n ) { n = recDigSum ( n ) ; if ( n == 2 n == 3 n == 5 n == 7 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int n = 5602 ; check ( n ) ; } }
import java . io . * ; class GFG { static int findNumber ( int n ) { int x = ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; } public static void main ( String [ ] args ) { int n = 55 ; System . out . println ( findNumber ( n ) ) ; } }
import java . io . * ; public class GFG { static int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; } static public void main ( String [ ] args ) { int n = 10 ; System . out . println ( weightedMean ( n ) ) ; } }
import java . io . * ; class GFG { static void calculate ( int a [ ] , int b [ ] , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . floor ( a [ i ] / mul ) ; System . out . print ( x + " ▁ " ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 5 , 100 , 8 } ; int b [ ] = { 2 , 3 } ; int n = a . length ; int m = b . length ; calculate ( a , b , n , m ) ; } }
class GFG { static void print ( int n ) { System . out . println ( n + n / 2 ) ; for ( int i = 2 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; for ( int i = 1 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; for ( int i = 2 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 3 ; print ( n ) ; } }
class GFG { static int lcm_fun ( int a , int b ) { if ( b == 0 ) return a ; return lcm_fun ( b , a % b ) ; } static int digitLCM ( int n ) { int lcm = 1 ; while ( n > 0 ) { lcm = ( n % 10 * lcm ) / lcm_fun ( n % 10 , lcm ) ; if ( lcm == 0 ) return 0 ; n = n / 10 ; } return lcm ; } public static void main ( String [ ] args ) { int n = 397 ; System . out . println ( digitLCM ( n ) ) ; } }
import java . util . * ; class GFG { static double e = 2.71828 ; static int roundNo ( float num ) { return ( int ) ( num < 0 ? num - 0.5 : num + 0.5 ) ; } static void printBestCandidate ( int candidate [ ] , int n ) { int sample_size = roundNo ( ( float ) ( n / e ) ) ; System . out . println ( " Sample size is " + sample_size); int best = 0 ; for ( int i = 1 ; i < sample_size ; i ++ ) if ( candidate [ i ] > candidate [ best ] ) best = i ; for ( int i = sample_size ; i < n ; i ++ ) if ( candidate [ i ] >= candidate [ best ] ) { best = i ; break ; } if ( best >= sample_size ) System . out . println ( " Best candidate found is " +  ( best + 1 ) + " ▁ with ▁ talent ▁ " + candidate [ best ] ) ; else System . out . print ( "Couldn't find a best candidateNEW_LINE"); } public static void main ( String [ ] args ) { int n = 8 ; int [ ] candidate = new int [ n ] ; Random rand = new Random ( ) ; for ( int i = 0 ; i < n ; i ++ ) candidate [ i ] = 1 + rand . nextInt ( ( 8 - 1 ) + 1 ) ; System . out . print ( " Candidate ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( i + 1 + " ▁ " ) ; System . out . println ( ) ; System . out . print ( " Talents ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( candidate [ i ] + " ▁ " ) ; printBestCandidate ( candidate , n ) ; } }
class GFG { static double u_cal ( double u , int n ) { double temp = u ; for ( int i = 1 ; i < n ; i ++ ) temp = temp * ( u + i ) ; return temp ; } static int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } public static void main ( String [ ] args ) { int n = 5 ; double x [ ] = { 1891 , 1901 , 1911 , 1921 , 1931 } ; double [ ] [ ] y = new double [ n ] [ n ] ; y [ 0 ] [ 0 ] = 46 ; y [ 1 ] [ 0 ] = 66 ; y [ 2 ] [ 0 ] = 81 ; y [ 3 ] [ 0 ] = 93 ; y [ 4 ] [ 0 ] = 101 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= i ; j -- ) y [ j ] [ i ] = y [ j ] [ i - 1 ] - y [ j - 1 ] [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) System . out . print ( y [ i ] [ j ] + " TABSYMBOL " ) ; System . out . println ( " " ) ; ; } double value = 1925 ; double sum = y [ n - 1 ] [ 0 ] ; double u = ( value - x [ n - 1 ] ) / ( x [ 1 ] - x [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { sum = sum + ( u_cal ( u , i ) * y [ n - 1 ] [ i ] ) / fact ( i ) ; } System . out . println ( " Value at " + value + " ▁ is ▁ " + String . format ( " % .6g % n " , sum ) ) ; } }
import java . io . * ; class GFG { static int sumDigitSquare ( int n ) { int sq = 0 ; while ( n != 0 ) { int digit = n % 10 ; sq += digit * digit ; n = n / 10 ; } return sq ; } static boolean isHappy ( int n ) { while ( true ) { if ( n == 1 ) return true ; n = sumDigitSquare ( n ) ; if ( n == 4 ) return false ; } } public static void main ( String args [ ] ) { int n = 23 ; if ( isHappy ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( findSumSubsets ( n ) ) ; } }
import java . util . * ; class GFG { static int findMin ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . log ( a [ i ] ) ; int x = ( int ) Math . exp ( sum / n ) ; return x + 1 ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 2 , 1 , 4 } ; int n = a . length ; System . out . println ( findMin ( a , n ) ) ; } }
class GFG { static int countdigits ( int N ) { int count = 0 ; while ( N > 0 ) { count ++ ; N = N / 10 ; } return count ; } static void cyclic ( int N ) { int num = N ; int n = countdigits ( N ) ; while ( true ) { System . out . println ( num ) ; int rem = num % 10 ; int dev = num / 10 ; num = ( int ) ( ( Math . pow ( 10 , n - 1 ) ) * rem + dev ) ; if ( num == N ) break ; } } public static void main ( String [ ] args ) { int N = 5674 ; cyclic ( N ) ; } }
import java . lang . * ; class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean checkCircular ( int N ) { int count = 0 , temp = N ; while ( temp > 0 ) { count ++ ; temp /= 10 ; } int num = N ; while ( isPrime ( num ) ) { int rem = num % 10 ; int div = num / 10 ; num = ( int ) ( ( Math . pow ( 10 , count - 1 ) ) * rem ) + div ; if ( num == N ) return true ; } return false ; } public static void main ( String [ ] args ) { int N = 1193 ; if ( checkCircular ( N ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Arrays ; public class GFG { static boolean sackRace ( int p1 , int s1 , int p2 , int s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; } public static void main ( String args [ ] ) { int p1 = 4 , s1 = 4 , p2 = 8 , s2 = 2 ; if ( sackRace ( p1 , s1 , p2 , s2 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { public static void solve ( int n ) { double a = n / 2 ; if ( n % 2 != 0 ) { System . out . println ( ( Math . ceil ( a ) - 1 ) + " ▁ " + ( Math . floor ( a ) + 1 ) ) ; } else { if ( ( int ) ( a ) % 2 == 0 ) { System . out . println ( ( Math . ceil ( a ) - 1 ) + " ▁ " + ( Math . floor ( a ) + 1 ) ) ; } else { System . out . println ( ( Math . ceil ( a ) - 2 ) + " ▁ " + ( Math . floor ( a ) + 2 ) ) ; } } } public static void main ( String [ ] args ) { int n = 34 ; solve ( n ) ; } }
import java . io . * ; class GFG { public static void main ( String args [ ] ) { float P = 1 , R = 1 , T = 1 ; float SI = ( P * T * R ) / 100 ; System . out . println ( " Simple ▁ interest ▁ = ▁ " + SI ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; } public static void main ( String args [ ] ) { int a = 33 ; int b = - 24 ; System . out . println ( " Number ▁ of ▁ digits ▁ = ▁ " + countDigits ( a , b ) ) ; } }
import java . io . * ; public class GFG { static void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) System . out . println ( "1" ) ; else System . out . println ( "0" ) ; } int mul = ( int ) Math . pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; System . out . println ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; } static public void main ( String [ ] args ) { int a = 349 , b = 1 , x = 4 ; multiple ( a , b , x ) ; } }
public class Main { static int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( maxSum ( n ) ) ; } }
class GFG { static int minNum ( int arr [ ] , int n ) { Boolean odd = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . length ; System . out . println ( minNum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static boolean checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; } public static void main ( String [ ] args ) { int num = - 1234 ; if ( checkJumbled ( num ) ) System . out . println ( " True ▁ " ) ; else System . out . println ( " False ▁ " ) ; num = - 1247 ; if ( checkJumbled ( num ) ) System . out . println ( " True ▁ " ) ; else System . out . println ( " False ▁ " ) ; } }
public class GFG { static int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; } static int josephify ( int n ) { int position = msbPos ( n ) ; int j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; } public static void main ( String [ ] args ) { int n = 41 ; System . out . println ( josephify ( n ) ) ; } }
public class CountXor { static int countXorPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; System . out . println ( countXorPair ( arr , arr . length ) ) ; } }
class GFG { static int powmod ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int [ ] value = new int [ m ] ; for ( int i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( int j = 0 ; j < n ; ++ j ) { int cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , m = 5 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; a = 3 ; b = 7 ; m = 11 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; } }
class GFG { static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , m = 5 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; a = 3 ; b = 7 ; m = 11 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; } }
import java . util . * ; class GFG { static String nthprimedigitsnumber ( int number ) { int rem ; String num = " " ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += '2' ; break ; case 2 : num += '3' ; break ; case 3 : num += '5' ; break ; case 0 : num += '7' ; break ; } if ( number % 4 == 0 ) number -- ; number = number / 4 ; } return new StringBuilder ( num ) . reverse ( ) . toString ( ) ; } public static void main ( String [ ] args ) { int number = 21 ; System . out . println ( nthprimedigitsnumber ( 10 ) ) ; System . out . println ( nthprimedigitsnumber ( 21 ) ) ; } }
class Test { static int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= Math . cbrt ( N ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = ( int ) Math . cbrt ( diff ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; } public static void main ( String args [ ] ) { for ( int i = 1 ; i <= 10 ; i ++ ) System . out . println ( " For ▁ n ▁ = ▁ " + i + " , ▁ " + + countPairs ( i ) + " ▁ pair ▁ exists " ) ; } }
import java . util . Arrays ; import java . util . Vector ; class Test { static void printEqualModNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; if ( d == 0 ) { System . out . println ( " Infinite ▁ solution " ) ; return ; } Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . add ( i ) ; if ( i != d / i ) v . add ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v . get ( i ) ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ; if ( j == n ) System . out . print ( v . get ( i ) + " ▁ " ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 38 , 6 , 34 } ; printEqualModNumbers ( arr , arr . length ) ; } }
class Test { static int FirstDigit ( int arr [ ] , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - Math . floor ( S ) ; int ans = ( int ) Math . pow ( 10 , fract_S ) ; return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 8 , 3 , 7 } ; System . out . println ( FirstDigit ( arr , arr . length ) ) ; } }
class Test { static int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int n = 1012 ; System . out . println ( countDigit ( n ) ) ; } }
import java . io . * ; class GFG { static int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int ans = 1 ; while ( n % 2 == 0 ) { n /= 2 ; ans *= 2 ; } return ans ; } public static void main ( String [ ] args ) { int n = 36 ; int res = makeOdd ( n ) ; System . out . println ( res ) ; } }
import java . io . * ; class Solution { static int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; } public static void main ( String [ ] args ) { int n = 56287 , x = 27 ; System . out . println ( closestMultiple ( n , x ) ) ; } }
class Test { static void printCubes ( int a , int b ) { int acrt = ( int ) Math . cbrt ( a ) ; int bcrt = ( int ) Math . cbrt ( b ) ; for ( int i = acrt ; i <= bcrt ; i ++ ) if ( i * i * i >= a && i * i * i <= b ) System . out . print ( i * i * i + " ▁ " ) ; } public static void main ( String [ ] args ) { int a = 24 , b = 576 ; System . out . println ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : " ) ; printCubes ( a , b ) ; } }
class GFG { static int number0f2s ( int n ) { int count = 0 ; while ( n > 0 ) { if ( n % 10 == 2 ) count ++ ; n = n / 10 ; } return count ; } static int numberOf2sinRange ( int n ) { int count = 0 ; for ( int i = 2 ; i <= n ; i ++ ) count += number0f2s ( i ) ; return count ; } public static void main ( String [ ] args ) { System . out . print ( numberOf2sinRange ( 22 ) ) ; System . out . println ( ) ; System . out . print ( numberOf2sinRange ( 100 ) ) ; } }
import java . io . * ; class GFG { static int minToggle ( int arr [ ] , int n ) { int zero [ ] = new int [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 1 , 0 } ; int n = arr . length ; System . out . println ( minToggle ( arr , n ) ) ; } }
class IsDivisible { static boolean check ( String str ) { int n = str . length ( ) ; if ( ( str . charAt ( n - 1 ) - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; } public static void main ( String [ ] args ) { String str = "1332" ; if ( check ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; import java . util . * ; public class Solution { static int res = 0 ; static int checkRecursive ( int num , int x , int k , int n ) { if ( x == 0 ) res ++ ; int r = ( int ) Math . floor ( Math . pow ( num , 1.0 / n ) ) ; for ( int i = k + 1 ; i <= r ; i ++ ) { int a = x - ( int ) Math . pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - ( int ) Math . pow ( i , n ) , i , n ) ; } return res ; } static int check ( int x , int n ) { return checkRecursive ( x , x , 0 , n ) ; } public static void main ( String [ ] args ) { System . out . println ( check ( 10 , 2 ) ) ; } }
import java . util . * ; class GFG { static int reverseNum ( int n ) { int rem , rev = 0 ; while ( n > 0 ) { rem = n % 10 ; rev = rev * 10 + rem ; n /= 10 ; } return rev ; } static boolean isPalindrom ( int num ) { return num == reverseNum ( num ) ; } static int nthPalindrome ( int n , int k ) { int num = ( int ) Math . pow ( 10 , k - 1 ) ; while ( true ) { if ( isPalindrom ( num ) ) -- n ; if ( n == 0 ) break ; ++ num ; } return num ; } public static void main ( String [ ] args ) { int n = 6 , k = 5 ; System . out . println ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " + nthPalindrome ( n , k ) ) ; n = 10 ; k = 6 ; System . out . println ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " + nthPalindrome ( n , k ) ) ; } }
class GFG { static void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . pow ( 10 , temp ) ; palindrome += n - 1 ; System . out . print ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome /= 10 ; while ( palindrome > 0 ) { System . out . print ( palindrome % 10 ) ; palindrome /= 10 ; } System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int n = 6 , k = 5 ; System . out . print ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; n = 10 ; k = 6 ; System . out . print ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; } }
import java . lang . * ; class GFG { static final int MAX = 100001 ; static long phi [ ] = new long [ MAX ] ; static long result [ ] = new long [ MAX ] ; static void computeTotient ( ) { phi [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( phi [ i ] == 0 ) { phi [ i ] = i - 1 ; for ( int j = ( i << 1 ) ; j < MAX ; j += i ) { if ( phi [ j ] == 0 ) phi [ j ] = j ; phi [ j ] = ( phi [ j ] / i ) * ( i - 1 ) ; } } } } static void sumOfGcdPairs ( ) { computeTotient ( ) ; for ( int i = 1 ; i < MAX ; ++ i ) { for ( int j = 2 ; i * j < MAX ; ++ j ) result [ i * j ] += i * phi [ j ] ; } for ( int i = 2 ; i < MAX ; i ++ ) result [ i ] += result [ i - 1 ] ; } public static void main ( String [ ] args ) { sumOfGcdPairs ( ) ; int N = 4 ; System . out . println ( " Summation ▁ of ▁ " + N + " ▁ = ▁ " + result [ N ] ) ; N = 12 ; System . out . println ( " Summation ▁ of ▁ " + N + " ▁ = ▁ " + result [ N ] ) ; N = 5000 ; System . out . print ( " Summation ▁ of ▁ " + N + " ▁ = ▁ " + + result [ N ] ) ; } }
import java . util . Vector ; class GFG { static final int N = 3 ; static Vector < Integer > solve ( int v [ ] ) { Vector < Integer > res = new Vector < Integer > ( ) ; int all3 = v [ 0 ] + v [ 1 ] + v [ 2 ] ; res . add ( all3 - v [ 1 ] * 2 ) ; res . add ( all3 - v [ 2 ] * 2 ) ; res . add ( all3 - v [ 0 ] * 2 ) ; return res ; } static void findVertex ( int xmid [ ] , int ymid [ ] ) { Vector < Integer > V1 = solve ( xmid ) ; Vector < Integer > V2 = solve ( ymid ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( V1 . get ( i ) + " ▁ " + V2 . get ( i ) ) ; } } public static void main ( String [ ] args ) { int xmid [ ] = { 5 , 4 , 5 } ; int ymid [ ] = { 3 , 4 , 5 } ; findVertex ( xmid , ymid ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int nthElement ( int a , int b , int n ) { ArrayList < Integer > seq = new ArrayList < Integer > ( n * n + 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) seq . add ( a * i ) ; Collections . sort ( seq ) ; for ( int i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( seq . indexOf ( b * i ) == - 1 ) { seq . add ( b * i ) ; Collections . sort ( seq ) ; k -- ; } } return seq . get ( n - 1 ) ; } public static void main ( String [ ] args ) { int a = 3 , b = 5 , n = 5 ; System . out . println ( nthElement ( a , b , n ) ) ; } }
import java . util . * ; class GFG { static int gcd ( int a , int b ) { return b > 0 ? gcd ( b , a % b ) : a ; } static int countGCD ( int L , int R , int g ) { L = ( L + g - 1 ) / g ; R = R / g ; int ans = 0 ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( gcd ( i , j ) == 1 ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int L = 1 , R = 11 , g = 5 ; System . out . println ( countGCD ( L , R , g ) ) ; } }
class GFG { static int dig [ ] = { 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 } ; static int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; } public static void main ( String [ ] args ) { int n = 14 ; System . out . print ( lastNon0Digit ( n ) ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; } static int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; } public static void main ( String [ ] args ) { int x = 16 ; System . out . print ( firstFactorialDivisibleNumber ( x ) ) ; } }
import java . util . Arrays ; class GFG { static void sieve ( boolean prime [ ] , int n ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } static int maxDigitInPrimes ( int L , int R ) { boolean prime [ ] = new boolean [ R + 1 ] ; Arrays . fill ( prime , false ) ; sieve ( prime , R ) ; int freq [ ] = new int [ 10 ] ; int val ; for ( int i = L ; i <= R ; i ++ ) { if ( ! prime [ i ] ) { while ( p > 0 ) { freq [ p % 10 ] ++ ; p /= 10 ; } } } int max = freq [ 0 ] , ans = 0 ; for ( int j = 1 ; j < 10 ; j ++ ) { if ( max <= freq [ j ] ) { max = freq [ j ] ; ans = j ; } } return ( max != 0 ) ? ans : - 1 ; } public static void main ( String [ ] args ) { int L = 1 , R = 20 ; System . out . println ( maxDigitInPrimes ( L , R ) ) ; } }
class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int commDiv ( int a , int b ) { int n = gcd ( a , b ) ; int result = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) result += 1 ; else result += 2 ; } } return result ; } public static void main ( String args [ ] ) { int a = 12 , b = 24 ; System . out . println ( commDiv ( a , b ) ) ; } }
class GFG { static long spellsCount ( String num ) { int n = num . length ( ) ; long result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num . charAt ( i + 1 ) == num . charAt ( i ) ) { count ++ ; i ++ ; } result = result * ( long ) Math . pow ( 2 , count - 1 ) ; } return result ; } public static void main ( String [ ] args ) { String num = "11112" ; System . out . print ( spellsCount ( num ) ) ; } }
class GFG { static int numSquareSum ( int n ) { int squareSum = 0 ; while ( n != 0 ) { squareSum += ( n % 10 ) * ( n % 10 ) ; n /= 10 ; } return squareSum ; } static boolean isHappynumber ( int n ) { int slow , fast ; slow = fast = n ; do { slow = numSquareSum ( slow ) ; fast = numSquareSum ( numSquareSum ( fast ) ) ; } while ( slow != fast ) ; return ( slow == 1 ) ; } public static void main ( String [ ] args ) { int n = 13 ; if ( isHappynumber ( n ) ) System . out . println ( n + " ▁ is ▁ a ▁ Happy ▁ number " ) ; else System . out . println ( n + " ▁ is ▁ not ▁ a ▁ Happy ▁ number " ) ; } }
import java . util . * ; class GFG { static Vector < Integer > allPrimes = new Vector < Integer > ( ) ; static void sieve ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . add ( p ) ; } static long factorialDivisors ( int n ) { long result = 1 ; for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) { long p = allPrimes . get ( i ) ; long exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes . get ( i ) ; } result = result * ( exp + 1 ) ; } return result ; } public static void main ( String [ ] args ) { System . out . println ( factorialDivisors ( 6 ) ) ; } }
import java . io . * ; class GFG { static int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; } public static void main ( String args [ ] ) { System . out . println ( nonFibonacci ( 5 ) ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; } public static void main ( String args [ ] ) { int a = 34 , b = 17 ; System . out . println ( " Gcd ▁ of ▁ given ▁ " + " numbers ▁ is ▁ " + gcd ( a , b ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void findNDigitNumsUtil ( int n , char out [ ] , int index , int evenSum , int oddSum ) { if ( index > n ) return ; if ( index == n ) { if ( Math . abs ( evenSum - oddSum ) == 1 ) { out [ index ] = ' ▁ ' ; System . out . print ( out ) ; } return ; } if ( index % 2 != 0 ) { for ( int i = 0 ; i <= 9 ; i ++ ) { out [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum , oddSum + i ) ; } } { for ( int i = 0 ; i <= 9 ; i ++ ) { out [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } } } static void findNDigitNums ( int n ) { char [ ] out = new char [ n + 1 ] ; int index = 0 ; int evenSum = 0 , oddSum = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { out [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } } public static void main ( String [ ] args ) { int n = 3 ; findNDigitNums ( n ) ; } }
class GFG { static String one [ ] = { " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve ▁ " , " thirteen ▁ " , " fourteen ▁ " , " fifteen ▁ " , " sixteen ▁ " , " seventeen ▁ " , " eighteen ▁ " , " nineteen ▁ " } ; static String ten [ ] = { " " , " " , " twenty ▁ " , " thirty ▁ " , " forty ▁ " , " fifty ▁ " , " sixty ▁ " , " seventy ▁ " , " eighty ▁ " , " ninety ▁ " } ; static String numToWords ( int n , String s ) { String str = " " ; if ( n > 19 ) { str += ten [ n / 10 ] + one [ n % 10 ] ; } else { str += one [ n ] ; } if ( n != 0 ) { str += s ; } return str ; } static String convertToWords ( long n ) { String out = " " ; out += numToWords ( ( int ) ( n / 10000000 ) , " crore ▁ " ) ; out += numToWords ( ( int ) ( ( n / 100000 ) % 100 ) , " lakh ▁ " ) ; out += numToWords ( ( int ) ( ( n / 1000 ) % 100 ) , " thousand ▁ " ) ; out += numToWords ( ( int ) ( ( n / 100 ) % 10 ) , " hundred ▁ " ) ; if ( n > 100 && n % 100 > 0 ) { out += " and ▁ " ; } out += numToWords ( ( int ) ( n % 100 ) , " " ) ; return out ; } public static void main ( String [ ] args ) { long n = 438237764 ; System . out . printf ( convertToWords ( n ) ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { return ( a % b == 0 ) ? Math . abs ( b ) : gcd ( b , a % b ) ; } static boolean isPossible ( int a , int b , int c ) { return ( c % gcd ( a , b ) == 0 ) ; } public static void main ( String [ ] args ) { int a = 3 , b = 6 , c = 9 ; if ( isPossible ( a , b , c ) ) System . out . println ( " Possible " ) ; else System . out . println ( " Not ▁ Possible " ) ; a = 3 ; b = 6 ; c = 8 ; if ( isPossible ( a , b , c ) ) System . out . println ( " Possible " ) ; else System . out . println ( " Not ▁ Possible " ) ; a = 2 ; b = 5 ; c = 1 ; if ( isPossible ( a , b , c ) ) System . out . println ( " Possible " ) ; else System . out . println ( " Not ▁ Possible " ) ; } }
class GFG { static void farey ( int n ) { double x1 = 0 , y1 = 1 , x2 = 1 , y2 = n ; System . out . printf ( " % .0f / % . 0f ▁ % .0f / % . 0f " , x1 , y1 , x2 , y2 ) ; while ( y != 1.0 ) { x = Math . floor ( ( y1 + n ) / y2 ) * x2 - x1 ; y = Math . floor ( ( y1 + n ) / y2 ) * y2 - y1 ; System . out . printf ( " ▁ % .0f / % . 0f " , x , y ) ; x1 = x2 ; x2 = x ; y1 = y2 ; y2 = y ; } } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( " Farey ▁ Sequence ▁ of ▁ order ▁ " + n + " isNEW_LINE"); farey ( n ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; } static void findSmallest ( int a , int b ) { int lcm = ( a * b ) / gcd ( a , b ) ; System . out . print ( " x ▁ = ▁ " + lcm / a + " y = " + lcm / b); } public static void main ( String [ ] args ) { int a = 25 , b = 35 ; findSmallest ( a , b ) ; } }
class GFG { static int power ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static int modInverse ( int a , int p ) { return power ( a , p - 2 , p ) ; } static int modFact ( int n , int p ) { if ( p <= n ) return 0 ; int res = ( p - 1 ) ; for ( int i = n + 1 ; i < p ; i ++ ) res = ( res * modInverse ( i , p ) ) % p ; return res ; } public static void main ( String [ ] args ) { int n = 25 , p = 29 ; System . out . println ( modFact ( n , p ) ) ; } }
import java . io . * ; class GFG { static int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( countWays ( n ) ) ; } }
import java . io . * ; class GFG { static int pairAndSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 10 , 15 } ; int n = arr . length ; System . out . println ( pairAndSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int pairAndSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int k = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) k ++ ; } ans += ( 1 << i ) * ( k * ( k - 1 ) / 2 ) ; } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 10 , 15 } ; int n = arr . length ; System . out . println ( pairAndSum ( arr , n ) ) ; } }
class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } public static void main ( String args [ ] ) { if ( isPrime ( 11 ) ) System . out . println ( " ▁ true " ) ; else System . out . println ( " ▁ false " ) ; if ( isPrime ( 15 ) ) System . out . println ( " ▁ true " ) ; else System . out . println ( " ▁ false " ) ; } }
import java . util . * ; class GFG { static void computeTotient ( int n ) { long phi [ ] = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( " Totient ▁ of ▁ " + i + " ▁ is ▁ " + phi [ i ] ) ; } public static void main ( String [ ] args ) { int n = 12 ; computeTotient ( n ) ; } }
import java . util . Arrays ; class GFG { static int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; int k1 = 3 , k2 = 6 ; int n = arr . length ; System . out . print ( sumBetweenTwoKth ( arr , k1 , k2 ) ) ; } }
class GFG { static int countSquares ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( " Count ▁ of ▁ squares ▁ is ▁ " + countSquares ( n ) ) ; } }
import java . io . * ; class GFG { static int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( int ) ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( " nth ▁ magic " + " ▁ number ▁ is ▁ " + nthMagicNo ( n ) ) ; } }
import java . io . * ; class GFG { static long countOfMultiples ( long n ) { return ( n / 3 + n / 5 - n / 15 ) ; } static public void main ( String [ ] args ) { System . out . println ( countOfMultiples ( 6 ) ) ; System . out . println ( countOfMultiples ( 16 ) ) ; } }
class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
class GfG { static boolean isDefeat ( String s1 , String s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) || ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) ) continue ; else if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == ' Z ' ) || ( s1 . charAt ( i ) == ' Z ' && s2 . charAt ( i ) == '0' ) ) continue ; else { return true ; } } return false ; } public static void main ( String [ ] args ) { String s1 = ( "01001101ZZ " ) ; String s2 = ( "10Z1001000" ) ; int n = 10 ; if ( isDefeat ( s1 , s2 , n ) ) System . out . println ( " Defeat " ) ; else System . out . println ( " Victory " ) ; } }
class GFG { static final int N = 3 , M = 3 ; static boolean check ( int a [ ] [ ] , int b [ ] [ ] ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) { a [ i ] [ j ] ^= 1 ; a [ 0 ] [ 0 ] ^= 1 ; a [ 0 ] [ j ] ^= 1 ; a [ i ] [ 0 ] ^= 1 ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) return false ; } } return true ; } public static void main ( String args [ ] ) { int a [ ] [ ] = { { 0 , 1 , 0 } , { 0 , 1 , 0 } , { 1 , 0 , 0 } } ; int b [ ] [ ] = { { 1 , 0 , 0 } , { 1 , 0 , 0 } , { 1 , 0 , 0 } } ; if ( check ( a , b ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; class GFG { static int FindIndexKthBit ( int n , int k ) { int cnt = 0 ; int ind = 0 ; while ( n > 0 ) { if ( ( n & 1 ) != 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; } public static void main ( String args [ ] ) { int n = 15 , k = 3 ; int ans = FindIndexKthBit ( n , k ) ; if ( ans != - 1 ) System . out . println ( ans ) ; else System . out . println ( " No ▁ k - th ▁ set ▁ bit " ) ; } }
import java . util . * ; class GFG { static int minDistance ( int n1 , int n2 ) { int bitCount1 = ( int ) Math . floor ( ( Math . log ( n1 ) / Math . log ( 2 ) ) ) + 1 ; int bitCount2 = ( int ) Math . floor ( ( Math . log ( n2 ) / Math . log ( 2 ) ) ) + 1 ; int bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = ( int ) Math . floor ( ( Math . log ( xorValue ) / Math . log ( 2 ) ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ; int result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; } public static void main ( String args [ ] ) { int n1 = 12 , n2 = 5 ; System . out . println ( minDistance ( n1 , n2 ) ) ; } }
import java . io . * ; class GFG { static int printMaxAfterRemoval ( String s ) { boolean flag = false ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' && flag == false ) { flag = true ; continue ; } else System . out . print ( s . charAt ( i ) ) ; } return 0 ; } public static void main ( String [ ] args ) { String s = "1001" ; printMaxAfterRemoval ( s ) ; } }
import java . io . * ; class GFG { static int bitPos ( int n1 , int n2 ) { if ( n1 == n2 ) return 0 ; int bitCount1 = ( int ) Math . floor ( Math . log ( n1 ) / Math . log ( 2 ) ) + 1 ; int bitCount2 = ( int ) Math . floor ( Math . log ( n2 ) / Math . log ( 2 ) ) + 1 ; int bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue = ( int ) Math . floor ( Math . log ( xorValue ) / Math . log ( 2 ) ) + 1 ; int disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; } public static void main ( String [ ] args ) { int n1 = 53 , n2 = 55 ; System . out . println ( bitPos ( n1 , n2 ) ) ; } }
public class GFG { static int countOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 != 1 ) ) { count ++ ; } } int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; } public static void main ( String [ ] args ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = A . length ; System . out . println ( countOddPair ( A , N ) ) ; } }
import java . io . * ; class GFG { static void ReplaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class GFG { static int OR ( int a [ ] , int n ) { int ans = a [ 0 ] ; int i ; for ( i = 1 ; i < n ; i ++ ) { ans |= a [ i ] ; } return ans ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 4 , 6 } ; int n = a . length ; System . out . println ( OR ( a , n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int bit ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; } static int maxSumOfBits ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = bit ( arr [ i ] ) ; } int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 } ; int n = arr . length ; System . out . print ( maxSumOfBits ( arr , n ) ) ; } }
class GFG { static char increment ( char i ) { int i1 = - ( ~ ( int ) ( i ) ) ; return ( char ) ( i1 ) ; } public static void main ( String [ ] args ) { char n = ' a ' ; System . out . println ( increment ( n ) ) ; } }
class GFG { static int findOddPair ( int A [ ] , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; } public static void main ( String [ ] arg ) { int a [ ] = { 5 , 4 , 7 , 2 , 1 } ; int n = a . length ; System . out . println ( findOddPair ( a , n ) ) ; } }
import java . io . * ; class GFG { static int MSBPosition ( long N ) { int msb_p = - 1 ; while ( N > 0 ) { N = N >> 1 ; msb_p ++ ; } return msb_p ; } static long findBitwiseOR ( long L , long R ) { long res = 0 ; int msb_p1 = MSBPosition ( L ) ; int msb_p2 = MSBPosition ( R ) ; while ( msb_p1 == msb_p2 ) { long res_val = ( 1 << msb_p1 ) ; res += res_val ; L -= res_val ; R -= res_val ; msb_p1 = MSBPosition ( L ) ; msb_p2 = MSBPosition ( R ) ; } msb_p1 = Math . max ( msb_p1 , msb_p2 ) ; for ( int i = msb_p1 ; i >= 0 ; i -- ) { long res_val = ( 1 << i ) ; res += res_val ; } return res ; } public static void main ( String [ ] args ) { int L = 12 , R = 18 ; System . out . println ( findBitwiseOR ( L , R ) ) ; } }
import java . io . * ; class GFG { public static long maxOR ( long arr [ ] , int n , int k , int x ) { long preSum [ ] = new long [ n + 1 ] ; long suffSum [ ] = new long [ n + 1 ] ; long res = 0 , pow = 1 ; for ( int i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; } public static void main ( String args [ ] ) { long arr [ ] = { 1 , 2 , 4 , 8 } ; int n = 4 ; int k = 2 , x = 3 ; long ans = maxOR ( arr , n , k , x ) ; System . out . println ( ans ) ; } }
class GFG { static int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; } public static void main ( String [ ] args ) { int n = 4 ; int k = 2 ; System . out . print ( turnOnK ( n , k ) ) ; } }
import java . util . Arrays ; public class AQRQ { static int minSum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 0 , 7 , 4 } ; int n = arr . length ; System . out . println ( " The ▁ required ▁ sum ▁ is ▁ " + minSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static void printKthBit ( long n , long k ) { System . out . println ( ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ) ; } public static void main ( String [ ] args ) { long n = 13 , k = 2 ; printKthBit ( n , k ) ; } }
import java . io . * ; class GFG { static int countSetBits ( int n ) { long count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return ( int ) count ; } static int countOfOddsPascal ( int n ) { int c = countSetBits ( n ) ; return ( int ) Math . pow ( 2 , c ) ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( countOfOddsPascal ( n ) ) ; } }
import java . util . * ; class GFG { static void ansQueries ( int prefeven [ ] , int prefodd [ ] , int l , int r ) { if ( ( r - l + 1 ) % 2 == 0 ) System . out . println ( "0" ) ; else { if ( l % 2 == 0 ) System . out . println ( prefeven [ r ] ^ prefeven [ l - 1 ] ) ; else System . out . println ( prefodd [ r ] ^ prefodd [ l - 1 ] ) ; } } static void wrapper ( int arr [ ] , int n , int l [ ] , int r [ ] , int q ) { int prefodd [ ] = new int [ 100 ] ; int prefeven [ ] = new int [ 100 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } int i = 0 ; while ( i != q ) { ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) ; i ++ ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int l [ ] = { 1 , 1 , 2 } ; int r [ ] = { 2 , 3 , 4 } ; int q = l . length ; wrapper ( arr , n , l , r , q ) ; } }
class GFG { static int solve ( int p [ ] , int n ) { int G = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 != 0 ) G ^= ( p [ i ] + 1 ) ; G ^= ( p [ i ] - 1 ) ; } return G ; } public static void main ( String [ ] args ) { int n = 3 ; int p [ ] = { 32 , 49 , 58 } ; int res = solve ( p , n ) ; System . out . print ( " Player ▁ 2 ▁ wins " ) ; System . out . print ( " Player ▁ 1 ▁ wins " ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { static int checkBit ( int pattern , int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; } static int maxAND ( int arr [ ] , int n ) { int res = 0 , count ; for ( int bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } return res ; } public static void main ( String argc [ ] ) { int arr [ ] = { 4 , 8 , 6 , 2 } ; int n = arr . length ; System . out . println ( " Maximum ▁ AND ▁ Value ▁ = ▁ " + maxAND ( arr , n ) ) ; } }
class GFG { static boolean checkPowerof8 ( int n ) { double i = Math . log ( n ) / Math . log ( 8 ) ; return ( i - Math . floor ( i ) < 0.000001 ) ; } public static void main ( String args [ ] ) { int n = 65 ; if ( checkPowerof8 ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static byte longSize = 8 ; static int ULL_SIZE = 8 * longSize ; static boolean bit_anagram_check ( long a ) { return ( Integer . bitCount ( ( int ) a ) == ( ULL_SIZE >> 1 ) ) ; } public static void main ( String [ ] args ) { long a = 4294967295L ; System . out . println ( bit_anagram_check ( a ) ) ; } }
public class Main { static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; 1 << i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { int num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( findSum ( n ) ) ; } }
import java . util . * ; class GFG { static int posOfRightMostDiffBit ( int m , int n ) { return ( int ) Math . floor ( Math . log10 ( Math . pow ( m ^ n , 2 ) ) ) + 2 ; } public static void main ( String [ ] args ) { int m = 52 , n = 4 ; System . out . println ( " Position ▁ = ▁ " + posOfRightMostDiffBit ( m , n ) ) ; } }
class GFG { static int setKthBit ( int n , int k ) { return ( ( 1 << k ) n ) ; } public static void main ( String arg [ ] ) { int n = 10 , k = 2 ; System . out . print ( " Kth ▁ bit ▁ set ▁ number ▁ = ▁ " + setKthBit ( n , k ) ) ; } }
class GFG { static void reverseArray ( int arr [ ] , int n ) { int x = ( Integer . MIN_VALUE / Integer . MAX_VALUE ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) swap ( arr , i , n + ( x * i ) + x ) ; } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 , 6 } ; int n = arr . length ; reverseArray ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . util . Arrays ; class GFG { static void reverseArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( arr , i , ( n + ~ i + 1 ) + ~ 1 + 1 ) ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 , 6 } ; int n = arr . length ; reverseArray ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
class Xor { static int maxXORInRange ( int L , int R ) { int LXR = L ^ R ; int msbPos = 0 ; while ( LXR > 0 ) { msbPos ++ ; LXR >>= 1 ; } int maxXOR = 0 ; int two = 1 ; while ( msbPos -- > 0 ) { maxXOR += two ; two <<= 1 ; } return maxXOR ; } public static void main ( String [ ] args ) { int L = 8 ; int R = 20 ; System . out . println ( maxXORInRange ( L , R ) ) ; } }
class GFG { static int CountZeroBit ( int n ) { int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) != 0 ) count ++ ; n >>= 1 ; } return count ; } static int CountORandSumEqual ( int N ) { int count = CountZeroBit ( N ) ; return ( 1 << count ) ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . print ( CountORandSumEqual ( N ) ) ; } }
import java . lang . * ; class GFG { static int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( int ) ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; } public static void main ( String [ ] args ) { int n = 11 ; System . out . println ( countNumbers ( n ) ) ; } }
class Test { static boolean isMultipleOf4 ( int n ) { if ( n == 1 ) return false ; int XOR = 0 ; for ( int i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; } public static void main ( String [ ] args ) { for ( int n = 0 ; n <= 42 ; n ++ ) System . out . print ( isMultipleOf4 ( n ) ? n : " ▁ " ) ; } }
class Test { static boolean isMultipleOf4 ( long n ) { if ( n == 0 ) return true ; return ( ( ( n >> 2 ) << 2 ) == n ) ; } public static void main ( String [ ] args ) { for ( int n = 0 ; n <= 42 ; n ++ ) System . out . print ( isMultipleOf4 ( n ) ? n : " ▁ " ) ; } }
import java . io . * ; class GFG { static int countSetBits ( int x ) { int count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; } static int ceilLog2 ( int x ) { int count = 0 ; x -- ; while ( x > 0 ) { x = x >> 1 ; count ++ ; } return count ; } static boolean isBleak ( int n ) { for ( int x = n - ceilLog2 ( n ) ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; } public static void main ( String [ ] args ) { if ( isBleak ( 3 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; if ( isBleak ( 4 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int countStrings ( int n ) { int a [ ] = new int [ n ] , b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; } public static void main ( String args [ ] ) { System . out . println ( countStrings ( 5 ) ) ; } }
import java . io . * ; class GFG { static int N = 3 ; static int M = 4 ; static void printDistance ( int mat [ ] [ ] ) { int ans [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . min ( ans [ i ] [ j ] , Math . abs ( i - k ) + Math . abs ( j - l ) ) ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) System . out . print ( ans [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 0 , 0 , 1 } , { 0 , 0 , 1 , 1 } , { 0 , 1 , 1 , 0 } } ; printDistance ( mat ) ; } }
import java . io . * ; import java . util . * ; public class detheap { static boolean isMinHeap ( int [ ] level ) { int n = level . length - 1 ; for ( int i = ( n / 2 - 1 ) ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } } return true ; } public static void main ( String [ ] args ) throws IOException { int [ ] level = new int [ ] { 10 , 15 , 14 , 25 , 30 } ; if ( isMinHeap ( level ) ) System . out . println ( " True " ) ; else System . out . println ( " False " ) ; } }
import java . util . * ; class GFG { static int mostFrequent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max_count = 1 , res = arr [ 0 ] ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 2 , 1 , 3 , 2 , 1 } ; int n = arr . length ; System . out . println ( mostFrequent ( arr , n ) ) ; } }
public class disjoint1 { boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) { for ( int i = 0 ; i < set1 . length ; i ++ ) { for ( int j = 0 ; j < set2 . length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; } public static void main ( String [ ] args ) { disjoint1 dis = new disjoint1 ( ) ; int set1 [ ] = { 12 , 34 , 11 , 9 , 3 } ; int set2 [ ] = { 7 , 2 , 1 , 5 } ; boolean result = dis . aredisjoint ( set1 , set2 ) ; if ( result ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) System . out . print ( a [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 6 , 3 , 4 , 5 } ; int b [ ] = { 2 , 4 , 3 , 1 , 0 } ; int n = a . length ; int m = b . length ; findMissing ( a , b , n , m ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static boolean areEqual ( int arr1 [ ] , int arr2 [ ] ) { int n = arr1 . length ; int m = arr2 . length ; if ( n != m ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 3 , 5 , 2 , 5 , 2 } ; int arr2 [ ] = { 2 , 3 , 5 , 5 , 2 } ; if ( areEqual ( arr1 , arr2 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { boolean isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; } public static void main ( String [ ] args ) { GFG g = new GFG ( ) ; int arr [ ] = { 10 , 20 , 9 , 40 } ; int x = 400 ; int n = arr . length ; if ( g . isProduct ( arr , n , x ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; x = 190 ; if ( g . isProduct ( arr , n , x ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; } static public void main ( String [ ] args ) { int [ ] arr = { 30 , 10 , 9 , 3 , 35 } ; int n = arr . length ; System . out . println ( findGreatest ( arr , n ) ) ; } }
public class find { public static void getPairsCount ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = i + 1 ; j < arr . length ; j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ; System . out . printf ( " Count ▁ of ▁ pairs ▁ is ▁ % d " , count ) ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 5 , 7 , - 1 , 5 } ; int sum = 6 ; getPairsCount ( arr , sum ) ; } }
import java . io . * ; class GFG { static int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int arr2 [ ] = { 2 , 3 , 5 , 8 } ; int m = arr1 . length ; int n = arr2 . length ; int x = 10 ; System . out . println ( " Count ▁ = ▁ " + countPairs ( arr1 , arr2 , m , n , x ) ) ; } }
import java . io . * ; class GFG { static boolean isPresent ( int arr [ ] , int low , int high , int value ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; } return false ; } static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int value = x - arr1 [ i ] ; if ( isPresent ( arr2 , 0 , n - 1 , value ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int arr2 [ ] = { 2 , 3 , 5 , 8 } ; int m = arr1 . length ; int n = arr2 . length ; int x = 10 ; System . out . println ( " Count ▁ = ▁ " + countPairs ( arr1 , arr2 , m , n , x ) ) ; } }
import java . io . * ; class GFG { static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int arr2 [ ] = { 2 , 3 , 5 , 8 } ; int m = arr1 . length ; int n = arr2 . length ; int x = 10 ; System . out . println ( " Count ▁ = ▁ " + countPairs ( arr1 , arr2 , m , n , x ) ) ; } }
class GFG { static boolean isPresent ( int [ ] arr , int low , int high , int value ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; } return false ; } static int countQuadruples ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 , int [ ] arr4 , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) { int T = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; if ( isPresent ( arr4 , 0 , n - 1 , x - T ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int [ ] arr1 = { 1 , 4 , 5 , 6 } ; int [ ] arr2 = { 2 , 3 , 7 , 8 } ; int [ ] arr3 = { 1 , 4 , 6 , 10 } ; int [ ] arr4 = { 2 , 4 , 7 , 8 } ; int n = 4 ; int x = 30 ; System . out . println ( " Count ▁ = ▁ " + countQuadruples ( arr1 , arr2 , arr3 , arr4 , n , x ) ) ; } }
import java . io . * ; class GFG { static int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 2 , 4 , 12 , 5 , 3 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
class clg { static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . println ( fib ( n ) ) ; } }
class GFG { static int factTR ( int n , int a ) { if ( n == 0 ) return a ; return factTR ( n - 1 , n * a ) ; } static int fact ( int n ) { return factTR ( n , 1 ) ; } static public void main ( String [ ] args ) { System . out . println ( fact ( 5 ) ) ; } }
import java . io . * ; class GFG { static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) System . out . println ( arr1 [ i ] + " ▁ " + arr2 [ j ] ) ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 2 , 3 , 7 , 5 , 4 } ; int arr2 [ ] = { 0 , 7 , 4 , 3 , 2 , 1 } ; int x = 8 ; findPairs ( arr1 , arr2 , arr1 . length , arr2 . length , x ) ; } }
import java . io . * ; public class GFG { static void findPair ( int [ ] arr , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { System . out . println ( arr [ i ] + " ▁ " + arr [ j ] ) ; found = true ; } } } } if ( found == false ) System . out . println ( " Not ▁ exist " ) ; } static public void main ( String [ ] args ) { int [ ] arr = { 10 , 4 , 8 , 13 , 5 } ; int n = arr . length ; findPair ( arr , n ) ; } }
class Test { static boolean printPairs ( int arr [ ] , int n , int k ) { boolean isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { System . out . print ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " ▁ " ) ; isPairFound = true ; } } } return isPairFound ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 5 , 4 , 7 } ; int k = 3 ; if ( printPairs ( arr , arr . length , k ) == false ) System . out . println ( " No ▁ such ▁ pair ▁ exists " ) ; } }
public class GFG { static final int ASCII_SIZE = 256 ; static char getMaxOccuringChar ( String str ) { int count [ ] = new int [ ASCII_SIZE ] ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) count [ str . charAt ( i ) ] ++ ; int max = - 1 ; char result = ' ▁ ' ; for ( int i = 0 ; i < len ; i ++ ) { if ( max < count [ str . charAt ( i ) ] ) { max = count [ str . charAt ( i ) ] ; result = str . charAt ( i ) ; } } return result ; } public static void main ( String [ ] args ) { String str = " sample ▁ string " ; System . out . println ( " Max ▁ occurring ▁ character ▁ is ▁ " + getMaxOccuringChar ( str ) ) ; } }
class GFG { static int firstNonRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 4 , 9 , 6 , 7 , 4 } ; int n = arr . length ; System . out . print ( firstNonRepeating ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static void subarrayDivisibleByK ( int [ ] arr , int n , int k ) { int [ ] mp = new int [ 1000 ] ; int s = 0 , e = 0 , maxs = 0 , maxe = 0 ; mp [ arr [ 0 ] % k ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] -- ; s ++ ; } mp [ mod ] ++ ; e ++ ; if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e ; maxs = s ; } } System . out . print ( " The ▁ maximum ▁ size ▁ is ▁ " + ( maxe - maxs + 1 ) + " and the subarray is as followsNEW_LINE"); for ( int i = maxs ; i <= maxe ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int k = 3 ; int [ ] arr = { 5 , 10 , 15 , 20 , 25 } ; int n = arr . length ; subarrayDivisibleByK ( arr , n , k ) ; } }
class GFG { static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; } public static void main ( String [ ] args ) { int a1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int a2 [ ] = { 2 , 3 , 6 , 1 , 2 } ; int a3 [ ] = { 3 , 2 , 4 , 5 , 6 } ; int sum = 9 ; int n1 = a1 . length ; int n2 = a2 . length ; int n3 = a3 . length ; if ( findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
public class Palindrome { static int minInsertion ( String str ) { int n = str . length ( ) ; int res = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . println ( minInsertion ( str ) ) ; } }
import java . util . * ; class GFG { static int findDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 8 , 4 , 5 , 4 , 1 , 1 , 7 , 7 , 2 , 5 } ; int n = arr . length ; System . out . println ( findDiff ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int maxDiff ( int [ ] arr , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { boolean isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; } static public void main ( String [ ] args ) { int [ ] arr = { 4 , 2 , - 3 , 3 , - 2 , - 2 , 8 } ; int n = arr . length ; System . out . println ( " Maximum ▁ Difference ▁ = ▁ " + maxDiff ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int maxDiff ( int [ ] arr , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; } static public void main ( String [ ] args ) { int [ ] arr = { 4 , 2 , - 3 , 3 , - 2 , - 2 , 8 } ; int n = arr . length ; System . out . println ( " Maximum ▁ Difference ▁ = ▁ " + maxDiff ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void printAllAPTriplets ( int [ ] arr , int n ) { ArrayList < Integer > s = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; boolean exists = s . contains ( arr [ i ] - diff ) ; if ( exists ) System . out . println ( arr [ i ] - diff + " ▁ " + arr [ i ] + " ▁ " + arr [ j ] ) ; } s . add ( arr [ i ] ) ; } } public static void main ( String args [ ] ) { int [ ] arr = { 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 } ; int n = arr . length ; printAllAPTriplets ( arr , n ) ; } }
import java . io . * ; class GFG { static void findAllTriplets ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { System . out . println ( arr [ j ] + " ▁ " + arr [ i ] + " ▁ " + arr [ k ] ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 } ; int n = arr . length ; findAllTriplets ( arr , n ) ; } }
class GFG { static int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] * arr [ j ] * arr [ k ] == m ) count ++ ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 , 8 } ; int m = 24 ; System . out . println ( countTriplets ( arr , arr . length , m ) ) ; } }
class GFG { static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
class GFG { static class pair { int first , second ; pair ( int a , int b ) { first = a ; second = b ; } } static void preCalculate ( int binary [ ] , int n , pair left [ ] ) { int count1 = 0 , count0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] . first = count1 ; left [ i ] . second = count0 ; if ( binary [ i ] != 0 ) count1 ++ ; else count0 ++ ; } } public static void main ( String args [ ] ) { int binary [ ] = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = binary . length ; pair left [ ] = new pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) left [ i ] = new pair ( 0 , 0 ) ; preCalculate ( binary , n , left ) ; int queries [ ] = { 0 , 1 , 2 , 4 } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( left [ queries [ i ] ] . first + " ▁ ones ▁ " + left [ queries [ i ] ] . second + " zerosNEW_LINE"); } }
public class Main { public static int pos1 = - 1 ; public static int pos2 = - 1 ; public static boolean equiSumUtil ( int [ ] arr ) { int n = arr . length ; int [ ] pre = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; pre [ i ] = sum ; } int [ ] suf = new int [ n ] ; sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; suf [ i ] = sum ; } int total_sum = sum ; int i = 0 , j = n - 1 ; while ( i < j - 1 ) { if ( pre [ i ] == total_sum / 3 ) { pos1 = i ; } if ( suf [ j ] == total_sum / 3 ) { pos2 = j ; } if ( pos1 != - 1 && pos2 != - 1 ) { if ( suf [ pos1 + 1 ] - suf [ pos2 ] == total_sum / 3 ) { return true ; } else { return false ; } } if ( pre [ i ] < suf [ j ] ) { i ++ ; } else { j -- ; } } return false ; } public static void equiSum ( int [ ] arr ) { boolean ans = equiSumUtil ( arr ) ; if ( ans ) { System . out . print ( " First ▁ Segment ▁ : ▁ " ) ; for ( int i = 0 ; i <= pos1 ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; System . out . print ( " Second ▁ Segment ▁ : ▁ " ) ; for ( int i = pos1 + 1 ; i < pos2 ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; System . out . print ( " Third ▁ Segment ▁ : ▁ " ) ; for ( int i = pos2 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; } else { System . out . println ( " Array ▁ cannot ▁ be ▁ " + " divided ▁ into ▁ three ▁ equal ▁ sum ▁ segments " ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 6 , 2 , 7 , 1 , 2 , 8 } ; equiSum ( arr ) ; } }
public class GFG { public static int getRightMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; int rightMin = 0 ; int i = 1 ; while ( i < n ) { if ( arr [ i ] == min ) rightMin = i ; i *= 2 ; } i = rightMin + 1 ; while ( i < n && arr [ i ] == min ) { rightMin = i ; i ++ ; } return rightMin ; } public static int getLeftMax ( int arr [ ] , int n ) { int max = arr [ n - 1 ] ; int leftMax = n - 1 ; int i = n - 2 ; while ( i > 0 ) { if ( arr [ i ] == max ) leftMax = i ; i /= 2 ; } i = leftMax - 1 ; while ( i >= 0 && arr [ i ] == max ) { leftMax = i ; i -- ; } return leftMax ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 0 , 1 , 2 , 5 , 5 , 6 , 8 , 8 } ; int n = arr . length ; System . out . println ( " Minimum ▁ left ▁ : ▁ " + 0 ) ; System . out . println ( " Minimum ▁ right ▁ : ▁ " + getRightMin ( arr , n ) ) ; System . out . println ( " Maximum ▁ left ▁ : ▁ " + getLeftMax ( arr , n ) ) ; System . out . println ( " Maximum ▁ right ▁ : ▁ " + ( n - 1 ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int countNum ( int [ ] arr , int n ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; } static public void main ( String [ ] args ) { int [ ] arr = { 3 , 5 , 8 , 6 } ; int n = arr . length ; System . out . println ( countNum ( arr , n ) ) ; } }
class GFG { static int countSubarrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference ++ ; } else { difference -- ; } if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 } ; int n = arr . length ; System . out . println ( " Total ▁ Number ▁ of ▁ Even - Odd " + " ▁ subarrays ▁ are ▁ " + countSubarrays ( arr , n ) ) ; } }
class GFG { static final int MAX = 100 ; static boolean search ( int mat [ ] [ ] , int m , int n , int x ) { int i = m - 1 , j = 0 ; while ( i >= 0 && j < n ) { if ( mat [ i ] [ j ] == x ) return true ; if ( mat [ i ] [ j ] > x ) i -- ; else j ++ ; } return false ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , { 50 , 60 , 70 , 80 } } ; if ( search ( mat , 5 , 4 , 29 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static void printGreaterCount ( String str ) { int len = str . length ( ) , right [ ] = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { if ( str . charAt ( i ) < str . charAt ( j ) ) { right [ i ] ++ ; } } } for ( int i = 0 ; i < len ; i ++ ) { System . out . print ( right [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { String str = " abcd " ; printGreaterCount ( str ) ; } }
class GFG { static int appearsNBy3 ( int arr [ ] , int n ) { int count1 = 0 , count2 = 0 ; int first = Integer . MIN_VALUE ; ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( first == arr [ i ] ) count1 ++ ; else if ( second == arr [ i ] ) count2 ++ ; else if ( count1 == 0 ) { count1 ++ ; first = arr [ i ] ; } else if ( count2 == 0 ) { count2 ++ ; second = arr [ i ] ; } else { count1 -- ; count2 -- ; } } count1 = 0 ; count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == first ) count1 ++ ; else if ( arr [ i ] == second ) count2 ++ ; } if ( count1 > n / 3 ) return first ; if ( count2 > n / 3 ) return second ; return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 1 , 1 } ; int n = arr . length ; System . out . println ( appearsNBy3 ( arr , n ) ) ; } }
import java . util . * ; class Count { public static int count4Divisibiles ( int arr [ ] , int n ) { int freq [ ] = { 0 , 0 , 0 , 0 } ; int i = 0 ; int ans ; for ( i = 0 ; i < n ; i ++ ) ++ freq [ arr [ i ] % 4 ] ; ans = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; ans += freq [ 2 ] * ( freq [ 2 ] - 1 ) / 2 ; ans += freq [ 1 ] * freq [ 3 ] ; return ( ans ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 1 , 7 , 5 } ; int n = 5 ; System . out . print ( count4Divisibiles ( arr , n ) ) ; } }
class gfg { static int countMaxSetBits ( int left , int right ) { int max_count = - 1 , num = 0 ; for ( int i = left ; i <= right ; ++ i ) { int temp = i , cnt = 0 ; while ( temp > 0 ) { if ( temp % 2 == 1 ) ++ cnt ; temp >>= 1 ; } if ( cnt > max_count ) { max_count = cnt ; num = i ; } } return num ; } public static void main ( String [ ] args ) { int l = 1 , r = 5 ; System . out . println ( countMaxSetBits ( l , r ) ) ; l = 1 ; r = 10 ; System . out . print ( countMaxSetBits ( l , r ) ) ; } }
import java . io . * ; class GFG { static void recaman ( int n ) { int arr [ ] = new int [ n ] ; arr [ 0 ] = 0 ; System . out . print ( arr [ 0 ] + " ▁ , " ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; System . out . print ( arr [ i ] + " , ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 17 ; recaman ( n ) ; } }
import java . util . * ; class GFG { static void recaman ( int n ) { if ( n <= 0 ) return ; System . out . printf ( " % d , ▁ " , 0 ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ; s . add ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . contains ( curr ) ) curr = prev + i ; s . add ( curr ) ; System . out . printf ( " % d , ▁ " , curr ) ; prev = curr ; } } public static void main ( String [ ] args ) { int n = 17 ; recaman ( n ) ; } }
import java . util . Arrays ; import java . util . Collections ; public class GFG { static int findArea ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int [ ] dimension = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; } public static void main ( String args [ ] ) { Integer arr [ ] = { 4 , 2 , 1 , 4 , 6 , 6 , 2 , 5 } ; int n = arr . length ; System . out . println ( findArea ( arr , n ) ) ; } }
class PairInSortedRotated { static boolean pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 15 , 6 , 8 , 9 , 10 } ; int sum = 16 ; int n = arr . length ; if ( pairInSortedRotated ( arr , n , sum ) ) System . out . print ( " Array ▁ has ▁ two ▁ elements " + " ▁ with ▁ sum ▁ 16" ) ; else System . out . print ( " Array ▁ doesn ' t ▁ have ▁ two " + " ▁ elements ▁ with ▁ sum ▁ 16 ▁ " ) ; } }
import java . io . * ; class GFG { static int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 15 , 6 , 7 , 9 , 10 } ; int sum = 16 ; int n = arr . length ; System . out . println ( pairsInSortedRotated ( arr , n , sum ) ) ; } }
import java . util . Arrays ; class Test { static int arr [ ] = new int [ ] { 10 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; static int maxSum ( ) { int arrSum = 0 ; int currVal = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { arrSum = arrSum + arr [ i ] ; currVal = currVal + ( i * arr [ i ] ) ; } int maxVal = currVal ; for ( int j = 1 ; j < arr . length ; j ++ ) { currVal = currVal + arrSum - arr . length * arr [ arr . length - j ] ; if ( currVal > maxVal ) maxVal = currVal ; } return maxVal ; } public static void main ( String [ ] args ) { System . out . println ( " Max ▁ sum ▁ is ▁ " + maxSum ( ) ) ; } }
import java . util . * ; import java . io . * ; class GFG { static int maxSum ( int arr [ ] , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 8 , 3 , 1 , 2 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 3 , 1 , 2 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class LinearSearch { static int countRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; } public static void main ( String [ ] args ) { int arr [ ] = { 15 , 18 , 2 , 3 , 6 , 12 } ; int n = arr . length ; System . out . println ( countRotations ( arr , n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class BinarySearch { static int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 15 , 18 , 2 , 3 , 6 , 12 } ; int n = arr . length ; System . out . println ( countRotations ( arr , 0 , n - 1 ) ) ; } }
class LeftRotate { static void preprocess ( int arr [ ] , int n , int temp [ ] ) { for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = temp [ i + n ] = arr [ i ] ; } static void leftRotate ( int arr [ ] , int n , int k , int temp [ ] ) { int start = k % n ; for ( int i = start ; i < start + n ; i ++ ) System . out . print ( temp [ i ] + " ▁ " ) ; System . out . print ( "NEW_LINE"); } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = arr . length ; int temp [ ] = new int [ 2 * n ] ; preprocess ( arr , n , temp ) ; int k = 2 ; leftRotate ( arr , n , k , temp ) ; k = 3 ; leftRotate ( arr , n , k , temp ) ; k = 4 ; leftRotate ( arr , n , k , temp ) ; } }
import java . io . * ; class GFG { static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = arr . length ; int k = 2 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; k = 3 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; k = 4 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; } }
import java . io . * ; class GFG { static void reverseArray ( int arr [ ] , int start , int end ) { while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } } static void rightRotate ( int arr [ ] , int d , int n ) { reverseArray ( arr , 0 , n - 1 ) ; reverseArray ( arr , 0 , d - 1 ) ; reverseArray ( arr , d , n - 1 ) ; } static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = arr . length ; int k = 3 ; rightRotate ( arr , k , n ) ; printArray ( arr , n ) ; } }
class GFG { static int maxHamming ( int arr [ ] , int n ) { int brr [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = Math . max ( maxHam , currHam ) ; } return maxHam ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 } ; int n = arr . length ; System . out . print ( maxHamming ( arr , n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class arr_rot { static void leftRotate ( int arr [ ] , int n , int k ) { int mod = k % n ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ ( i + mod ) % n ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = arr . length ; int k = 2 ; leftRotate ( arr , n , k ) ; k = 3 ; leftRotate ( arr , n , k ) ; k = 4 ; leftRotate ( arr , n , k ) ; } }
import java . util . * ; class GFG { static int findElement ( int [ ] arr , int [ ] [ ] ranges , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index -- ; } } return arr [ index ] ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int rotations = 2 ; int [ ] [ ] ranges = { { 0 , 2 } , { 0 , 3 } } ; int index = 1 ; System . out . println ( findElement ( arr , ranges , rotations , index ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = arr . length ; int position = 2 ; splitArr ( arr , 6 , position ) ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class GFG { static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } static void sort_shell_metzner ( int arr [ ] , int n ) { int i , j , k , l , m , temp ; m = n ; while ( m > 0 ) { m /= 2 ; k = n - m ; j = 0 ; do { i = j ; do { l = i + m ; if ( l < n && arr [ i ] > arr [ l ] ) { swap ( arr , i , l ) ; i -= m ; } else { break ; } } while ( i >= 0 ) ; j ++ ; } while ( j <= k ) ; } } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 0 , - 2 , 8 , 5 , 1 } ; int n = arr . length ; sort_shell_metzner ( arr , n ) ; printArray ( arr , n ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static void rearrangeArr ( int arr [ ] , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int [ ] tempArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; Arrays . sort ( tempArr ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String argc [ ] ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int size = 7 ; rearrangeArr ( arr , size ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int MaxSumDifference ( Integer [ ] a , int n ) { List < Integer > finalSequence = new ArrayList < Integer > ( ) ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . add ( a [ i ] ) ; finalSequence . add ( a [ n - i - 1 ] ) ; } if ( n % 2 != 0 ) finalSequence . add ( a [ n / 2 ] ) ; int MaximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( i ) - finalSequence . get ( i + 1 ) ) ; } MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( n - 1 ) - finalSequence . get ( 0 ) ) ; return MaximumSum ; } public static void main ( String args [ ] ) { Integer [ ] a = { 1 , 2 , 4 , 8 } ; int n = a . length ; System . out . print ( MaxSumDifference ( a , n ) ) ; } }
import java . lang . * ; class GFG { static int minSwap ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ; int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ; int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) -- bad ; if ( arr [ j ] > k ) ++ bad ; ans = Math . min ( ans , bad ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 5 , 6 , 3 } ; int n = arr . length ; int k = 3 ; System . out . print ( minSwap ( arr , n , k ) + "NEW_LINE"); int arr1 [ ] = { 2 , 7 , 9 , 5 , 8 , 7 , 4 } ; n = arr1 . length ; k = 5 ; System . out . print ( minSwap ( arr1 , n , k ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int maxProductSubarrayOfSizeK ( int A [ ] , int n , int k ) { Arrays . sort ( A ) ; int product = 1 ; if ( A [ n - 1 ] == 0 && k % 2 != 0 ) return 0 ; if ( A [ n - 1 ] <= 0 && k % 2 != 0 ) { for ( int i = n - 1 ; i >= n - k ; i -- ) product *= A [ i ] ; return product ; } int i = 0 ; int j = n - 1 ; if ( k % 2 != 0 ) { product *= A [ j ] ; j -- ; k -- ; } k >>= 1 ; for ( int itr = 0 ; itr < k ; itr ++ ) { int left_product = A [ i ] * A [ i + 1 ] ; int right_product = A [ j ] * A [ j - 1 ] ; if ( left_product > right_product ) { product *= left_product ; i += 2 ; } else { product *= right_product ; j -= 2 ; } } return product ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , - 1 , - 3 , - 6 , 4 } ; int n = A . length ; int k = 4 ; System . out . println ( maxProductSubarrayOfSizeK ( A , n , k ) ) ; } }
import java . util . Arrays ; class Test { static int arr [ ] = new int [ ] { 50 , 40 , 70 , 60 , 90 } ; static int index [ ] = new int [ ] { 3 , 0 , 4 , 1 , 2 } ; static void reorder ( ) { int temp [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } } public static void main ( String [ ] args ) { reorder ( ) ; System . out . println ( " Reordered ▁ array ▁ is : ▁ " ) ; System . out . println ( Arrays . toString ( arr ) ) ; System . out . println ( " Modified ▁ Index ▁ array ▁ is : " ) ; System . out . println ( Arrays . toString ( index ) ) ; } }
import java . util . * ; class GFG { static int numofsubset ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 100 , 56 , 5 , 6 , 102 , 58 , 101 , 57 , 7 , 103 , 59 } ; int n = arr . length ; System . out . println ( numofsubset ( arr , n ) ) ; } }
import java . util . Arrays ; public class GFG { static void gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { int temp = 0 ; temp = arr [ index ] ; arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = temp ; index -- ; } } return ; } public static void main ( String [ ] args ) { int arr [ ] = { 34 , 2 , 10 , - 9 } ; gnomeSort ( arr , arr . length ) ; System . out . print ( " Sorted ▁ sequence ▁ after ▁ applying ▁ Gnome ▁ sort : ▁ " ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }
import java . util . * ; class GFG { static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } System . out . println ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " + max_guests + " ▁ at ▁ time ▁ " + time ) ; } public static void main ( String [ ] args ) { int arrl [ ] = { 1 , 2 , 10 , 5 , 5 } ; int exit [ ] = { 4 , 5 , 12 , 9 , 12 } ; int n = arrl . length ; findMaxGuests ( arrl , exit , n ) ; } }
import java . io . * ; import java . util . * ; import java . text . * ; import java . math . * ; import java . util . regex . * ; class GFG { public static void maxOverlap ( int [ ] start , int [ ] end , int n ) { int maxa = Arrays . stream ( start ) . max ( ) . getAsInt ( ) ; int maxb = Arrays . stream ( end ) . max ( ) . getAsInt ( ) ; int maxc = Math . max ( maxa , maxb ) ; int [ ] x = new int [ maxc + 2 ] ; Arrays . fill ( x , 0 ) ; int cur = 0 , idx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ++ x [ start [ i ] ] ; -- x [ end [ i ] + 1 ] ; } int maxy = Integer . MIN_VALUE ; for ( int i = 0 ; i <= maxc ; i ++ ) { cur += x [ i ] ; if ( maxy < cur ) { maxy = cur ; idx = i ; } } System . out . println ( " Maximum ▁ value ▁ is : " + maxy + " ▁ at ▁ position : ▁ " + idx + " " ) ; } public static void main ( String [ ] args ) { int [ ] start = new int [ ] { 13 , 28 , 29 , 14 , 40 , 17 , 3 } ; int [ ] end = new int [ ] { 107 , 95 , 111 , 105 , 70 , 127 , 74 } ; int n = start . length ; maxOverlap ( start , end , n ) ; } }
import java . util . Arrays ; public class GFG { static void rearrange ( int [ ] arr , int n ) { int temp [ ] = arr . clone ( ) ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) arr [ i ] = temp [ large -- ] ; else arr [ i ] = temp [ small ++ ] ; flag = ! flag ; } } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 } ; System . out . println ( " Original ▁ Array ▁ " ) ; System . out . println ( Arrays . toString ( arr ) ) ; rearrange ( arr , arr . length ) ; System . out . println ( " Modified ▁ Array ▁ " ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }
public class Main { public static void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . length ; System . out . println ( " Original ▁ Array " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; rearrange ( arr , n ) ; System . out . print ( " Modified Array "); for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . io . * ; class GFG { static void rearrange ( int arr [ ] , int n ) { int j = 0 , temp ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { if ( i != j ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } } } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int arr [ ] = { - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 } ; int n = arr . length ; rearrange ( arr , n ) ; printArray ( arr , n ) ; } }
import java . util . Arrays ; class GFG { static void segregateElements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } public static void main ( String arg [ ] ) { int arr [ ] = { 1 , - 1 , - 3 , - 2 , 7 , 5 , 11 , 6 } ; int n = arr . length ; segregateElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class GFG { static void rearrange ( int arr [ ] , int n ) { int temp ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } if ( i % 2 != 0 && arr [ i ] < arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } } } static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 4 , 2 , 1 , 8 , 3 } ; int n = arr . length ; System . out . print ( "Before rearranging: NEW_LINE"); printArray ( arr , n ) ; rearrange ( arr , n ) ; System . out . print ( "After rearranging: NEW_LINE"); printArray ( arr , n ) ; } }
import java . io . * ; class GFG { static void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , - 3 , 5 , 6 , - 3 , 6 , 7 , - 4 , 9 , 10 } ; int n = arr . length ; rearrange ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
public class GFG { static void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 2 , 4 , 7 , 6 , 9 , 10 } ; int n = arr . length ; arrayEvenAndOdd ( arr , n ) ; } }
class Test { static int arr [ ] = { 10 , 324 , 45 , 90 , 9808 } ; static int largest ( ) { int i ; int max = arr [ 0 ] ; for ( i = 1 ; i < arr . length ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; } public static void main ( String [ ] args ) { System . out . println ( " Largest ▁ in ▁ given ▁ array ▁ is ▁ " + largest ( ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int largest ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] ; } static public void main ( String [ ] args ) { int [ ] arr = { 10 , 324 , 45 , 90 , 9808 } ; int n = arr . length ; System . out . println ( largest ( arr , n ) ) ; } }
import java . util . * ; class GFG { public static double findMean ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; } public static double findMedian ( int a [ ] , int n ) { Arrays . sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = a . length ; System . out . println ( " Mean ▁ = ▁ " + findMean ( a , n ) ) ; System . out . println ( " Median ▁ = ▁ " + findMedian ( a , n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static void printSmall ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String argc [ ] ) { int [ ] arr = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = 10 ; int k = 5 ; printSmall ( arr , n , k ) ; } }
class GFG { public static void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { System . out . print ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } first = second = Integer . MIN_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == Integer . MIN_VALUE ) System . out . print ( " There ▁ is ▁ no ▁ second ▁ largest " + " elementNEW_LINE"); else System . out . print ( " The ▁ second ▁ largest ▁ element " + " ▁ is ▁ " + second ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = arr . length ; print2largest ( arr , n ) ; } }
import java . io . * ; import java . lang . Math ; class GFG { static double sumNodes ( int l ) { double leafNodeCount = Math . pow ( 2 , l - 1 ) ; double sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; double sum = sumLastLevel * l ; return sum ; } public static void main ( String [ ] args ) { int l = 3 ; System . out . println ( sumNodes ( l ) ) ; } }
import java . io . * ; class GFG { static void add ( int arr [ ] , int N , int lo , int hi , int val ) { arr [ lo ] += val ; if ( hi != N - 1 ) arr [ hi + 1 ] -= val ; } static void updateArray ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) arr [ i ] += arr [ i - 1 ] ; } static void printArr ( int arr [ ] , int N ) { updateArray ( arr , N ) ; for ( int i = 0 ; i < N ; i ++ ) System . out . print ( " " + arr [ i ] + " ▁ " ) ; System . out . print ( "NEW_LINE"); } public static void main ( String [ ] args ) { int N = 6 ; int arr [ ] = new int [ N ] ; add ( arr , N , 0 , 2 , 100 ) ; add ( arr , N , 1 , 5 , 100 ) ; add ( arr , N , 2 , 3 , 100 ) ; printArr ( arr , N ) ; } }
import java . util . * ; class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static void FillPrefixSuffix ( int prefix [ ] , int arr [ ] , int suffix [ ] , int n ) { prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = GCD ( prefix [ i - 1 ] , arr [ i ] ) ; suffix [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix [ i ] = GCD ( suffix [ i + 1 ] , arr [ i ] ) ; } static int GCDoutsideRange ( int l , int r , int prefix [ ] , int suffix [ ] , int n ) { if ( l == 0 ) return suffix [ r + 1 ] ; if ( r == n - 1 ) return prefix [ l - 1 ] ; return GCD ( prefix [ l - 1 ] , suffix [ r + 1 ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 6 , 9 } ; int n = arr . length ; int prefix [ ] = new int [ n ] ; int suffix [ ] = new int [ n ] ; FillPrefixSuffix ( prefix , arr , suffix , n ) ; int l = 0 , r = 0 ; System . out . println ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) ; l = 1 ; r = 1 ; System . out . println ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) ; l = 1 ; r = 2 ; System . out . println ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) ; } }
import java . io . * ; class GFG { static int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 9 , 10 , 3 } ; int n = arr . length ; int i = 1 , j = 4 ; System . out . println ( countInRange ( arr , n , i , j ) ) ; i = 9 ; j = 12 ; System . out . println ( countInRange ( arr , n , i , j ) ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int lowerIndex ( int arr [ ] , int n , int x ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; } static int upperIndex ( int arr [ ] , int n , int y ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; } static int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 4 , 9 , 10 , 3 } ; int n = arr . length ; Arrays . sort ( arr ) ; int i = 1 , j = 4 ; System . out . println ( countInRange ( arr , n , i , j ) ) ; ; i = 9 ; j = 12 ; System . out . println ( countInRange ( arr , n , i , j ) ) ; } }
import java . util . Arrays ; class GFG { static void precompute ( int arr [ ] , int n , int pre [ ] ) { Arrays . fill ( pre , 0 ) ; pre [ n - 1 ] = arr [ n - 1 ] * ( int ) ( Math . pow ( 2 , 0 ) ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) pre [ i ] = pre [ i + 1 ] + arr [ i ] * ( 1 << ( n - 1 - i ) ) ; } static int decimalOfSubarr ( int arr [ ] , int l , int r , int n , int pre [ ] ) { if ( r != n - 1 ) return ( pre [ l ] - pre [ r + 1 ] ) / ( 1 << ( n - 1 - r ) ) ; return pre [ l ] / ( 1 << ( n - 1 - r ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 } ; int n = arr . length ; int pre [ ] = new int [ n ] ; precompute ( arr , n , pre ) ; System . out . println ( decimalOfSubarr ( arr , 2 , 4 , n , pre ) ) ; System . out . println ( decimalOfSubarr ( arr , 4 , 5 , n , pre ) ) ; } }
import java . io . * ; class GFG { static int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 5 } ; int n = a . length ; int l = 1 , r = 4 ; System . out . println ( answerQuery ( a , n , l , r ) ) ; l = 2 ; r = 4 ; System . out . println ( answerQuery ( a , n , l , r ) ) ; } }
import java . lang . Math ; class GFG { private static final int MAX = 2147483647 ; static int [ ] [ ] one = new int [ 100001 ] [ 32 ] ; static void make_prefix ( int A [ ] , int n ) { for ( int j = 0 ; j < 32 ; j ++ ) one [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int a = A [ i - 1 ] ; for ( int j = 0 ; j < 32 ; j ++ ) { int x = ( int ) Math . pow ( 2 , j ) ; if ( ( a & x ) != 0 ) one [ i ] [ j ] = 1 + one [ i - 1 ] [ j ] ; else one [ i ] [ j ] = one [ i - 1 ] [ j ] ; } } } static int Solve ( int L , int R ) { int l = L , r = R ; int tot_bits = r - l + 1 ; int X = MAX ; for ( int i = 0 ; i < 31 ; i ++ ) { int x = one [ r ] [ i ] - one [ l - 1 ] [ i ] ; if ( x >= tot_bits - x ) { int ith_bit = ( int ) Math . pow ( 2 , i ) ; X = X ^ ith_bit ; } } return X ; } public static void main ( String [ ] args ) { int n = 5 , q = 3 ; int A [ ] = { 210 , 11 , 48 , 22 , 133 } ; int L [ ] = { 1 , 4 , 2 } , R [ ] = { 3 , 14 , 4 } ; make_prefix ( A , n ) ; for ( int j = 0 ; j < q ; j ++ ) System . out . println ( Solve ( L [ j ] , R [ j ] ) ) ; } }
class GFG { static int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; } public static void main ( String [ ] args ) { int a = 5 , b = 13 , n = 3 ; System . out . println ( findCountOfPairs ( a , b , n ) ) ; } }
import java . util . * ; class GFG { static int minItems ( int k , int r ) { for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; } public static void main ( String args [ ] ) { int k = 15 ; int r = 2 ; System . out . println ( minItems ( k , r ) ) ; } }
class GFG { static int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 } ; int n = a . length ; int L , R ; L = 1 ; R = 8 ; System . out . println ( answer_query ( a , n , L , R ) ) ; L = 0 ; R = 4 ; System . out . println ( answer_query ( a , n , L , R ) ) ; } }
class GFG { public static int N = 1000 ; static int prefixans [ ] = new int [ 1000 ] ; public static void countIndex ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i + 1 < n && a [ i ] == a [ i + 1 ] ) prefixans [ i ] = 1 ; if ( i != 0 ) prefixans [ i ] += prefixans [ i - 1 ] ; } } public static int answer_query ( int l , int r ) { if ( l == 0 ) return prefixans [ r - 1 ] ; else return prefixans [ r - 1 ] - prefixans [ l - 1 ] ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 } ; int n = 9 ; countIndex ( a , n ) ; int L , R ; L = 1 ; R = 8 ; System . out . println ( answer_query ( L , R ) ) ; L = 0 ; R = 4 ; System . out . println ( answer_query ( L , R ) ) ; } }
import java . util . LinkedHashSet ; class GFG { static int repeated_digit ( int n ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; while ( n != 0 ) { int d = n % 10 ; if ( s . contains ( d ) ) { return 0 ; } s . add ( d ) ; n = n / 10 ; } return 1 ; } static int calculate ( int L , int R ) { int answer = 0 ; for ( int i = L ; i < R + 1 ; ++ i ) { answer = answer + repeated_digit ( i ) ; } return answer ; } public static void main ( String [ ] args ) { int L = 1 , R = 100 ; System . out . println ( calculate ( L , R ) ) ; } }
class GFG { static int countMinSwaps ( String st ) { int min_swaps = 0 ; int odd_0 = 0 , even_0 = 0 ; int odd_1 = 0 , even_1 = 0 ; int n = st . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( st . charAt ( i ) == '1' ) even_1 ++ ; else even_0 ++ ; } else { if ( st . charAt ( i ) == '1' ) odd_1 ++ ; else odd_0 ++ ; } } int cnt_swaps_1 = Math . min ( even_0 , odd_1 ) ; int cnt_swaps_2 = Math . min ( even_1 , odd_0 ) ; return Math . min ( cnt_swaps_1 , cnt_swaps_2 ) ; } public static void main ( String [ ] args ) { String st = "000111" ; System . out . println ( countMinSwaps ( st ) ) ; } }
class GFG { static long modpow ( long base , long exp , long modulus ) { base %= modulus ; long result = 1 ; while ( exp > 0 ) { if ( ( exp & 1 ) > 0 ) result = ( result * base ) % modulus ; base = ( base * base ) % modulus ; exp >>= 1 ; } return result ; } public static void main ( String [ ] args ) { long n = 654654 ; long mod = 971 ; System . out . println ( ( ( modpow ( n , 6 , mod ) + modpow ( n , 2 , mod ) ) % mod + 355 ) % mod ) ; } }
import java . io . * ; import java . util . * ; class Kadane { static int maxSubArraySum ( int a [ ] ) { int size = a . length ; int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } public static void main ( String [ ] args ) { int [ ] a = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; System . out . println ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + maxSubArraySum ( a ) ) ; } }
static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; else if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; }
class GFG { static int findMinRooms ( String slots [ ] , int n , int m ) { int counts [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; } public static void main ( String args [ ] ) { int n = 3 , m = 7 ; String slots [ ] = { "0101011" , "0011001" , "0110111" } ; System . out . println ( findMinRooms ( slots , n , m ) ) ; } }
import java . io . * ; class GFG { static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; } public static void main ( String [ ] args ) { int a [ ] = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = a . length ; int max_sum = maxSubArraySum ( a , n ) ; System . out . println ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + max_sum ) ; } }
class GFG { static void maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } System . out . println ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + max_so_far ) ; System . out . println ( " Starting ▁ index ▁ " + start ) ; System . out . println ( " Ending ▁ index ▁ " + end ) ; } public static void main ( String [ ] args ) { int a [ ] = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = a . length ; maxSubArraySum ( a , n ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static void countCurrency ( int amount ) { int [ ] notes = new int [ ] { 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 } ; int [ ] noteCounter = new int [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { noteCounter [ i ] = amount / notes [ i ] ; amount = amount - noteCounter [ i ] * notes [ i ] ; } } System . out . println ( " Currency ▁ Count ▁ - > " ) ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( noteCounter [ i ] != 0 ) { System . out . println ( notes [ i ] + " ▁ : ▁ " + noteCounter [ i ] ) ; } } } public static void main ( String argc [ ] ) { int amount = 868 ; countCurrency ( amount ) ; } }
import java . util . Arrays ; public class GFG { static int minSum ( int [ ] A , int n ) { int min_val = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ; return ( min_val * ( n - 1 ) ) ; } static public void main ( String [ ] args ) { int [ ] A = { 3 , 6 , 2 , 8 , 7 , 5 } ; int n = A . length ; System . out . println ( ( minSum ( A , n ) ) ) ; } }
import java . util . Arrays ; public class GFG { static void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] , j = 0 ; Arrays . fill ( allocation , - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; while ( j < m ) { count ++ ; if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } j = ( j + 1 ) % m ; } } System . out . print ( " Process No . Process Size Block no . "); for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( i + 1 + " TABSYMBOL TABSYMBOL " + processSize [ i ] + " TABSYMBOL TABSYMBOL " ) ; if ( allocation [ i ] != - 1 ) { System . out . print ( allocation [ i ] + 1 ) ; } else { System . out . print ( " Not ▁ Allocated " ) ; } System . out . println ( " " ) ; } } static public void main ( String [ ] args ) { int blockSize [ ] = { 5 , 10 , 20 } ; int processSize [ ] = { 10 , 20 , 5 } ; int m = blockSize . length ; int n = processSize . length ; NextFit ( blockSize , m , processSize , n ) ; } }
class Test { static int arr [ ] = new int [ ] { 3 , 7 , 90 , 20 , 10 , 50 , 40 } ; static void findMinAvgSubarray ( int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; int min_sum = curr_sum ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } System . out . println ( " Subarray ▁ between ▁ [ " + res_index + " , ▁ " + ( res_index + k - 1 ) + " ] ▁ has ▁ minimum ▁ average " ) ; } public static void main ( String [ ] args ) { int k = 3 ; findMinAvgSubarray ( arr . length , k ) ; } }
import java . io . * ; class GFG { static int [ ] seg = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ; static int computeSegment ( int x ) { if ( x == 0 ) return seg [ 0 ] ; int count = 0 ; while ( x > 0 ) { count += seg [ x % 10 ] ; x /= 10 ; } return count ; } static int elementMinSegment ( int [ ] arr , int n ) { int minseg = computeSegment ( arr [ 0 ] ) ; int minindex = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = computeSegment ( arr [ i ] ) ; if ( temp < minseg ) { minseg = temp ; minindex = i ; } } return arr [ minindex ] ; } static public void main ( String [ ] args ) { int [ ] arr = { 489 , 206 , 745 , 123 , 756 } ; int n = arr . length ; System . out . println ( elementMinSegment ( arr , n ) ) ; } }
class GFG { static void findLargest ( int m , int s ) { if ( s == 0 ) { System . out . print ( m == 1 ? " Largest ▁ number ▁ is ▁ 0" : " Not ▁ possible " ) ; return ; } if ( s > 9 * m ) { System . out . println ( " Not ▁ possible " ) ; return ; } int [ ] res = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( s >= 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } System . out . print ( " Largest ▁ number ▁ is ▁ " ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( res [ i ] ) ; } public static void main ( String [ ] args ) { int s = 9 , m = 2 ; findLargest ( m , s ) ; } }
import java . util . * ; import java . io . * ; class GFG { static int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) min = jumps + 1 ; } return min ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = arr . length ; System . out . print ( " Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ▁ end ▁ is ▁ " + minJumps ( arr , 0 , n - 1 ) ) ; } }
class GFG { static int minJumps ( int arr [ ] , int n ) { int [ ] jumps = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MAX_VALUE ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = Integer . MAX_VALUE ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 6 , 1 , 0 , 9 } ; int size = arr . length ; System . out . println ( " Minimum ▁ number ▁ of " + " ▁ jumps ▁ to ▁ reach ▁ end ▁ is ▁ " + minJumps ( arr , size ) ) ; } }
class SmallestSubArraySum { static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int min_len = n + 1 ; for ( int start = 0 ; start < n ; start ++ ) { int curr_sum = arr [ start ] ; if ( curr_sum > x ) return 1 ; for ( int end = start + 1 ; end < n ; end ++ ) { curr_sum += arr [ end ] ; if ( curr_sum > x && ( end - start + 1 ) < min_len ) min_len = ( end - start + 1 ) ; } } return min_len ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 4 , 45 , 6 , 10 , 19 } ; int x = 51 ; int n1 = arr1 . length ; int res1 = smallestSubWithSum ( arr1 , n1 , x ) ; if ( res1 == n1 + 1 ) System . out . println ( " Not ▁ Possible " ) ; else System . out . println ( res1 ) ; int arr2 [ ] = { 1 , 10 , 5 , 2 , 7 } ; int n2 = arr2 . length ; x = 9 ; int res2 = smallestSubWithSum ( arr2 , n2 , x ) ; if ( res2 == n2 + 1 ) System . out . println ( " Not ▁ Possible " ) ; else System . out . println ( res2 ) ; int arr3 [ ] = { 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 } ; int n3 = arr3 . length ; x = 280 ; int res3 = smallestSubWithSum ( arr3 , n3 , x ) ; if ( res3 == n3 + 1 ) System . out . println ( " Not ▁ Possible " ) ; else System . out . println ( res3 ) ; } }
class SmallestSubArraySum { static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 4 , 45 , 6 , 10 , 19 } ; int x = 51 ; int n1 = arr1 . length ; int res1 = smallestSubWithSum ( arr1 , n1 , x ) ; if ( res1 == n1 + 1 ) System . out . println ( " Not ▁ Possible " ) ; else System . out . println ( res1 ) ; int arr2 [ ] = { 1 , 10 , 5 , 2 , 7 } ; int n2 = arr2 . length ; x = 9 ; int res2 = smallestSubWithSum ( arr2 , n2 , x ) ; if ( res2 == n2 + 1 ) System . out . println ( " Not ▁ Possible " ) ; else System . out . println ( res2 ) ; int arr3 [ ] = { 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 } ; int n3 = arr3 . length ; x = 280 ; int res3 = smallestSubWithSum ( arr3 , n3 , x ) ; if ( res3 == n3 + 1 ) System . out . println ( " Not ▁ Possible " ) ; else System . out . println ( res3 ) ; } }
class Test { static int arr [ ] = new int [ ] { 16 , 16 , 16 } ; static int countMinOperations ( int n ) { int result = 0 ; while ( true ) { int zero_count = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) break ; else if ( arr [ i ] == 0 ) zero_count ++ ; } if ( zero_count == n ) return result ; if ( i == n ) { for ( int j = 0 ; j < n ; j ++ ) arr [ j ] = arr [ j ] / 2 ; result ++ ; } for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] % 2 == 1 ) { arr [ j ] -- ; result ++ ; } } } } public static void main ( String [ ] args ) { System . out . println ( "Minimum number of steps required to NEW_LINE" + " get ▁ the ▁ given ▁ target ▁ array ▁ is ▁ " + countMinOperations ( arr . length ) ) ; } }
class GFG { static int findMinOps ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 , j = n - 1 ; i <= j ; ) { if ( arr [ i ] == arr [ j ] ) { i ++ ; j -- ; } else if ( arr [ i ] > arr [ j ] ) { j -- ; arr [ j ] += arr [ j + 1 ] ; ans ++ ; } else { i ++ ; arr [ i ] += arr [ i - 1 ] ; ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 1 , 4 , 5 , 9 , 1 } ; System . out . println ( " Count ▁ of ▁ minimum ▁ operations ▁ is ▁ " + findMinOps ( arr , arr . length ) ) ; } }
class FindSmallestInteger { int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; } public static void main ( String [ ] args ) { FindSmallestInteger small = new FindSmallestInteger ( ) ; int arr1 [ ] = { 1 , 3 , 4 , 5 } ; int n1 = arr1 . length ; System . out . println ( small . findSmallest ( arr1 , n1 ) ) ; int arr2 [ ] = { 1 , 2 , 6 , 10 , 11 , 15 } ; int n2 = arr2 . length ; System . out . println ( small . findSmallest ( arr2 , n2 ) ) ; int arr3 [ ] = { 1 , 1 , 1 , 1 } ; int n3 = arr3 . length ; System . out . println ( small . findSmallest ( arr3 , n3 ) ) ; int arr4 [ ] = { 1 , 1 , 3 , 4 } ; int n4 = arr4 . length ; System . out . println ( small . findSmallest ( arr4 , n4 ) ) ; } }
class GFG { static int findMinDiff ( int [ ] arr , int n ) { int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 1 , 5 , 3 , 19 , 18 , 25 } ; System . out . println ( " Minimum ▁ difference ▁ is ▁ " + findMinDiff ( arr , arr . length ) ) ; } }
import java . util . Arrays ; class GFG { static int findMinDiff ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 1 , 5 , 3 , 19 , 18 , 25 } ; System . out . println ( " Minimum ▁ difference ▁ is ▁ " + findMinDiff ( arr , arr . length ) ) ; } }
import java . lang . * ; class GFG { public static void main ( String [ ] args ) { int a = 2 , b = 10 ; int size = Math . abs ( b - a ) + 1 ; int array [ ] = new int [ size ] ; for ( int i = a ; i <= b ; i ++ ) if ( i % 2 == 0 i % 5 == 0 ) array [ i - a ] = 1 ; System . out . println ( " MULTIPLES ▁ of ▁ 2" + " ▁ and ▁ 5 : " ) ; for ( int i = a ; i <= b ; i ++ ) if ( array [ i - a ] == 1 ) System . out . printf ( i + " ▁ " ) ; } }
class Test { static int arr1 [ ] = new int [ ] { 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; static int arr2 [ ] = new int [ ] { 1 , 1 , 1 , 1 , 1 , 0 , 1 } ; static int longestCommonSum ( int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; } public static void main ( String [ ] args ) { System . out . print ( " Length ▁ of ▁ the ▁ longest ▁ common ▁ span ▁ with ▁ same ▁ sum ▁ is ▁ " ) ; System . out . println ( longestCommonSum ( arr1 . length ) ) ; } }
class MergeArrays { void moveToEnd ( int mPlusN [ ] , int size ) { int i , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) { if ( mPlusN [ i ] != - 1 ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } } void merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) || ( j == n ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { MergeArrays mergearray = new MergeArrays ( ) ; int mPlusN [ ] = { 2 , 8 , - 1 , - 1 , - 1 , 13 , - 1 , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = N . length ; int m = mPlusN . length - n ; mergearray . moveToEnd ( mPlusN , m + n ) ; mergearray . merge ( mPlusN , N , m , n ) ; mergearray . printArray ( mPlusN , m + n ) ; } }
import java . util . Arrays ; class GFG { static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } Arrays . sort ( A , i , 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 5 , 3 , 4 , 6 } ; boolean B [ ] = { false , true , true , true , false } ; int n = A . length ; if ( sortedAfterSwap ( A , B , n ) ) { System . out . println ( " A ▁ can ▁ be ▁ sorted " ) ; } else { System . out . println ( " A ▁ can ▁ not ▁ be ▁ sorted " ) ; } } }
class GFG { static int sortedAfterSwap ( int [ ] A , int [ ] B , int n ) { int t = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; } public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 5 , 3 , 4 , 6 } ; int [ ] B = { 0 , 1 , 1 , 1 , 0 } ; int n = A . length ; if ( sortedAfterSwap ( A , B , n ) == 0 ) System . out . println ( " A ▁ can ▁ be ▁ sorted " ) ; else System . out . println ( " A ▁ can ▁ not ▁ be ▁ sorted " ) ; } }
class segregation { static void segregate0and1 ( int arr [ ] , int n ) { int type0 = 0 ; int type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type0 ] = arr [ type0 ] + arr [ type1 ] ; arr [ type1 ] = arr [ type0 ] - arr [ type1 ] ; arr [ type0 ] = arr [ type0 ] - arr [ type1 ] ; type1 -- ; } else { type0 ++ ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 } ; segregate0and1 ( arr , arr . length ) ; for ( int a : arr ) System . out . print ( a + " ▁ " ) ; } }
class Test { static int arr [ ] = new int [ ] { 1 , 20 , 6 , 4 , 5 } ; static int getInvCount ( int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; } public static void main ( String [ ] args ) { System . out . println ( " Number ▁ of ▁ inversions ▁ are ▁ " + getInvCount ( arr . length ) ) ; } }
import java . util . * ; import java . lang . * ; class Main { static void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { System . out . println ( " Invalid ▁ Input " ) ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( min_sum ) > Math . abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } System . out . println ( " ▁ The ▁ two ▁ elements ▁ whose ▁ " + " sum ▁ is ▁ minimum ▁ are ▁ " + arr [ min_l ] + " ▁ and ▁ " + arr [ min_r ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 60 , - 10 , 70 , - 80 , 85 } ; minAbsSumPair ( arr , 6 ) ; } }
import java . util . * ; import java . io . * ; class GFG { public static boolean increasing ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] >= a [ i + 1 ] ) return false ; return true ; } public static boolean decreasing ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] < arr [ i + 1 ] ) return false ; return true ; } public static int shortestUnsorted ( int a [ ] , int n ) { if ( increasing ( a , n ) == true || decreasing ( a , n ) == true ) return 0 ; else return 3 ; } public static void main ( String [ ] args ) { int ar [ ] = new int [ ] { 7 , 9 , 10 , 8 , 11 } ; int n = ar . length ; System . out . println ( shortestUnsorted ( ar , n ) ) ; } }
class FindUnion { static int printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) System . out . print ( arr1 [ i ++ ] + " ▁ " ) ; else if ( arr2 [ j ] < arr1 [ i ] ) System . out . print ( arr2 [ j ++ ] + " ▁ " ) ; else { System . out . print ( arr2 [ j ++ ] + " ▁ " ) ; i ++ ; } } while ( i < m ) System . out . print ( arr1 [ i ++ ] + " ▁ " ) ; while ( j < n ) System . out . print ( arr2 [ j ++ ] + " ▁ " ) ; return 0 ; } public static void main ( String args [ ] ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = arr1 . length ; int n = arr2 . length ; printUnion ( arr1 , arr2 , m , n ) ; } }
class FindIntersection { static void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { System . out . print ( arr2 [ j ++ ] + " ▁ " ) ; i ++ ; } } } public static void main ( String args [ ] ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = arr1 . length ; int n = arr2 . length ; printIntersection ( arr1 , arr2 , m , n ) ; } }
import java . util . Arrays ; class UnionAndIntersection { void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { if ( m > n ) { int tempp [ ] = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } Arrays . sort ( arr1 ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( arr1 [ i ] + " ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == - 1 ) System . out . print ( arr2 [ i ] + " ▁ " ) ; } } void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { if ( m > n ) { int tempp [ ] = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } Arrays . sort ( arr1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != - 1 ) System . out . print ( arr2 [ i ] + " ▁ " ) ; } } int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } public static void main ( String [ ] args ) { UnionAndIntersection u_i = new UnionAndIntersection ( ) ; int arr1 [ ] = { 7 , 1 , 5 , 2 , 3 , 6 } ; int arr2 [ ] = { 3 , 8 , 6 , 20 , 7 } ; int m = arr1 . length ; int n = arr2 . length ; System . out . println ( " Union ▁ of ▁ two ▁ arrays ▁ is ▁ " ) ; u_i . printUnion ( arr1 , arr2 , m , n ) ; System . out . println ( " " ) ; System . out . println ( " Intersection ▁ of ▁ two ▁ arrays ▁ is ▁ " ) ; u_i . printIntersection ( arr1 , arr2 , m , n ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static void intersection ( int a [ ] , int b [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( a [ i ] > b [ j ] ) { j ++ ; } else if ( b [ j ] > a [ i ] ) { i ++ ; } else { System . out . print ( a [ i ] + " ▁ " ) ; i ++ ; j ++ ; } } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 2 , 3 , 4 , 5 , 5 , 6 } ; int b [ ] = { 3 , 3 , 5 } ; int n = a . length ; int m = b . length ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; intersection ( a , b , n , m ) ; } }
import java . io . * ; class countzot { static void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 , temp = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; break ; } case 1 : mid ++ ; break ; case 2 : { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; break ; } } } } static void printArray ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int arr_size = arr . length ; sort012 ( arr , arr_size ) ; System . out . println ( " Array ▁ after ▁ seggregation ▁ " ) ; printArray ( arr , arr_size ) ; } }
class Main { static void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { System . out . println ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } System . out . println ( " ▁ The ▁ unsorted ▁ subarray ▁ which " + " ▁ makes ▁ the ▁ given ▁ array ▁ sorted ▁ lies " + " ▁ between ▁ the ▁ indices ▁ " + s + " ▁ and ▁ " + e ) ; return ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_size = arr . length ; printUnsorted ( arr , arr_size ) ; } }
import java . io . * ; import java . util . * ; class CountTriangles { static int findNumberOfTriangles ( int arr [ ] ) { int n = arr . length ; Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; System . out . println ( " Total ▁ number ▁ of ▁ triangles ▁ is ▁ " + findNumberOfTriangles ( arr ) ) ; } }
import java . util . * ; import java . io . * ; class GFG { static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = arr . length ; int k = 3 ; System . out . println ( " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " + countPairsWithDiffK ( arr , n , k ) ) ; } }
import java . util . * ; import java . io . * ; class GFG { static int binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( x > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; } static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 , i ; Arrays . sort ( arr ) ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( binarySearch ( arr , i + 1 , n - 1 , arr [ i ] + k ) != - 1 ) count ++ ; return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = arr . length ; int k = 3 ; System . out . println ( " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " + countPairsWithDiffK ( arr , n , k ) ) ; } }
import java . util . * ; class GFG { static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; Arrays . sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = arr . length ; int k = 3 ; System . out . println ( " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " + countPairsWithDiffK ( arr , n , k ) ) ; } }
import java . io . * ; class PairSum { static void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; } public static void main ( String [ ] args ) { int pair [ ] = { 15 , 13 , 11 , 10 , 12 , 10 , 9 , 8 , 7 , 5 } ; int n = 5 ; int [ ] arr = new int [ n ] ; constructArr ( arr , pair , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . util . Arrays ; class Test { static int arr1 [ ] = new int [ ] { 1 , 5 , 9 , 10 , 15 , 20 } ; static int arr2 [ ] = new int [ ] { 2 , 3 , 8 , 13 } ; static void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } } public static void main ( String [ ] args ) { merge ( arr1 . length , arr2 . length ) ; System . out . print ( " After ▁ Merging ▁ nFirst ▁ Array : ▁ " ) ; System . out . println ( Arrays . toString ( arr1 ) ) ; System . out . print ( " Second ▁ Array : ▁ " ) ; System . out . println ( Arrays . toString ( arr2 ) ) ; } }
class GFG { static void gouldSequence ( int n ) { for ( int row_num = 1 ; row_num <= n ; row_num ++ ) { int count = 1 ; int c = 1 ; for ( int i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } System . out . print ( count + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 16 ; gouldSequence ( n ) ; } }
import java . util . * ; import java . lang . * ; class GfG { public static int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; } public static void main ( String argc [ ] ) { int [ ] arr1 = new int [ ] { 10 , 2 , 3 , 6 , 4 , 1 } ; int [ ] arr2 = new int [ ] { 5 , 1 , 4 , 2 , 6 , 9 } ; int n1 = 6 ; int n2 = 6 ; System . out . println ( minMaxProduct ( arr1 , arr2 , n1 , n2 ) ) ; } }
public class GFG { public static final int M = 100 ; public static final int N = 100 ; static int find_min_odd_cost ( int given [ ] [ ] , int m , int n ) { int floor [ ] [ ] = new int [ M ] [ N ] ; int min_odd_cost = 0 ; int i , j , temp ; for ( j = 0 ; j < n ; j ++ ) floor [ 0 ] [ j ] = given [ 0 ] [ j ] ; for ( i = 1 ; i < m ; i ++ ) for ( j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j + 1 ] ) ; } else if ( j == n - 1 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; } else { temp = Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; temp = Math . min ( temp , floor [ i - 1 ] [ j + 1 ] ) ; floor [ i ] [ j ] = given [ i ] [ j ] + temp ; } } min_odd_cost = Integer . MAX_VALUE ; for ( j = 0 ; j < n ; j ++ ) { if ( floor [ n - 1 ] [ j ] % 2 == 1 ) { if ( min_odd_cost > floor [ n - 1 ] [ j ] ) min_odd_cost = floor [ n - 1 ] [ j ] ; } } if ( min_odd_cost == Integer . MIN_VALUE ) return - 1 ; return min_odd_cost ; } public static void main ( String args [ ] ) { int m = 5 , n = 5 ; int given [ ] [ ] = { { 1 , 2 , 3 , 4 , 6 } , { 1 , 2 , 3 , 4 , 5 } , { 1 , 2 , 3 , 4 , 5 } , { 1 , 2 , 3 , 4 , 5 } , { 100 , 2 , 3 , 4 , 5 } } ; System . out . println ( " Minimum ▁ odd ▁ cost ▁ is ▁ " + find_min_odd_cost ( given , m , n ) ) ; } }
import java . util . * ; import java . lang . * ; class GfG { public static int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; } public static void main ( String argc [ ] ) { int [ ] arr1 = new int [ ] { 10 , 2 , 3 , 6 , 4 , 1 } ; int [ ] arr2 = new int [ ] { 5 , 1 , 4 , 2 , 6 , 9 } ; int n1 = 6 ; int n2 = 6 ; System . out . println ( minMaxProduct ( arr1 , arr2 , n1 , n2 ) ) ; } }
class Main { static int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 34 , 10 , 6 , 40 } ; int n = arr . length ; int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) System . out . println ( " Element ▁ not ▁ found " ) ; else System . out . println ( " Element ▁ Found ▁ at ▁ Position : ▁ " + ( position + 1 ) ) ; } }
class Main { static int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; arr [ n ] = key ; return ( n + 1 ) ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ 20 ] ; arr [ 0 ] = 12 ; arr [ 1 ] = 16 ; arr [ 2 ] = 20 ; arr [ 3 ] = 40 ; arr [ 4 ] = 50 ; arr [ 5 ] = 70 ; int capacity = 20 ; int n = 6 ; int i , key = 26 ; System . out . print ( " Before ▁ Insertion : ▁ " ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; n = insertSorted ( arr , n , key , capacity ) ; System . out . print ( " After Insertion : "); for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class Main { static int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } static int deleteElement ( int arr [ ] , int n , int key ) { int pos = findElement ( arr , n , key ) ; if ( pos == - 1 ) { System . out . println ( " Element ▁ not ▁ found " ) ; return n ; } int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; } public static void main ( String args [ ] ) { int i ; int arr [ ] = { 10 , 50 , 30 , 40 , 20 } ; int n = arr . length ; int key = 30 ; System . out . println ( " Array ▁ before ▁ deletion " ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; n = deleteElement ( arr , n , key ) ; System . out . println ( " Array after deletion "); for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class Main { static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = arr . length - 1 ; key = 10 ; System . out . println ( " Index : ▁ " + binarySearch ( arr , 0 , n , key ) ) ; } }
class GFG { static int findSDSFunc ( int n ) { int DP [ ] = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( findSDSFunc ( n ) ) ; } }
class FindCommon { void findCommon ( int ar1 [ ] , int ar2 [ ] , int ar3 [ ] ) { int i = 0 , j = 0 , k = 0 ; while ( i < ar1 . length && j < ar2 . length && k < ar3 . length ) { if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { System . out . print ( ar1 [ i ] + " ▁ " ) ; i ++ ; j ++ ; k ++ ; } else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ; else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ; else k ++ ; } } public static void main ( String args [ ] ) { FindCommon ob = new FindCommon ( ) ; int ar1 [ ] = { 1 , 5 , 10 , 20 , 40 , 80 } ; int ar2 [ ] = { 6 , 7 , 20 , 80 , 100 } ; int ar3 [ ] = { 3 , 4 , 15 , 20 , 30 , 70 , 80 , 120 } ; System . out . print ( " Common ▁ elements ▁ are ▁ " ) ; ob . findCommon ( ar1 , ar2 , ar3 ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int Jacobsthal ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; } public static int Jacobsthal_Lucas ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 2 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; } public static void main ( String argc [ ] ) { int n = 5 ; System . out . println ( " Jacobsthal ▁ number : ▁ " + Jacobsthal ( n ) ) ; System . out . println ( " Jacobsthal - Lucas ▁ number : ▁ " + Jacobsthal_Lucas ( n ) ) ; } }
class Test { static int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } static int findPos ( int arr [ ] , int key ) { int l = 0 , h = 1 ; int val = arr [ 0 ] ; while ( val < key ) { l = h ; if ( 2 * h < arr . length - 1 ) h = 2 * h ; else h = arr . length - 1 ; val = arr [ h ] ; } return binarySearch ( arr , l , h , key ) ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 3 , 5 , 7 , 9 , 10 , 90 , 100 , 130 , 140 , 160 , 170 } ; int ans = findPos ( arr , 10 ) ; if ( ans == - 1 ) System . out . println ( " Element ▁ not ▁ found " ) ; else System . out . println ( " Element ▁ found ▁ at ▁ index ▁ " + ans ) ; } }
class GFG { static long answer ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( answer ( n ) ) ; } }
class MaxSum { static int findSingle ( int ar [ ] , int ar_size ) { int res = ar [ 0 ] ; for ( int i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; } public static void main ( String [ ] args ) { int ar [ ] = { 2 , 3 , 5 , 4 , 5 , 3 , 4 } ; int n = ar . length ; System . out . println ( " Element ▁ occurring ▁ once ▁ is ▁ " + findSingle ( ar , n ) + " ▁ " ) ; } }
import java . util . * ; class GFG { public static int dp [ ] [ ] ; public static void computeDpArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 1 ; j <= 15000 ; ++ j ) { if ( i == 0 && j == arr [ i ] ) dp [ i ] [ j ] = 1 ; else if ( i == 0 ) dp [ i ] [ j ] = 0 ; else if ( arr [ i ] == j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } public static int countTripletSum ( int arr [ ] , int n ) { computeDpArray ( arr , n ) ; int ans = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { for ( int j = i + 1 ; j < n - 1 ; ++ j ) { for ( int k = 1 ; k <= 24 ; ++ k ) { int cube = k * k * k ; int rem = cube - ( arr [ i ] + arr [ j ] ) ; if ( rem > 0 ) ans += dp [ n - 1 ] [ rem ] - dp [ j ] [ rem ] ; } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 1 , 20 , 6 } ; int n = arr . length ; dp = new int [ 1001 ] [ 15001 ] ; System . out . println ( countTripletSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static boolean isPresent ( int B [ ] , int m , int x ) { for ( int i = 0 ; i < m ; i ++ ) if ( B [ i ] == x ) return true ; return false ; } static int findMaxSubarraySumUtil ( int A [ ] , int B [ ] , int n , int m ) { int max_so_far = - 2147483648 , curr_max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPresent ( B , m , A [ i ] ) ) { curr_max = 0 ; continue ; } curr_max = Math . max ( A [ i ] , curr_max + A [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; } static void findMaxSubarraySum ( int A [ ] , int B [ ] , int n , int m ) { int maxSubarraySum = findMaxSubarraySumUtil ( A , B , n , m ) ; if ( maxSubarraySum == - 2147483648 ) { System . out . println ( " Maximum ▁ Subarray ▁ Sum " + " ▁ " + " can ' t ▁ be ▁ found " ) ; } else { System . out . println ( " The ▁ Maximum ▁ Subarray ▁ Sum ▁ = ▁ " + maxSubarraySum ) ; } } public static void main ( String [ ] args ) { int A [ ] = { 3 , 4 , 5 , - 4 , 6 } ; int B [ ] = { 1 , 8 , 5 } ; int n = A . length ; int m = B . length ; findMaxSubarraySum ( A , B , n , m ) ; } }
import java . io . * ; class GFG { static int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( " Non - decreasing ▁ digits ▁ = ▁ " + nonDecNums ( n ) ) ; } }
class GFG { static final int MOD = 1000000007 ; public static long countBT ( int h ) { long [ ] dp = new long [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; } public static void main ( String [ ] args ) { int h = 3 ; System . out . println ( " No . ▁ of ▁ balanced ▁ binary ▁ trees ▁ of ▁ height ▁ " + h + " ▁ is : ▁ " + countBT ( h ) ) ; } }
class EquilibriumIndex { int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { EquilibriumIndex equi = new EquilibriumIndex ( ) ; int arr [ ] = { - 7 , 1 , 5 , 2 , - 4 , 3 , 0 } ; int arr_size = arr . length ; System . out . println ( equi . equilibrium ( arr , arr_size ) ) ; } }
class GFG { static final int MAX = 100 ; static int countEndless ( boolean input [ ] [ ] , int n ) { boolean row [ ] [ ] = new boolean [ n ] [ n ] ; boolean col [ ] [ ] = new boolean [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { boolean isEndless = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; col [ i ] [ j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { boolean isEndless = true ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; row [ i ] [ j ] = isEndless ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; } public static void main ( String arg [ ] ) { boolean input [ ] [ ] = { { true , false , true , true } , { false , true , true , true } , { true , true , true , true } , { false , true , true , false } } ; int n = 4 ; System . out . print ( countEndless ( input , n ) ) ; } }
class EquilibriumIndex { int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; } public static void main ( String [ ] args ) { EquilibriumIndex equi = new EquilibriumIndex ( ) ; int arr [ ] = { - 7 , 1 , 5 , 2 , - 4 , 3 , 0 } ; int arr_size = arr . length ; System . out . println ( " First ▁ equilibrium ▁ index ▁ is ▁ " + equi . equilibrium ( arr , arr_size ) ) ; } }
import java . util . Arrays ; class GFG { public static int sumOfSubstrings ( String num ) { int n = num . length ( ) ; int sumofdigit [ ] = new int [ n ] ; sumofdigit [ 0 ] = num . charAt ( 0 ) - '0' ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = num . charAt ( i ) - '0' ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; } public static void main ( String [ ] args ) { String num = "1234" ; System . out . println ( sumOfSubstrings ( num ) ) ; } }
class LeadersInArray { void printLeaders ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { LeadersInArray lead = new LeadersInArray ( ) ; int arr [ ] = new int [ ] { 16 , 17 , 4 , 3 , 5 , 2 } ; int n = arr . length ; lead . printLeaders ( arr , n ) ; } }
class LeadersInArray { void printLeaders ( int arr [ ] , int size ) { int max_from_right = arr [ size - 1 ] ; System . out . print ( max_from_right + " ▁ " ) ; for ( int i = size - 2 ; i >= 0 ; i -- ) { if ( max_from_right < arr [ i ] ) { max_from_right = arr [ i ] ; System . out . print ( max_from_right + " ▁ " ) ; } } } public static void main ( String [ ] args ) { LeadersInArray lead = new LeadersInArray ( ) ; int arr [ ] = new int [ ] { 16 , 17 , 4 , 3 , 5 , 2 } ; int n = arr . length ; lead . printLeaders ( arr , n ) ; } }
public class UboundedKnapsack { private static int max ( int i , int j ) { return ( i > j ) ? i : j ; } private static int unboundedKnapsack ( int W , int n , int [ ] val , int [ ] wt ) { int dp [ ] = new int [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( wt [ j ] <= i ) { dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; } } } return dp [ W ] ; } public static void main ( String [ ] args ) { int W = 100 ; int val [ ] = { 10 , 30 , 20 } ; int wt [ ] = { 5 , 10 , 15 } ; int n = val . length ; System . out . println ( unboundedKnapsack ( W , n , val , wt ) ) ; } }
class Main { static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = arr . length ; int x = 3 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) System . out . println ( " Ceiling ▁ of ▁ " + x + " ▁ doesn ' t ▁ exist ▁ in ▁ array " ) ; else System . out . println ( " ceiling ▁ of ▁ " + x + " ▁ is ▁ " + arr [ index ] ) ; } }
class GFG { static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) { int fw [ ] = new int [ n ] ; int bw [ ] = new int [ n ] ; int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ; fw [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; fw [ i ] = cur_max ; } cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } int fans = max_so_far ; for ( int i = 1 ; i < n - 1 ; i ++ ) fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ; return fans ; } public static void main ( String arg [ ] ) { int arr [ ] = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = arr . length ; System . out . print ( maxSumSubarrayRemovingOneEle ( arr , n ) ) ; } }
class Main { static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = arr . length ; int x = 8 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) System . out . println ( " Ceiling ▁ of ▁ " + x + " ▁ doesn ' t ▁ exist ▁ in ▁ array " ) ; else System . out . println ( " ceiling ▁ of ▁ " + x + " ▁ is ▁ " + arr [ index ] ) ; } }
class GFG { public static double maxAverageOfPath ( int cost [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; } public static void main ( String [ ] args ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 6 , 5 , 4 } , { 7 , 3 , 9 } } ; System . out . println ( maxAverageOfPath ( cost , 3 ) ) ; } }
import java . util . * ; class GFG { public static int maxCost ( int mat [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 4 , 1 , 5 , 6 , 1 } , { 2 , 9 , 2 , 11 , 10 } , { 15 , 1 , 3 , 15 , 2 } , { 16 , 92 , 41 , 4 , 3 } , { 8 , 142 , 6 , 4 , 8 } } ; int N = 5 ; System . out . println ( " Maximum ▁ Path ▁ Sum ▁ : ▁ " + maxCost ( mat , N ) ) ; } }
import java . io . * ; class GFG { static int maxProfit ( int price [ ] , int n , int k ) { int profit [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { int prevDiff = Integer . MIN_VALUE ; for ( int j = 1 ; j < n ; j ++ ) { prevDiff = Math . max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ; } } return profit [ k ] [ n - 1 ] ; } public static void main ( String [ ] args ) { int k = 3 ; int price [ ] = { 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 } ; int n = price . length ; System . out . println ( " Maximum ▁ profit ▁ is : ▁ " + maxProfit ( price , n , k ) ) ; } }
import java . io . * ; class GFG { static int countSeq ( int n , int diff ) { if ( Math . abs ( diff ) > n ) return 0 ; if ( n == 1 && diff == 0 ) return 2 ; if ( n == 1 && Math . abs ( diff ) == 1 ) return 1 ; int res = countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ; return res ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( " Count ▁ of ▁ sequences ▁ is ▁ " + countSeq ( 2 , 0 ) ) ; } }
import java . io . * ; class GFG { static int lookup [ ] [ ] = new int [ 1000 ] [ 1000 ] ; static int countSeqUtil ( int n , int dif ) { if ( Math . abs ( dif ) > n ) return 0 ; if ( n == 1 && dif == 0 ) return 2 ; if ( n == 1 && Math . abs ( dif ) == 1 ) return 1 ; if ( lookup [ n ] [ n + dif ] != - 1 ) return lookup [ n ] [ n + dif ] ; countSeqUtil ( n - 1 , dif + 1 ) + 2 * countSeqUtil ( n - 1 , dif ) + countSeqUtil ( n - 1 , dif - 1 ) ; return lookup [ n ] [ n + dif ] = res ; } static int countSeq ( int n ) { for ( int k = 0 ; k < lookup . length ; k ++ ) { for ( int j = 0 ; j < lookup . length ; j ++ ) { lookup [ k ] [ j ] = - 1 ; } } return countSeqUtil ( n , 0 ) ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( " Count ▁ of ▁ sequences ▁ is ▁ " + countSeq ( 2 ) ) ; } }
class GFG { static int min ( int a , int b ) { return ( a < b ) ? a : b ; } static int min ( int arr [ ] , int l , int h ) { int mn = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( mn > arr [ i ] ) mn = arr [ i ] ; return mn ; } static int max ( int arr [ ] , int l , int h ) { int mx = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( mx < arr [ i ] ) mx = arr [ i ] ; return mx ; } static int minRemovals ( int arr [ ] , int l , int h ) { if ( l >= h ) return 0 ; int mn = min ( arr , l , h ) ; int mx = max ( arr , l , h ) ; if ( 2 * mn > mx ) return 0 ; return min ( minRemovals ( arr , l + 1 , h ) , minRemovals ( arr , l , h - 1 ) ) + 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 } ; int n = arr . length ; System . out . print ( minRemovals ( arr , 0 , n - 1 ) ) ; } }
class GFG { static int numberOfPaths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; + count [ i - 1 ] [ j - 1 ] ; } return count [ m - 1 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { System . out . println ( numberOfPaths ( 3 , 3 ) ) ; } }
import java . io . * ; class GFG { static int maxProd ( int n ) { if ( n == 0 n == 1 ) return 0 ; int max_val = 0 ; for ( int i = 1 ; i < n ; i ++ ) max_val = Math . max ( max_val , Math . max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) ; return max_val ; } public static void main ( String [ ] args ) { System . out . println ( " Maximum ▁ Product ▁ is ▁ " + maxProd ( 10 ) ) ; } }
import java . io . * ; class GFG { static int NUM_LINE = 2 ; static int NUM_STATION = 4 ; static int min ( int a , int b ) { return a < b ? a : b ; } static int carAssembly ( int a [ ] [ ] , int t [ ] [ ] , int e [ ] , int x [ ] ) { int T1 [ ] = new int [ NUM_STATION ] ; int T2 [ ] = new int [ NUM_STATION ] ; int i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 4 , 5 , 3 , 2 } , { 2 , 10 , 1 , 4 } } ; int t [ ] [ ] = { { 0 , 7 , 4 , 5 } , { 0 , 9 , 2 , 8 } } ; int e [ ] = { 10 , 12 } , x [ ] = { 18 , 7 } ; System . out . println ( carAssembly ( a , t , e , x ) ) ; } }
class GFG { static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) { int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Integer . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; } public static void main ( String [ ] args ) { String X = " OldSite : GeeksforGeeks . org " ; String Y = " NewSite : GeeksQuiz . com " ; int m = X . length ( ) ; int n = Y . length ( ) ; System . out . println ( LCSubStr ( X . toCharArray ( ) , Y . toCharArray ( ) , m , n ) ) ; } }
import java . util . * ; class GFG { static int maxCrossingSum ( int arr [ ] , int l , int m , int h ) { int sum = 0 ; int left_sum = Integer . MIN_VALUE ; for ( int i = m ; i >= l ; i -- ) { sum = sum + arr [ i ] ; if ( sum > left_sum ) left_sum = sum ; } sum = 0 ; int right_sum = Integer . MIN_VALUE ; for ( int i = m + 1 ; i <= h ; i ++ ) { sum = sum + arr [ i ] ; if ( sum > right_sum ) right_sum = sum ; } return Math . max ( left_sum + right_sum , Math . max ( left_sum , right_sum ) ) ; } static int maxSubArraySum ( int arr [ ] , int l , int h ) { if ( l == h ) return arr [ l ] ; int m = ( l + h ) / 2 ; return Math . max ( Math . max ( maxSubArraySum ( arr , l , m ) , maxSubArraySum ( arr , m + 1 , h ) ) , maxCrossingSum ( arr , l , m , h ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 , 7 } ; int n = arr . length ; int max_sum = maxSubArraySum ( arr , 0 , n - 1 ) ; System . out . println ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + max_sum ) ; } }
import java . lang . * ; class GFG { static float findWater ( int i , int j , float X ) { if ( j > i ) { System . out . println ( " Incorrect ▁ Input " ) ; System . exit ( 0 ) ; } int ll = Math . round ( ( i * ( i + 1 ) ) ) ; float [ ] glass = new float [ ll + 2 ] ; int index = 0 ; glass [ index ] = X ; for ( int row = 1 ; row <= i ; ++ row ) { for ( int col = 1 ; col <= row ; ++ col , ++ index ) { X = glass [ index ] ; glass [ index ] = ( X >= 1.0f ) ? 1.0f : X ; X = ( X >= 1.0f ) ? ( X - 1 ) : 0.0f ; glass [ index + row ] += X / 2 ; glass [ index + row + 1 ] += X / 2 ; } } return glass [ ( int ) ( i * ( i - 1 ) / 2 + j - 1 ) ] ; } public static void main ( String [ ] args ) { int i = 2 , j = 2 ; float X = 2.0f ; System . out . println ( " Amount ▁ of ▁ water ▁ in ▁ jth ▁ " + " glass ▁ of ▁ ith ▁ row ▁ is : ▁ " + findWater ( i , j , X ) ) ; } }
public class GFG { static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] [ ] C = new int [ n ] [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = Integer . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { String str = " ababbbabbababa " ; System . out . println ( " Min ▁ cuts ▁ needed ▁ for ▁ " + " Palindrome ▁ Partitioning ▁ is ▁ " + minPalPartion ( str ) ) ; } }
import java . util . * ; public class GfG { public static int doMatch ( String A , String B ) { for ( int i = 0 ; i < A . length ( ) ; i ++ ) { if ( A . charAt ( i ) != ' * ' && B . charAt ( i ) != ' * ' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; } public static void main ( String [ ] args ) { String A = " gee * sforgeeks " ; String B = " geeksforgeeks " ; System . out . println ( doMatch ( A , B ) ) ; } }
import java . util . * ; class GFG { static int countSubstrs ( String s1 , String s2 ) { int ans = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { String s3 = " " ; char [ ] s4 = s1 . toCharArray ( ) ; for ( int j = i ; j < s1 . length ( ) ; j ++ ) { s3 += s4 [ j ] ; if ( s2 . indexOf ( s3 ) != - 1 ) ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { String s1 = " aab " , s2 = " aaaab " ; System . out . println ( countSubstrs ( s1 , s2 ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int factorial ( int N ) { int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact = fact * i ; return fact ; } static int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; } public static void main ( String args [ ] ) { int N = 6 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { public static boolean regexMatch ( String text , String pat ) { int lenText = text . length ( ) ; int lenPat = pat . length ( ) ; char [ ] Text = text . toCharArray ( ) ; char [ ] Pat = pat . toCharArray ( ) ; int i = 0 , j = 0 ; while ( i < lenPat ) { if ( Pat [ i ] != ' # ' ) { if ( Pat [ i ] != Text [ j ] ) return false ; i ++ ; j ++ ; } else { j ++ ; while ( Text [ j ] != Pat [ i + 1 ] ) j ++ ; i ++ ; } } return ( j == lenText ) ; } public static void main ( String [ ] args ) { String str = " ABABABA " ; String pat = " A # B # A " ; if ( regexMatch ( str , pat ) ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; } }
class GfG { static void update ( int arr [ ] , int l , int r , int val ) { arr [ l ] += val ; if ( r + 1 < arr . length ) arr [ r + 1 ] -= val ; } static int getElement ( int arr [ ] , int i ) { int res = 0 ; for ( int j = 0 ; j <= i ; j ++ ) res += arr [ j ] ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 } ; int n = arr . length ; int l = 2 , r = 4 , val = 2 ; update ( arr , l , r , val ) ; int index = 4 ; System . out . println ( " Element ▁ at ▁ index ▁ " + index + " ▁ is ▁ " + getElement ( arr , index ) ) ; l = 0 ; r = 3 ; val = 4 ; update ( arr , l , r , val ) ; index = 3 ; System . out . println ( " Element ▁ at ▁ index ▁ " + index + " ▁ is ▁ " + getElement ( arr , index ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; } static int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ; } static int NumberOfWays ( int n , int x , int y ) { return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ; } public static void main ( String [ ] args ) throws java . lang . Exception { int n = 5 , x = 4 , y = 2 ; System . out . println ( NumberOfWays ( n , x , y ) ) ; } }
import java . io . * ; class GFG { static int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; } int pairs = Math . min ( odd1 , odd2 ) + Math . min ( even1 , even2 ) ; return pairs ; } public static void main ( String [ ] args ) { int a [ ] = { 9 , 14 , 6 , 2 , 11 } ; int b [ ] = { 8 , 4 , 7 , 20 } ; int n = a . length ; int m = b . length ; System . out . println ( count_pairs ( a , b , n , m ) ) ; } }
import java . io . * ; class GFG { static int getValueOfF ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n /= 2 ; } return 2 * cnt ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( getValueOfF ( n ) ) ; } }
class GFG { static int A_mod_B ( String N , int a ) { int len = N . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) ans = ( ans * 10 + ( int ) N . charAt ( i ) - '0' ) % a ; return ans % a ; } static int findMod ( String N ) { int mod = A_mod_B ( N , 4 ) ; int ans = ( 1 + ( int ) Math . pow ( 2 , mod ) + ( int ) Math . pow ( 3 , mod ) + ( int ) Math . pow ( 4 , mod ) ) ; return ( ans % 5 ) ; } public static void main ( String args [ ] ) { String N = "4" ; System . out . println ( findMod ( N ) ) ; } }
class GfG { static void printElements ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 } ; int n = arr . length ; printElements ( arr , n ) ; } }
import java . lang . Math ; class GFG { static int exponent ( int A , int B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; int y ; if ( B % 2 == 0 ) { y = exponent ( A , B / 2 ) ; y = ( y * y ) ; } else { y = A ; y = ( y * exponent ( A , B - 1 ) ) ; } return y ; } static int sum ( int k , int n ) { int sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 3 ; int K = 3 ; System . out . println ( sum ( K , n ) ) ; } }
import java . util . * ; class GFG { static boolean isPrime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; } static int minimumCost ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 1 && isPrime ( n - 2 ) ) return 2 ; if ( n % 2 == 0 ) return 2 ; return 3 ; } public static void main ( String args [ ] ) { int n = 6 ; System . out . println ( minimumCost ( n ) ) ; } }
class GFG { static double wastedWater ( double V , double M , double N ) { double wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; } public static void main ( String [ ] args ) { double V , M , N ; V = 700 ; M = 10 ; N = 3 ; System . out . println ( wastedWater ( V , M , N ) ) ; V = 1000 ; M = 100 ; N = 50 ; System . out . println ( wastedWater ( V , M , N ) ) ; } }
class GFG { static void nDigitPerfectCubes ( int n ) { int smallest = ( int ) Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n - 1 ) ) ) ) , 3 ) ; System . out . print ( smallest + " ▁ " ) ; int largest = ( int ) Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ; System . out . print ( largest ) ; } public static void main ( String args [ ] ) { int n = 3 ; nDigitPerfectCubes ( n ) ; } }
class GFG { static int countNumbers ( int n ) { return ( n / 2520 ) ; } public static void main ( String args [ ] ) { int n = 3000 ; System . out . println ( countNumbers ( n ) ) ; } }
import java . io . * ; class GFG { static int MAX = 100001 ; static int prefix [ ] = new int [ MAX ] ; static void sieve_modified ( ) { for ( int i = 1 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( int i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; } static int sumOddFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; } public static void main ( String [ ] args ) { sieve_modified ( ) ; int l = 6 , r = 10 ; System . out . println ( sumOddFactors ( l , r ) ) ; } }
class GfG { static int n = 3 ; static void preComputeXor ( int arr [ ] [ ] , int prefix_xor [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) prefix_xor [ i ] [ j ] = arr [ i ] [ j ] ; else prefix_xor [ i ] [ j ] = ( prefix_xor [ i ] [ j - 1 ] ^ arr [ i ] [ j ] ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) prefix_xor [ j ] [ i ] = ( prefix_xor [ j - 1 ] [ i ] ^ prefix_xor [ j ] [ i ] ) ; } static int ansQuerie ( int prefix_xor [ ] [ ] , int x1 , int y1 , int x2 , int y2 ) { int xor_1 = 0 , xor_2 = 0 , xor_3 = 0 ; if ( x1 != 0 ) xor_1 = prefix_xor [ x1 - 1 ] [ y2 ] ; if ( y1 != 0 ) xor_2 = prefix_xor [ x2 ] [ y1 - 1 ] ; if ( x1 != 0 && y1 != 0 ) xor_3 = prefix_xor [ x1 - 1 ] [ y1 - 1 ] ; return ( ( prefix_xor [ x2 ] [ y2 ] ^ xor_1 ) ^ ( xor_2 ^ xor_3 ) ) ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = new int [ ] [ ] { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int prefix_xor [ ] [ ] = new int [ n ] [ n ] ; preComputeXor ( arr , prefix_xor ) ; System . out . println ( ansQuerie ( prefix_xor , 1 , 1 , 2 , 2 ) ) ; System . out . println ( ansQuerie ( prefix_xor , 1 , 2 , 2 , 2 ) ) ; } }
class GFG { static boolean isDigitSumOne ( int nm ) { if ( nm % 9 == 1 ) return true ; else return false ; } static void printValidNums ( int n ) { int cbrt_n = ( int ) Math . cbrt ( n ) ; for ( int i = 1 ; i <= cbrt_n ; i ++ ) { int cube = ( int ) Math . pow ( i , 3 ) ; if ( cube >= 1 && cube <= n && isDigitSumOne ( cube ) ) System . out . print ( cube + " ▁ " ) ; } } public static void main ( String args [ ] ) { int n = 1000 ; printValidNums ( n ) ; } }
import java . io . * ; class GFG { static int countRhombi ( int h , int w ) { int ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; } public static void main ( String [ ] args ) { int h = 2 , w = 2 ; System . out . println ( countRhombi ( h , w ) ) ; } }
import java . io . * ; class GFG { static double calculateArea ( int x , int y ) { double pi = 3.1415926536 ; double arx = pi * x * x ; double ary = pi * y * y ; return arx - ary ; } public static void main ( String [ ] args ) { int x = 2 ; int y = 1 ; System . out . println ( calculateArea ( x , y ) ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static char getWinner ( int [ ] arr , int n ) { int gcd = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { gcd = __gcd ( gcd , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } int totalMoves = ( maxEle / gcd ) - n ; if ( totalMoves % 2 == 1 ) return ' A ' ; return ' B ' ; } public static void main ( String args [ ] ) { int [ ] arr = { 5 , 6 , 7 } ; int n = arr . length ; System . out . print ( getWinner ( arr , n ) ) ; } }
class GFG { public static int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countPairs ( n ) ) ; } }
class GFG { static String isDivisible ( int n ) { int temp = n ; while ( n > 0 ) { int k = n % 10 ; if ( temp % k == 0 ) { return " YES " ; } n /= 10 ; } return " NO " ; } public static void main ( String [ ] args ) { int n = 9876543 ; System . out . println ( isDivisible ( n ) ) ; } }
import java . io . * ; class GFG { static double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . printf ( " Sum ▁ is ▁ % f " , sum ( n ) ) ; } }
import java . util . * ; class GFG { static final int N = 100005 ; static Set < Integer > ABUNDANT ( ) { Set < Integer > v = new HashSet < > ( ) ; for ( int i = 1 ; i < N ; i ++ ) { int sum = 1 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { sum += j ; if ( i / j != j ) { sum += i / j ; } } } if ( sum > i ) { v . add ( i ) ; } } return v ; } static void SumOfAbundant ( int n ) { Set < Integer > v = ABUNDANT ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( v . contains ( i ) & v . contains ( n - i ) ) { System . out . print ( i + " ▁ " + ( n - i ) ) ; return ; } } System . out . print ( - 1 ) ; } public static void main ( String [ ] args ) { int n = 24 ; SumOfAbundant ( n ) ; } }
import java . lang . Math ; class GFG { static long nthTermOfTheSeries ( int n ) { long nthTerm ; if ( n % 2 == 0 ) nthTerm = ( long ) Math . pow ( n - 1 , 2 ) + n ; else nthTerm = ( long ) Math . pow ( n + 1 , 2 ) + n ; return nthTerm ; } public static void main ( String [ ] args ) { int n ; n = 8 ; System . out . println ( nthTermOfTheSeries ( n ) ) ; n = 12 ; System . out . println ( nthTermOfTheSeries ( n ) ) ; n = 102 ; System . out . println ( nthTermOfTheSeries ( n ) ) ; n = 999 ; System . out . println ( nthTermOfTheSeries ( n ) ) ; n = 9999 ; System . out . println ( nthTermOfTheSeries ( n ) ) ; } }
import java . util . * ; class solution { static float CPwithProfit ( int sellingPrice , int profit ) { float costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 + profit ) ; return costPrice ; } static float CPwithLoss ( int sellingPrice , int loss ) { float costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 - loss ) ; return costPrice ; } public static void main ( String args [ ] ) { int SP , profit , loss ; SP = 1020 ; profit = 20 ; System . out . println ( " Cost ▁ Price ▁ = ▁ " + CPwithProfit ( SP , profit ) ) ; SP = 900 ; loss = 10 ; System . out . println ( " Cost ▁ Price ▁ = ▁ " + CPwithLoss ( SP , loss ) ) ; SP = 42039 ; profit = 8 ; System . out . println ( " Cost ▁ Price ▁ = ▁ " + CPwithProfit ( SP , profit ) ) ; } }
class GFG { static boolean isNonHypotenuse ( int n ) { while ( n % 2 == 0 ) { n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { if ( ( i - 1 ) % 4 == 0 ) return false ; while ( n % i == 0 ) { n = n / i ; } } } if ( n > 2 && ( n - 1 ) % 4 == 0 ) return false ; else return true ; } public static void test ( int n ) { System . out . println ( " Testing ▁ for ▁ " + n + " ▁ : ▁ " ) ; if ( isNonHypotenuse ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static void main ( String args [ ] ) { int n = 11 ; test ( n ) ; n = 10 ; test ( n ) ; } }
import java . io . * ; import java . util . * ; class Gfg { static String obtain_str ( int n ) { int len = ( int ) Math . floor ( ( Math . log ( n + 1 ) / Math . log ( 2 ) ) ) ; int rel_ind = n + 1 - ( int ) Math . pow ( 2 , len ) ; int i = 0 ; StringBuilder str = new StringBuilder ( ) ; for ( i = 0 ; i < len ; i ++ ) { str . append ( ' a ' ) ; } i = 0 ; while ( rel_ind > 0 ) { if ( rel_ind % 2 == 1 ) str . setCharAt ( i , ' b ' ) ; rel_ind /= 2 ; i ++ ; } str = str . reverse ( ) ; return str . toString ( ) ; } public static void main ( String args [ ] ) { int n = 11 ; System . out . print ( obtain_str ( n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static void NthTerm ( int n ) { int numerator = ( ( int ) Math . pow ( n , 2 ) ) - 1 ; int denomeanator = 2 * n - 3 ; System . out . println ( numerator + " / " + denomeanator ) ; } public static void main ( String [ ] args ) { int n = 3 ; NthTerm ( n ) ; } }
public class GFG { public static int getSum ( int arr [ ] , int p ) { return arr . length ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 8 } ; int p = 7 ; System . out . print ( getSum ( arr , p ) ) ; } }
public class GFG { static int SquareCube ( long N ) { int cnt = 0 , i = 1 ; while ( ( int ) ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; } public static void main ( String [ ] args ) { long N = 100000 ; System . out . println ( SquareCube ( N ) ) ; } }
class Solution { static long getSum ( int n , int d ) { long sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; } public static void main ( String args [ ] ) { int n = 30 , d = 3 ; System . out . print ( getSum ( n , d ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static int MOD = 1000000007 ; static long sum ( long N ) { long val = N * ( N + 1 ) ; val = val % MOD ; return val ; } static int sumX ( int N , int M , int K ) { for ( int i = 0 ; i < M ; i ++ ) { N = ( int ) sum ( K + N ) ; } N = N % MOD ; return N ; } public static void main ( String args [ ] ) { int N = 1 , M = 2 , K = 3 ; System . out . println ( sumX ( N , M , K ) ) ; } }
class Gfg1 { static int Log2n ( int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; } public static void main ( String args [ ] ) { int n = 32 ; System . out . println ( Log2n ( n ) ) ; } }
import java . util . * ; class GFG { static boolean checkIsHP ( double [ ] arr ) { int n = arr . length ; if ( n == 1 ) return true ; ArrayList < Integer > rec = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) rec . add ( ( int ) ( 1 / arr [ i ] ) ) ; Collections . sort ( rec ) ; int d = ( int ) rec . get ( 1 ) - ( int ) rec . get ( 0 ) ; for ( int i = 2 ; i < n ; i ++ ) if ( rec . get ( i ) - rec . get ( i - 1 ) != d ) return false ; return true ; } public static void main ( String [ ] args ) { double arr [ ] = { 1 / 5 , 1 / 10 , 1 / 15 , 1 / 20 , 1 / 25 } ; if ( checkIsHP ( arr ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( ( A + i * d ) + " ▁ " ) ; } public static void main ( String args [ ] ) { int A = 20 , B = 32 , N = 5 ; printAMeans ( A , B , N ) ; } }
import java . io . * ; import java . lang . Math ; class GFG { public static void primeFactors ( int n ) { while ( n % 2 == 0 ) { System . out . print ( 2 + " ▁ " ) ; n /= 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { System . out . print ( i + " ▁ " ) ; n /= i ; } } if ( n > 2 ) System . out . print ( n ) ; } public static void main ( String [ ] args ) { int n = 315 ; primeFactors ( n ) ; } }
public class GFG { static int startingPoint ( int Length , int Speed1 , int Speed2 ) { int result1 = 0 , result2 = 0 ; int time1 = Length / Speed1 ; int time2 = Length / Speed2 ; result1 = __gcd ( time1 , time2 ) ; result2 = time1 * time2 / ( result1 ) ; return result2 ; } static int __gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return __gcd ( b , a % b ) ; } static float firstTime ( int Length , int Speed1 , int Speed2 ) { float result = 0 ; int relativeSpeed = Math . abs ( Speed1 - Speed2 ) ; result = ( ( float ) Length / relativeSpeed ) ; return result ; } public static void main ( String [ ] args ) { int L = 30 , S1 = 5 , S2 = 2 ; float first_Time = firstTime ( L , S1 , S2 ) ; int starting_Point = startingPoint ( L , S1 , S2 ) ; System . out . println ( " Met ▁ first ▁ time ▁ after ▁ " + first_Time + " ▁ hrs " ) ; System . out . println ( " Met ▁ at ▁ starting ▁ point ▁ after ▁ " + starting_Point + " ▁ hrs " ) ; } }
import java . io . * ; class GFG { static boolean CheckArray ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 12 , 3 , 2 } ; int n = arr . length ; if ( CheckArray ( arr , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; class GFG { static int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= Math . min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; } public static void main ( String [ ] args ) { int A = 10 , B = 15 ; System . out . print ( " Sum ▁ = ▁ " + sum ( A , B ) ) ; } }
import java . util . Arrays ; class GFG { static int findgcd ( int a , int b ) { if ( b == 0 ) return a ; return findgcd ( b , a % b ) ; } static int minimumCuts ( int a [ ] , int n ) { Arrays . sort ( a ) ; int gcd = a [ 1 ] - a [ 0 ] ; int s = gcd ; for ( int i = 2 ; i < n ; i ++ ) { gcd = findgcd ( gcd , a [ i ] - a [ i - 1 ] ) ; s += a [ i ] - a [ i - 1 ] ; } if ( 360 - s > 0 ) gcd = findgcd ( gcd , 360 - s ) ; return ( 360 / gcd ) - n ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 30 , 60 , 180 } ; int n = arr . length ; System . out . println ( minimumCuts ( arr , n ) ) ; } }
import java . util . * ; class solution { static float SellingPrice ( float CP , float PP ) { float P_decimal = 1 + ( PP / 100 ) ; float res = P_decimal * CP ; return res ; } public static void main ( String args [ ] ) { float C = 720 , P = 13 ; System . out . println ( SellingPrice ( C , P ) ) ; } }
import java . util . * ; class GFG { static int compositeProduct ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; boolean [ ] prime = new boolean [ max_val + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) { prime [ i ] = false ; } } } int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { product *= arr [ i ] ; } } return product ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; System . out . println ( compositeProduct ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int sum_odd ( int n ) { int sum = 0 , pos = 1 ; while ( n > 0 ) { if ( pos % 2 == 1 ) sum += n % 10 ; n = n / 10 ; pos ++ ; } return sum ; } static boolean check_prime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } public static void main ( String [ ] args ) { int n = 223 ; int sum = sum_odd ( n ) ; if ( check_prime ( sum ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public class GFG { static float findAmount ( float X , float W , float Y ) { return ( X * ( Y - W ) ) / ( 100 - Y ) ; } public static void main ( String args [ ] ) { float X = 100 , W = 50 , Y = 60 ; System . out . println ( " Water ▁ to ▁ be ▁ added ▁ = ▁ " + findAmount ( X , W , Y ) ) ; } }
class GFG { static int reverseNum ( int x ) { String s = Integer . toString ( x ) ; String str = " " ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { str = str + s . charAt ( i ) ; } int rev = Integer . parseInt ( str ) ; return rev ; } static boolean isMysteryNumber ( int n ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) { int j = reverseNum ( i ) ; if ( i + j == n ) { System . out . println ( i + " ▁ " + j ) ; return true ; } } System . out . println ( " Not ▁ a ▁ Mystery ▁ Number " ) ; return false ; } public static void main ( String [ ] args ) { int n = 121 ; isMysteryNumber ( n ) ; } }
class GFG { static void ReplaceElements ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) { prod *= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = prod / arr [ i ] ; } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 3 , 5 , 7 } ; int n = arr . length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( " " ) ; } }
class GFG { public boolean Check_is_possible ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return ( count > 1 ) ; } public static void main ( String [ ] args ) { GFG g = new GFG ( ) ; int l = 4 , r = 12 ; int k = 5 ; if ( g . Check_is_possible ( l , r , k ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; class GFG { public static int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; } public static void main ( String [ ] args ) { int N = 20 ; System . out . println ( sum ( N ) ) ; } }
import java . io . * ; class GFG { static int fastPow ( int N , int K ) { if ( K == 0 ) return 1 ; int temp = fastPow ( N , K / 2 ) ; if ( K % 2 == 0 ) return temp * temp ; else return N * temp * temp ; } static int countWays ( int N , int K ) { return K * fastPow ( K - 1 , N - 1 ) ; } public static void main ( String [ ] args ) { int N = 3 , K = 3 ; System . out . println ( countWays ( N , K ) ) ; } }
public class GFG { static int sumNth ( int A [ ] , int B [ ] , int m , int n ) { int res = 0 ; if ( n == 1 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + A [ i ] ; } else if ( n == 2 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + B [ i ] * m ; } else { int f [ ] = new int [ n ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; for ( int i = 0 ; i < m ; i ++ ) { res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ; } } return res ; } public static void main ( String args [ ] ) { int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 4 , 5 , 6 } ; int n = 3 ; int m = A . length ; System . out . println ( sumNth ( A , B , m , n ) ) ; } }
import java . util . * ; class solution { public static void main ( String arr [ ] ) { int a = 5 ; int AC = a ; int CE = 2 * a ; double shortestDistace = Math . sqrt ( AC * AC + CE * CE ) ; System . out . println ( shortestDistace ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . println ( sum_of_series ( n ) ) ; n = 10 ; System . out . println ( sum_of_series ( n ) ) ; } }
class GFG { static boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static boolean isThabitNumber ( int n ) { n = n + 1 ; if ( n % 3 == 0 ) n = n / 3 ; else return false ; if ( isPowerOfTwo ( n ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 47 ; if ( isThabitNumber ( n ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; import java . util . * ; class GFG { static int findMinEqualSums ( int [ ] a , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } int sum1 = 0 , sum2 = 0 ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( Math . abs ( sum1 - sum2 ) < min ) { min = Math . abs ( sum1 - sum2 ) ; } if ( min == 0 ) { break ; } } return min ; } public static void main ( String args [ ] ) { int [ ] a = { 3 , 2 , 1 , 5 , 7 , 8 } ; int N = a . length ; System . out . println ( findMinEqualSums ( a , N ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { public double CountDigits ( int n ) { if ( n == 1 ) return 1 ; double sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum += ( ( double ) Math . log ( i ) / ( double ) Math . log ( 10 ) ) ; } sum *= n ; return Math . ceil ( sum ) ; } public static void main ( String args [ ] ) { GFG g = new GFG ( ) ; int N = 5 ; System . out . println ( g . CountDigits ( N ) ) ; } }
import java . util . * ; class GFG { static final int MAX = 200006 ; static final int CONS = 32766 ; static void calc ( int a [ ] , int b [ ] , int lr [ ] , int q , int n ) { int M , m , i , j , k , l , r , suma , sumb , cc ; cc = 0 ; for ( i = 0 ; i < n - 1 ; ++ i ) { a [ i + 1 ] += a [ i ] ; b [ i + 1 ] += b [ i ] ; } while ( q != 0 ) { l = lr [ cc ++ ] ; r = lr [ cc ++ ] ; l -= 2 ; r -= 1 ; suma = a [ r ] ; sumb = b [ r ] ; if ( l >= 0 ) { suma -= a [ l ] ; sumb -= b [ l ] ; } M = Math . max ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) ; M = Math . max ( M , Math . max ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) ; m = Math . min ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) ; m = Math . min ( m , Math . min ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) ; System . out . println ( ( M - m ) ) ; q -- ; } } public static void main ( String [ ] args ) { int n = 5 , q = 2 ; int [ ] a = { 0 , 7 , 3 , 4 , 5 } ; int [ ] b = { 0 , 3 , 1 , 2 , 3 } ; int [ ] lr = new int [ q * 2 ] ; lr [ 0 ] = 1 ; lr [ 1 ] = 1 ; lr [ 2 ] = 1 ; lr [ 3 ] = 3 ; calc ( a , b , lr , q , n ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static long NthTerm ( long n ) { long x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; } public static void main ( String args [ ] ) { long N = 4 ; System . out . println ( NthTerm ( N ) ) ; } }
import java . io . * ; class GFG { static int power [ ] = new int [ 31 ] ; static int pre [ ] = new int [ 31 ] ; static void PowerOfTwo ( ) { int x = 1 ; for ( int i = 0 ; i < 31 ; i ++ ) { power [ i ] = x ; x *= 2 ; } pre [ 0 ] = 1 ; for ( int i = 1 ; i < 31 ; i ++ ) pre [ i ] = pre [ i - 1 ] + power [ i ] ; } static int Sum ( int n ) { int ans = n * ( n + 1 ) / 2 ; for ( int i = 0 ; i < 31 ; i ++ ) { if ( power [ i ] > n ) { ans -= 2 * pre [ i - 1 ] ; break ; } } return ans ; } public static void main ( String [ ] args ) { PowerOfTwo ( ) ; int n = 4 ; System . out . println ( Sum ( n ) ) ; } }
class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 17 ; if ( isPrime ( n ) && ( n % 16 == 1 ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
class GFG { static int findNumber ( int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int [ ] count = new int [ 10 ] ; int x = i ; int count1 = 0 , count2 = 0 ; while ( x > 0 ) { count [ x % 10 ] ++ ; x /= 10 ; count1 ++ ; } for ( int j = 0 ; j < 10 ; j ++ ) { if ( count [ j ] == 1 ) count2 ++ ; } if ( count1 == count2 ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { int n = 8490 ; System . out . println ( findNumber ( n ) ) ; } }
class GFG { static void SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } } static void findPrimePair ( int n ) { int flag = 0 ; boolean [ ] isPrime = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( isPrime [ i ] && isPrime [ x ] && x != i && x * i == n ) { System . out . println ( i + " ▁ " + x ) ; flag = 1 ; return ; } } if ( flag == 0 ) System . out . println ( " No ▁ such ▁ pair ▁ found " ) ; } public static void main ( String [ ] args ) { int n = 39 ; findPrimePair ( n ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static void solveProportion ( int a , int b1 , int b2 , int c ) { int A = a * b2 ; int B = b1 * b2 ; int C = b1 * c ; int gcd = __gcd ( __gcd ( A , B ) , C ) ; System . out . print ( A / gcd + " : " + B / gcd + " : " + C / gcd ) ; } public static void main ( String args [ ] ) { int a , b1 , b2 , c ; a = 3 ; b1 = 4 ; b2 = 8 ; c = 9 ; solveProportion ( a , b1 , b2 , c ) ; } }
import java . io . * ; class GFG { static int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 12 , k = 3 ; System . out . println ( countDivisors ( n , k ) ) ; } }
class GFG { static float pi = 3.14159f ; public static float volume ( float r , float h ) { return ( float ) 1 / 3 * pi * h * r * r ; } public static float surface_area ( float r , float s ) { return pi * r * s + pi * r * r ; } public static void main ( String args [ ] ) { float radius = 5 ; float slant_height = 13 ; float height = 12 ; float vol , sur_area ; System . out . print ( " Volume ▁ Of ▁ Cone ▁ : ▁ " ) ; System . out . println ( volume ( radius , height ) ) ; System . out . print ( " Surface ▁ Area ▁ Of ▁ Cone ▁ : ▁ " ) ; System . out . println ( surface_area ( radius , slant_height ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 6 * ( int ) Math . pow ( n , 2 ) - 4 * n - 2 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 2 * n + 2 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int sum ( int n ) { int ans = ( n * ( n - 1 ) ) / 2 ; return ans ; } public static void main ( String arr [ ] ) { int n = 5 ; System . out . println ( sum ( n ) ) ; } }
import java . util . * ; class solution { static long getNthTerm ( long N ) { return 4 * ( long ) Math . pow ( N , 2 ) - 3 * N + 2 ; } public static void main ( String arr [ ] ) { long N = 10 ; System . out . println ( getNthTerm ( N ) ) ; } }
public class GFG { static long MOD = 1000000007 ; static long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long sumProd ( long n , long t ) { long dino = power ( t + 1 , MOD - 2 , MOD ) ; long ans = 1 ; for ( long i = n + t + 1 ; i > n ; -- i ) ans = ( ans % MOD * i % MOD ) % MOD ; long tfact = 1 ; for ( int i = 1 ; i <= t ; ++ i ) tfact = ( tfact * i ) % MOD ; ans = ans * dino - tfact + MOD ; return ans % MOD ; } public static void main ( String [ ] args ) { long n = 3 , t = 2 ; System . out . println ( sumProd ( n , t ) ) ; } }
import java . util . * ; class GFG { static int calculateSum ( int n ) { return ( n * ( ( int ) Math . pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ; } public static void main ( String arr [ ] ) { int n = 25 ; System . out . println ( calculateSum ( n ) ) ; } }
public class TYU { static long mod = 1000000007 ; static long power ( long a , long b ) { long res = 1 ; while ( b != 0 ) { if ( ( b & 1 ) != 0 ) { res *= a ; res %= mod ; } b /= 2 ; a *= a ; a %= mod ; } return res ; } static long minPlayer ( long n , long k ) { long num = ( ( power ( k , n ) - 1 ) + mod ) % mod ; long den = ( power ( k - 1 , mod - 2 ) + mod ) % mod ; long ans = ( ( ( num * den ) % mod ) * k ) % mod ; return ans ; } public static void main ( String [ ] args ) { long n = 3 , k = 3 ; System . out . println ( minPlayer ( n , k ) ) ; } }
public class GFG { static void sieveOfEratosthenes ( int N , int s [ ] ) { boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) prime [ i ] = false ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } static int findSum ( int N ) { int [ ] s = new int [ N + 1 ] ; int ans = 1 ; sieveOfEratosthenes ( N , s ) ; int currFactor = s [ N ] ; int power = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( currFactor == s [ N ] ) { power ++ ; continue ; } int sum = 0 ; for ( int i = 0 ; i <= power ; i ++ ) sum += Math . pow ( currFactor , i ) ; ans *= sum ; currFactor = s [ N ] ; power = 1 ; } return ans ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . print ( " Sum ▁ of ▁ the ▁ factors ▁ is ▁ : ▁ " ) ; System . out . print ( findSum ( n ) ) ; } }
class GFG { static int count_setbits ( int N ) { int cnt = 0 ; while ( N > 0 ) { cnt += ( N & 1 ) ; N = N >> 1 ; } return cnt ; } static int countMultiples ( int n ) { int multiple [ ] = { 2 , 3 , 5 } ; int count = 0 , mask = ( int ) Math . pow ( 2 , 3 ) ; for ( int i = 1 ; i < mask ; i ++ ) { int prod = 1 ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( ( i & 1 << j ) > 0 ) prod = prod * multiple [ j ] ; } if ( count_setbits ( i ) % 2 == 1 ) count = count + n / prod ; else count = count - n / prod ; } return count ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( countMultiples ( n ) ) ; } }
import java . io . * ; class GFG { static int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; } public static void main ( String [ ] args ) { int k = 7 ; int res = findN ( k ) ; if ( res == - 1 ) System . out . println ( " Not ▁ possible " ) ; else System . out . println ( res ) ; } }
import java . io . * ; class GFG { static int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( Circular ( n - 1 ) ) ; } }
import java . io . * ; class GFG { static double calTime ( double arr [ ] , int n ) { double work = 0 ; for ( int i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; } public static void main ( String [ ] args ) { double arr [ ] = { 6.0 , 3.0 , 4.0 } ; int n = arr . length ; System . out . println ( calTime ( arr , n ) + " ▁ Hours " ) ; } }
import java . io . * ; class GFG { static void printTwins ( int low , int high ) { boolean prime [ ] = new boolean [ high + 1 ] ; boolean twin = false ; for ( int i = 0 ; i < high + 1 ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p <= Math . floor ( Math . sqrt ( high ) ) + 1 ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= high ; i += p ) prime [ i ] = false ; } } for ( int i = high ; i >= low ; i -- ) { if ( prime [ i ] && ( i - 2 >= low && prime [ i - 2 ] == true ) ) { System . out . println ( " Largest ▁ twins ▁ in ▁ given ▁ range : ▁ ( " + ( i - 2 ) + " , ▁ " + ( i ) + " ) " ) ; twin = true ; break ; } } if ( twin == false ) System . out . println ( " No ▁ such ▁ pair ▁ exists " ) ; } public static void main ( String [ ] args ) { printTwins ( 10 , 100 ) ; } }
class GFG { static int prevComplement ( int n , int b ) { int maxDigit , maxNum = 0 , digits = 0 , num = n ; while ( n != 0 ) { digits ++ ; n = n / 10 ; } maxDigit = b - 1 ; while ( ( digits -- ) > 0 ) { maxNum = maxNum * 10 + maxDigit ; } return maxNum - num ; } static int complement ( int n , int b ) { return prevComplement ( n , b ) + 1 ; } public static void main ( String args [ ] ) { System . out . println ( prevComplement ( 25 , 7 ) ) ; System . out . println ( complement ( 25 , 7 ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } public static void main ( String [ ] args ) { int a = 2 ; int b = 4 ; System . out . println ( gcd ( a , b ) ) ; } }
class GFG { static int MaximumDivisors ( int X , int Y ) { int [ ] arr = new int [ Y - X + 1 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) arr [ i ] = 0 ; int mx = 0 ; int cnt = 0 ; for ( int i = 1 ; i * i <= Y ; i ++ ) { int sq = i * i ; int first_divisible ; if ( ( X / i ) * i >= X ) first_divisible = ( X / i ) * i ; else first_divisible = ( X / i + 1 ) * i ; for ( int j = first_divisible ; j <= Y ; j += i ) { if ( j < sq ) continue ; else if ( j == sq ) arr [ j - X ] ++ ; else arr [ j - X ] += 2 ; } } for ( int i = X ; i <= Y ; i ++ ) { if ( arr [ i - X ] > mx ) { cnt = 1 ; mx = arr [ i - X ] ; } else if ( arr [ i - X ] == mx ) cnt ++ ; } return cnt ; } public static void main ( String [ ] args ) { int X = 1 , Y = 10 ; System . out . println ( MaximumDivisors ( X , Y ) ) ; } }
class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static int NearestElement ( int A , int D , int P ) { if ( A == 0 ) return 0 ; else if ( D == 0 ) return - 1 ; else { int X = power ( D , P - 2 , P ) ; return ( X * ( P - A ) ) % P ; } } public static void main ( String args [ ] ) { int A = 4 , D = 9 , P = 11 ; A %= P ; D %= P ; System . out . println ( NearestElement ( A , D , P ) ) ; } }
class GFG { static void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( true ) { flag = 1 ; x = ( int ) ( Math . pow ( 2 , i ) ) ; p1 = x * p0 + ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; System . out . print ( " ▁ " + p1 ) ; i ++ ; } } public static void main ( String args [ ] ) { int p0 = 2 ; print ( p0 ) ; } }
class solution_1 { static int findOddPair ( int A [ ] , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; } public static void main ( String args [ ] ) { int a [ ] = { 5 , 1 , 3 , 2 } ; int n = a . length ; System . out . println ( findOddPair ( a , n ) ) ; } }
import java . io . * ; class GFG { static long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( " Sum ▁ of ▁ all ▁ elements : " + calculateSum ( n ) ) ; } }
import java . io . * ; class GFG { static void Divide ( int a , int b ) { long dividend = ( long ) a ; long divisor = ( long ) b ; long sign = ( dividend < 0 ) ^ ( divisor < 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; if ( divisor == 0 ) { System . out . println ( " Cannot ▁ Divide ▁ by ▁ 0" ) ; return ; } if ( dividend == 0 ) { System . out . println ( a + " ▁ / ▁ " + b + " ▁ is ▁ equal ▁ to ▁ : ▁ " + 0 ) ; return ; } if ( divisor == 1 ) { System . out . println ( a + " ▁ / ▁ " + b + " ▁ is ▁ equal ▁ to ▁ : ▁ " + sign * dividend ) ; return ; } System . out . println ( a + " ▁ / ▁ " + b + " ▁ is ▁ equal ▁ to ▁ : ▁ " + Math . floor ( sign * ( Math . exp ( Math . log ( dividend ) - Math . log ( divisor ) ) ) ) ) ; } public static void main ( String [ ] args ) { int a = 10 , b = 5 ; Divide ( a , b ) ; a = 49 ; b = - 7 ; Divide ( a , b ) ; } }
class GFG { static boolean findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } } public static void main ( String [ ] args ) { int a = 2 , b = 4 ; int n = 3 ; if ( findNature ( a , b , n ) ) System . out . println ( " Odd " ) ; else System . out . println ( " Even " ) ; } }
import java . io . * ; class GFG { static String checkEqual ( String S ) { for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) != '1' && S . charAt ( i ) != '0' && S . charAt ( i ) != '8' ) { return " No " ; } } int start = 0 , end = S . length ( ) - 1 ; while ( start < end ) { if ( S . charAt ( start ) != S . charAt ( end ) ) { return " No " ; } start ++ ; end -- ; } return " Yes " ; } public static void main ( String [ ] args ) { String S = "101" ; System . out . println ( checkEqual ( S ) ) ; } }
class GFG { static int Log2n ( int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; } static boolean isPowerOfd ( int n , int d ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % ( Log2n ( d ) ) == 0 ) ; } return false ; } public static void main ( String [ ] args ) { int n = 64 , d = 8 ; if ( isPowerOfd ( n , d ) ) System . out . println ( n + " ▁ is ▁ a ▁ power ▁ of ▁ " + d ) ; else System . out . println ( n + " ▁ is ▁ not ▁ a ▁ power ▁ of ▁ " + d ) ; } }
import java . io . * ; class GFG { static int octahedral_num ( int n ) { return n * ( 2 * n * n + 1 ) / 3 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( n + " th ▁ Octahedral " + " ▁ number : ▁ " ) ; System . out . println ( octahedral_num ( n ) ) ; } }
import java . io . * ; class GFG { static int centeredTetrahedralNumber ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( centeredTetrahedralNumber ( n ) ) ; } }
class GFG { static void swap ( int a , int b , int c , int d ) { a = a + b ; b = a - b ; a = a - b ; b = b + c ; c = b - c ; b = b - c ; c = c + d ; d = c - d ; c = c - d ; System . out . println ( " values ▁ after ▁ " + " swapping ▁ are ▁ : ▁ " ) ; System . out . println ( " a ▁ = ▁ " + a ) ; System . out . println ( " b ▁ = ▁ " + b ) ; System . out . println ( " c ▁ = ▁ " + c ) ; System . out . println ( " d ▁ = ▁ " + d ) ; } public static void main ( String [ ] args ) { int a = 1 ; int b = 2 ; int c = 3 ; int d = 4 ; System . out . println ( " values ▁ before ▁ " + " swapping ▁ are ▁ : ▁ " ) ; System . out . println ( " a ▁ = ▁ " + a ) ; System . out . println ( " b ▁ = ▁ " + b ) ; System . out . println ( " c ▁ = ▁ " + c ) ; System . out . println ( " d ▁ = ▁ " + d ) ; System . out . println ( " " ) ; swap ( a , b , c , d ) ; } }
import java . io . * ; class GFG { static int seriesSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( seriesSum ( n ) ) ; } }
import java . io . * ; class GFG { static int N = 3 ; static boolean checkCentrosymmetricted ( int n , int m [ ] [ ] ) { int mid_row ; if ( ( n & 1 ) > 0 ) mid_row = n / 2 + 1 ; else mid_row = n / 2 ; for ( int i = 0 ; i < mid_row ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 3 ; int m [ ] [ ] = { { 1 , 3 , 5 } , { 6 , 8 , 6 } , { 5 , 3 , 1 } } ; if ( checkCentrosymmetricted ( n , m ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int Centered_Triangular_num ( int n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( Centered_Triangular_num ( n ) ) ; n = 12 ; System . out . println ( Centered_Triangular_num ( n ) ) ; } }
import java . io . * ; class GFG { static int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } static int k_Leaves ( int n , int k ) { int ans = ( binomialCoeff ( n , k ) * binomialCoeff ( n , k - 1 ) ) / n ; System . out . println ( " Number ▁ of ▁ trees ▁ " + " having ▁ 4 ▁ edges ▁ and ▁ exactly ▁ 2 ▁ " + " leaves ▁ : ▁ " + ans ) ; return 0 ; } static int numberOfNodes ( int n , int d ) { int ans = binomialCoeff ( 2 * n - 1 - d , n - 1 ) ; System . out . println ( " Number ▁ of ▁ nodes ▁ " + " of ▁ degree ▁ 1 ▁ in ▁ a ▁ tree ▁ having ▁ 4 ▁ " + " edges ▁ : ▁ " + ans ) ; return 0 ; } static int rootDegreeR ( int n , int r ) { int ans = r * binomialCoeff ( 2 * n - 1 - r , n - 1 ) ; ans = ans / n ; System . out . println ( " Number ▁ of ▁ trees ▁ " + " having ▁ 4 ▁ edges ▁ where ▁ root ▁ has " + " ▁ degree ▁ 2 ▁ : ▁ " + ans ) ; return 0 ; } public static void main ( String [ ] args ) { k_Leaves ( 3 , 2 ) ; numberOfNodes ( 3 , 1 ) ; rootDegreeR ( 3 , 2 ) ; } }
import java . util . * ; class GFG { public static int repUnitValue ( int n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; } public static void main ( String [ ] args ) { int n = 13 ; System . out . println ( repUnitValue ( n ) ) ; } }
class GFG { static int GCD ( int a , int b ) { return b == 0 ? a : GCD ( b , a % b ) ; } static boolean isSplittable ( int n , int m ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int sum_s1 = ( total_sum + m ) / 2 ; int sum_s2 = total_sum - sum_s1 ; if ( total_sum < m ) return false ; if ( sum_s1 + sum_s2 == total_sum && sum_s1 - sum_s2 == m ) return ( GCD ( sum_s1 , sum_s2 ) == 1 ) ; return false ; } public static void main ( String args [ ] ) { int n = 5 , m = 7 ; if ( isSplittable ( n , m ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static boolean isPossibleToZero ( int a [ ] , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 1 , 0 } ; int n = arr . length ; if ( isPossibleToZero ( arr , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; class GFG { public static boolean isBlumInteger ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] ) { if ( ( n % i == 0 ) && ( ( i - 3 ) % 4 ) == 0 ) { int q = n / i ; return ( q != i && prime [ q ] && ( q - 3 ) % 4 == 0 ) ; } } } return false ; } public static void main ( String [ ] args ) { int n = 249 ; if ( isBlumInteger ( n ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } public static void main ( String [ ] args ) { int n = 5 , r = 3 ; System . out . println ( nCr ( n , r ) ) ; } }
import java . io . * ; import java . math . * ; import java . text . * ; import java . util . * ; import java . util . regex . * ; class GFG { static int summingSeries ( long n ) { return ( int ) Math . pow ( n , 2 ) ; } public static void main ( String [ ] args ) { int n = 100 ; System . out . println ( " The ▁ sum ▁ of ▁ n ▁ term ▁ is : ▁ " + summingSeries ( n ) ) ; } }
class GFG { static void find_sum_of_two_squares ( int a , int b ) { int ab = a * b ; for ( int i = 0 ; i * i <= ab ; i ++ ) { for ( int j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) System . out . println ( i + " ^ 2 ▁ + ▁ " + j + " ^ 2 ▁ = ▁ " + ab ) ; } } } public static void main ( String [ ] args ) { int a = 1 * 1 + 2 * 2 ; int b = 3 * 3 + 4 * 4 ; System . out . println ( " Representation ▁ of ▁ a ▁ * ▁ b ▁ " + " as ▁ sum ▁ of ▁ 2 ▁ squares : " ) ; find_sum_of_two_squares ( a , b ) ; } }
class GFG { static int tetrahedralNumber ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( tetrahedralNumber ( n ) ) ; } }
import java . io . * ; class GFG { static void check_euler_four_square_identity ( int a , int b , int ab ) { int s = 0 ; for ( int i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( int j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( int k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( int l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { System . out . print ( " i ▁ = ▁ " + i + "NEW_LINE"); System . out . print ( " j ▁ = ▁ " + j + "NEW_LINE"); System . out . print ( " k ▁ = ▁ " + k + "NEW_LINE"); System . out . print ( " l ▁ = ▁ " + l + "NEW_LINE"); System . out . print ( " Product ▁ of ▁ " + a + " ▁ and ▁ " + b ) ; System . out . print ( " ▁ can ▁ be ▁ written " + " ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ " + "j, k, lNEW_LINE"); System . out . print ( ab + " ▁ = ▁ " ) ; System . out . print ( i + " * " + i + " ▁ + ▁ " ) ; System . out . print ( j + " * " + j + " ▁ + ▁ " ) ; System . out . print ( k + " * " + k + " ▁ + ▁ " ) ; System . out . print ( l + " * " + l + "NEW_LINE"); System . out . println ( ) ; } } } } } } public static void main ( String [ ] args ) { int ab = a * b ; check_euler_four_square_identity ( a , b , ab ) ; } }
import java . lang . * ; class GFG { public static int calculateDivisors ( int A , int B ) { int N = ( A - B ) ; int noOfDivisors = 0 ; for ( int i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( ( N % i ) == 0 ) { if ( i > B ) noOfDivisors ++ ; if ( ( N / i ) != i && ( N / i ) > B ) noOfDivisors ++ ; } } return noOfDivisors ; } public static int numberOfPossibleWaysUtil ( int A , int B ) { if ( A == B ) return - 1 ; if ( A < B ) return 0 ; int noOfDivisors = 0 ; noOfDivisors = calculateDivisors ( A , B ) ; return noOfDivisors ; } public static void numberOfPossibleWays ( int A , int B ) { int noOfSolutions = numberOfPossibleWaysUtil ( A , B ) ; if ( noOfSolutions == - 1 ) { System . out . print ( " For ▁ A ▁ = ▁ " + A + " ▁ and ▁ B ▁ = ▁ " + B + " , ▁ X ▁ can ▁ take ▁ Infinitely ▁ many ▁ values " + " ▁ greater ▁ than ▁ " + A + "NEW_LINE"); } else { System . out . print ( " For ▁ A ▁ = ▁ " + A + " ▁ and ▁ B ▁ = ▁ " + B + " , ▁ X ▁ can ▁ take ▁ " + noOfSolutions + " valuesNEW_LINE"); } } public static void main ( String [ ] args ) { int A = 26 , B = 2 ; numberOfPossibleWays ( A , B ) ; A = 21 ; B = 5 ; numberOfPossibleWays ( A , B ) ; } }
import java . io . * ; import java . util . * ; class GFG { static long powerNumbers ( int n ) { HashSet < Long > v = new HashSet < Long > ( ) ; for ( long i = 2 ; i * i * i <= n ; i ++ ) { long j = i * i ; while ( j * i <= n ) { j *= i ; long s = ( long ) Math . sqrt ( j ) ; if ( s * s != j ) v . add ( j ) ; } } return v . size ( ) + ( long ) Math . sqrt ( n ) ; } public static void main ( String args [ ] ) { System . out . print ( powerNumbers ( 50 ) ) ; } }
import java . io . * ; class GFG { static int mean ( int a [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ; return sum / ( n * n ) ; } static int variance ( int a [ ] [ ] , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] -= m ; a [ i ] [ j ] *= a [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ; return sum / ( n * n ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int m = mean ( mat , 3 ) ; int var = variance ( mat , 3 , m ) ; double dev = ( int ) Math . sqrt ( var ) ; System . out . println ( " Mean : ▁ " + m ) ; System . out . println ( " Variance : ▁ " + var ) ; System . out . println ( " Deviation : ▁ " + ( int ) dev ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( ( A + i * d ) + " ▁ " ) ; } public static void main ( String args [ ] ) { int A = 20 , B = 32 , N = 5 ; printAMeans ( A , B , N ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; } public static void main ( String [ ] args ) { System . out . println ( sumofseries ( 3 ) ) ; } }
import java . io . * ; class GFG { static boolean isValid ( long i , long m ) { long sq_i = ( long ) Math . sqrt ( i ) ; long sq = Math . min ( m , sq_i ) ; for ( long j = 2 ; j <= sq ; j ++ ) if ( i % j == 0 ) return false ; return true ; } static void findLargestNum ( long n , long m ) { for ( long i = n ; i > m ; i -- ) { if ( isValid ( i , m ) ) { System . out . println ( i ) ; return ; } } System . out . println ( " Number ▁ Doesn ' t ▁ Exists " ) ; } public static void main ( String [ ] args ) { long n = 16 , m = 3 ; findLargestNum ( n , m ) ; } }
import java . io . * ; class GFG { static boolean isOrthogonal ( int [ ] [ ] a , int m , int n ) { if ( m != n ) return false ; int [ ] [ ] trans = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) trans [ i ] [ j ] = a [ j ] [ i ] ; int [ ] [ ] prod = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) ; } prod [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && prod [ i ] [ j ] != 0 ) return false ; if ( i == j && prod [ i ] [ j ] != 1 ) return false ; } } return true ; } static public void main ( String [ ] args ) { int [ ] [ ] a = { { 1 , 0 , 0 } , { 0 , 1 , 0 } , { 0 , 0 , 1 } } ; if ( isOrthogonal ( a , 3 , 3 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static boolean isPerfectSquare ( int x ) { if ( x >= 0 ) { int sr = ( int ) Math . sqrt ( x ) ; return ( ( sr * sr ) == x ) ; } return false ; } public static void main ( String [ ] args ) { int x = 2502 ; if ( isPerfectSquare ( x ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * ( int ) Math . pow ( r , i ) ; System . out . print ( curr_term + " ▁ " ) ; } } public static void main ( String [ ] args ) { int a = 2 ; int r = 3 ; int n = 5 ; printGP ( a , r , n ) ; } }
class GFG { static int getMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 2 ) ; } static void multiply ( int F [ ] [ ] , int M [ ] [ ] ) { int x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; int y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; int z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; int w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; } static void power ( int F [ ] [ ] , int n ) { if ( n == 0 n == 1 ) return ; int [ ] [ ] M = { { 1 , 1 } , { 1 , 0 } } ; for ( int m = getMSB ( n ) ; m > 0 ; m = m >> 1 ) { multiply ( F , F ) ; if ( ( n & m ) > 0 ) { multiply ( F , M ) ; } } } static int fib ( int n ) { int [ ] [ ] F = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n - 1 ) ; return F [ 0 ] [ 0 ] ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( fib ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void SternSequenceFunc ( Vector < Integer > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence . get ( i ) ; int precedent = BrocotSequence . get ( i - 1 ) ; BrocotSequence . add ( considered_element + precedent ) ; BrocotSequence . add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) System . out . print ( BrocotSequence . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 15 ; Vector < Integer > BrocotSequence = new Vector < Integer > ( ) ; BrocotSequence . add ( 1 ) ; BrocotSequence . add ( 1 ) ; SternSequenceFunc ( BrocotSequence , n ) ; } }
import java . io . * ; import java . math . * ; class GFG { static boolean isRevDiffDivisible ( int x , int k ) { int n = x ; int m = 0 ; int flag ; while ( x > 0 ) { m = m * 10 + x % 10 ; x /= 10 ; } return ( Math . abs ( n - m ) % k == 0 ) ; } static int countNumbers ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) if ( isRevDiffDivisible ( i , k ) ) ++ count ; return count ; } public static void main ( String args [ ] ) { int l = 35 , r = 45 , k = 5 ; System . out . println ( countNumbers ( l , r , k ) ) ; } }
import java . io . * ; class GFG { static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + 1 ) ; } static boolean areAmicable ( int x , int y ) { if ( divSum ( x ) != y ) return false ; return ( divSum ( y ) == x ) ; } public static void main ( String [ ] args ) { int x = 220 , y = 284 ; if ( areAmicable ( x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; import java . math . * ; class GFG { static boolean isPerfectSquare ( int n ) { if ( n < 0 ) return false ; int root = Math . round ( ( int ) ( Math . sqrt ( n ) ) ) ; return n == root * root ; } static void printnonsquare ( int n ) { int count = 0 ; for ( int i = 1 ; count < n ; ++ i ) { if ( ! isPerfectSquare ( i ) ) { System . out . print ( i + " ▁ " ) ; count ++ ; } } } public static void main ( String args [ ] ) { int n = 10 ; printnonsquare ( n ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int nonsquare ( int n ) { return n + ( int ) ( 0.5 + ( Math . sqrt ( n ) ) ) ; } static void printNonSquare ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( nonsquare ( i ) + " ▁ " ) ; } public static void main ( String args [ ] ) { int n = 10 ; printNonSquare ( n ) ; } }
import java . io . * ; import java . util . * ; class Fraction { int num , den ; Fraction ( int n , int d ) { num = n ; den = d ; } static Fraction maxFraction ( Fraction first , Fraction sec ) { int a = first . num ; int b = first . den ; int c = sec . num ; int d = sec . den ; int Y = a * d - b * c ; return ( Y > 0 ) ? first : sec ; } public static void main ( String [ ] args ) { Fraction first = new Fraction ( 3 , 2 ) ; Fraction sec = new Fraction ( 3 , 4 ) ; Fraction res = maxFraction ( first , sec ) ; System . out . println ( res . num + " / " + res . den ) ; } }
import java . io . * ; class GFG { static Boolean isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; } public static void main ( String [ ] args ) { int N = 12 ; if ( isPentagonal ( N ) ) System . out . println ( N + " ▁ is ▁ pentagonal ▁ " ) ; else System . out . println ( N + " ▁ is ▁ not ▁ pentagonal " ) ; } }
import java . io . * ; import java . util . * ; class GFG { static long fourthPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( fourthPowerSum ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static long fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( fourthPowerSum ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( Math . pow ( x , y ) ) ) % 10 ) ; } public static void main ( String [ ] args ) { int x = 133 , y = 5 ; System . out . println ( unitnumber ( x , y ) ) ; } }
import java . io . * ; class GFG { static int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; } public static void main ( String args [ ] ) throws IOException { int n = 12 ; System . out . println ( aliquotSum ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static String complexNumberMultiply ( String a , String b ) { String x [ ] = a . split ( " \\ + ▁ i " ) ; String y [ ] = b . split ( " \\ + ▁ i " ) ; int a_real = Integer . parseInt ( x [ 0 ] ) ; int a_img = Integer . parseInt ( x [ 1 ] ) ; int b_real = Integer . parseInt ( y [ 0 ] ) ; int b_img = Integer . parseInt ( y [ 1 ] ) ; return ( a_real * b_real - a_img * b_img ) + " + " + ( a_real * b_img + a_img * b_real ) + " i " ; } public static void main ( String argc [ ] ) { String str1 = "1 + 1i " ; String str2 = "1 + 1i " ; System . out . println ( complexNumberMultiply ( str1 , str2 ) ) ; } }
import java . io . * ; public class GFG { static float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } static public void main ( String [ ] args ) { int n = 2 ; System . out . println ( AvgofSquareN ( n ) ) ; } }
import java . util . * ; class GFG { static float func ( float x ) { return ( 1 / ( 1 + x * x ) ) ; } static float calculate ( float lower_limit , float upper_limit , int interval_limit ) { float value ; float interval_size = ( upper_limit - lower_limit ) / interval_limit ; float sum = func ( lower_limit ) + func ( upper_limit ) ; for ( int i = 1 ; i < interval_limit ; i ++ ) { if ( i % 3 == 0 ) sum = sum + 2 * func ( lower_limit + i * interval_size ) ; else sum = sum + 3 * func ( lower_limit + i * interval_size ) ; } return ( 3 * interval_size / 8 ) * sum ; } public static void main ( String [ ] args ) { int interval_limit = 10 ; float lower_limit = 1 ; float upper_limit = 10 ; float integral_res = calculate ( lower_limit , upper_limit , interval_limit ) ; System . out . println ( integral_res ) ; } }
import java . io . * ; class GFG { static float focal_length ( float image_distance , float object_distance ) { return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) ; } public static void main ( String [ ] args ) { float image_distance = 2 ; float object_distance = 50 ; System . out . println ( " Focal ▁ length ▁ of ▁ a ▁ lens ▁ is ▁ " + focal_length ( image_distance , object_distance ) + " ▁ units . " ) ; } }
import java . io . * ; class GFG { static boolean check ( int n ) { int m = n ; while ( n != 0 ) { int r = n % 10 ; if ( r > 0 ) if ( ( m % r ) != 0 ) return false ; n /= 10 ; } return true ; } static int count ( int l , int r ) { int ans = 0 ; for ( int i = l ; i <= r ; i ++ ) if ( check ( i ) ) ans += 1 ; return ans ; } public static void main ( String args [ ] ) { int l = 10 , r = 20 ; System . out . println ( count ( 10 , 20 ) ) ; } }
class demo { public static double sumOfTheSeries ( int n ) { double sum = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( sumOfTheSeries ( n ) ) ; } }
import java . util . * ; class GFG { static long sum ( long n ) { long root = ( long ) Math . sqrt ( n ) ; long ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; } public static void main ( String [ ] args ) { long n = 35 ; System . out . println ( sum ( n ) ) ; } }
class GFG { static int sumOfTheSeries ( int n ) { int sum_n = ( n * ( n + 1 ) / 2 ) ; int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . printf ( " Sum ▁ = ▁ % d " , sumOfTheSeries ( n ) ) ; } }
import static java . lang . Math . * ; class GFG { static int sumofsquare ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( sumofsquare ( n ) ) ; } }
public class GfG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; } public static void main ( String s [ ] ) { int n = 10 ; System . out . println ( sumOfSeries ( n ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int evenSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( evenSum ( n ) ) ; } }
import java . util . * ; class GFG { static void triangular_series ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . printf ( " % d ▁ " ; , i * ( i + 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; triangular_series ( n ) ; } }
import java . util . * ; class GFG { static void checksum ( int n ) { if ( n % 3 == 0 ) System . out . println ( n / 3 - 1 + " ▁ " + n / 3 + " ▁ " + ( n / 3 + 1 ) ) ; else System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { int n = 6 ; checksum ( n ) ; } }
import java . io . * ; class GFG { static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( divisorSum ( n ) ) ; n = 5 ; System . out . println ( divisorSum ( n ) ) ; } }
import java . io . * ; class GFG { static double polite ( double n ) { n += 1 ; double base = 2 ; return n + ( Math . log ( ( n + ( Math . log ( n ) / Math . log ( base ) ) ) ) ) / Math . log ( base ) ; } public static void main ( String [ ] args ) { double n = 7 ; System . out . println ( ( int ) polite ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; } public static void main ( String argc [ ] ) { int T = 15 ; int ans = solve ( 1 , T , 2 * T ) ; if ( ans != - 1 ) ans -- ; System . out . println ( " Number ▁ of ▁ stair ▁ steps ▁ = ▁ " + ans ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { static Boolean isOverflow ( long a , long b ) { if ( a == 0 b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; } public static void main ( String argc [ ] ) { long a = Long . parseLong ( "10000000000" ) ; long b = Long . parseLong ( " - 10000000000" ) ; if ( isOverflow ( a , b ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; class Odd { public static int oddSum ( int n ) { int sum = 0 , curr = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( " ▁ Sum ▁ of ▁ first ▁ " + n + " ▁ Odd ▁ Numbers ▁ is : ▁ " + oddSum ( n ) ) ; } }
import java . util . * ; class Odd { public static int oddSum ( int n ) { return ( n * n ) ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( " ▁ Sum ▁ of ▁ first ▁ " + n + " ▁ Odd ▁ Numbers ▁ is : ▁ " + oddSum ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void printKPFNums ( int A , int B , int K ) { int p_factors [ ] = new int [ B + 1 ] ; Arrays . fill ( p_factors , 0 ) ; for ( int p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( int i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( int i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) System . out . print ( i + " ▁ " ) ; } public static void main ( String args [ ] ) { int A = 14 , B = 18 , K = 2 ; printKPFNums ( A , B , K ) ; } }
public class GFG { final static int MAX = 100005 ; static void precompute ( int prefix [ ] , int suffix [ ] ) { boolean prime [ ] = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { prime [ i ] = true ; } for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j < MAX ; j += i ) { prime [ j ] = false ; } } } prefix [ 1 ] = 1 ; suffix [ MAX - 1 ] = ( int ) 1e9 + 7 ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) { prefix [ i ] = i ; } else { prefix [ i ] = prefix [ i - 1 ] ; } } for ( int i = MAX - 2 ; i > 1 ; i -- ) { if ( prime [ i ] ) { suffix [ i ] = i ; } else { suffix [ i ] = suffix [ i + 1 ] ; } } } static int query ( int prefix [ ] , int suffix [ ] , int L , int R ) { if ( prefix [ R ] < L suffix [ L ] > R ) { return 0 ; } else { return prefix [ R ] - suffix [ L ] ; } } public static void main ( String [ ] args ) { int q = 3 ; int L [ ] = { 2 , 2 , 24 } ; int R [ ] = { 5 , 2 , 28 } ; int prefix [ ] = new int [ MAX ] , suffix [ ] = new int [ MAX ] ; precompute ( prefix , suffix ) ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( query ( prefix , suffix , L [ i ] , R [ i ] ) ) ; } } }
import static java . lang . Math . pow ; class GFG { static double sum ( int x , int n ) { double i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) total = total + ( Math . pow ( x , i ) / i ) ; return total ; } public static void main ( String [ ] args ) { int x = 2 ; int n = 5 ; System . out . printf ( " % .2f " , sum ( x , n ) ) ; } }
class GFG { static boolean isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; } public static void main ( String args [ ] ) { int a = 1 , x = 7 , d = 3 ; if ( isMember ( a , d , x ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static boolean sumSquare ( int n ) { for ( long i = 1 ; i * i <= n ; i ++ ) for ( long j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { System . out . println ( i + " ^ 2 ▁ + ▁ " + j + " ^ 2" ) ; return true ; } return false ; } public static void main ( String args [ ] ) { int n = 25 ; if ( sumSquare ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static boolean check ( long a , long b ) { long c = 0 ; while ( a != 0 ) { c = c + a % 10 ; a = a / 10 ; } return ( c == b ) ; } static long root ( long n ) { boolean found = false ; long mx = ( long ) 1E18 ; for ( long i = 0 ; i <= 90 ; i ++ ) { long s = i * i + 4 * n ; long sq = ( long ) Math . sqrt ( s ) ; if ( sq * sq == s && check ( ( sq - i ) / 2 , i ) ) { found = true ; mx = Math . min ( mx , ( sq - i ) / 2 ) ; } } if ( found ) return mx ; else return - 1 ; } public static void main ( String [ ] args ) { long n = 110 ; System . out . println ( root ( n ) ) ; } }
public class base_power { static int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) Math . pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; } public static void main ( String [ ] args ) { int n = 5 ; int power = 4 ; System . out . println ( calculate ( n , power ) ) ; } }
class GFG { static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static boolean coprime ( int a , int b ) { return ( __gcd ( a , b ) == 1 ) ; } static void pairSum ( int n ) { int mid = n / 2 ; for ( int i = mid ; i >= 1 ; i -- ) { if ( coprime ( i , n - i ) == true ) { System . out . print ( i + " ▁ " + ( n - i ) ) ; break ; } } } public static void main ( String args [ ] ) { int n = 11 ; pairSum ( n ) ; } }
import java . util . Vector ; class GFG { static void modBigNumber ( String num , long m ) { Vector < Integer > vec = new Vector < > ( ) ; long mod = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { int digit = num . charAt ( i ) - '0' ; mod = mod * 10 + digit ; int quo = ( int ) ( mod / m ) ; vec . add ( vec . size ( ) , quo ) ; mod = mod % m ; } System . out . print ( " Remainder : " ▁ + ▁ mod ▁ + ▁ " "); System . out . print ( " Quotient ▁ : ▁ " ) ; boolean zeroflag = false ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { if ( vec . get ( i ) == 0 && zeroflag == false ) { continue ; } zeroflag = true ; System . out . print ( vec . get ( i ) ) ; } return ; } public static void main ( String [ ] args ) { String num = "14598499948265358486" ; long m = 487 ; modBigNumber ( num , m ) ; } }
import java . util . * ; class GFG { static int N = ( int ) 1E6 ; static boolean [ ] fourDiv = new boolean [ N + 1 ] ; static void fourDistinctFactors ( ) { boolean [ ] primeAll = new boolean [ N + 1 ] ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( primeAll [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) primeAll [ i ] = true ; } } ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; for ( int p = 2 ; p <= N ; p ++ ) if ( ! primeAll [ p ] ) prime . add ( p ) ; for ( int i = 0 ; i < prime . size ( ) ; ++ i ) { int p = prime . get ( i ) ; if ( 1L * p * p * p <= N ) fourDiv [ p * p * p ] = true ; for ( int j = i + 1 ; j < prime . size ( ) ; ++ j ) { int q = prime . get ( j ) ; if ( 1L * p * q > N ) break ; fourDiv [ p * q ] = true ; } } } public static void main ( String [ ] args ) { fourDistinctFactors ( ) ; int num = 10 ; if ( fourDiv [ num ] ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; num = 12 ; if ( fourDiv [ num ] ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int leonardo ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ; return dp [ n ] ; } public static void main ( String [ ] args ) { System . out . println ( leonardo ( 3 ) ) ; } }
class GFG { static void Cholesky_Decomposition ( int [ ] [ ] matrix , int n ) { int [ ] [ ] lower = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { int sum = 0 ; if ( j == i ) { for ( int k = 0 ; k < j ; k ++ ) sum += ( int ) Math . pow ( lower [ j ] [ k ] , 2 ) ; lower [ j ] [ j ] = ( int ) Math . sqrt ( matrix [ j ] [ j ] - sum ) ; } else { for ( int k = 0 ; k < j ; k ++ ) sum += ( lower [ i ] [ k ] * lower [ j ] [ k ] ) ; lower [ i ] [ j ] = ( matrix [ i ] [ j ] - sum ) / lower [ j ] [ j ] ; } } } System . out . println ( " ▁ Lower ▁ Triangular TABSYMBOL ▁ Transpose " ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( lower [ i ] [ j ] + " TABSYMBOL " ) ; System . out . print ( " " ) ; for ( int j = 0 ; j < n ; j ++ ) System . out . print ( lower [ j ] [ i ] + " TABSYMBOL " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 3 ; int [ ] [ ] matrix = new int [ ] [ ] { { 4 , 12 , - 16 } , { 12 , 37 , - 43 } , { - 16 , - 43 , 98 } } ; Cholesky_Decomposition ( matrix , n ) ; } }
class GFG { static float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; } public static void main ( String [ ] args ) { float n = 20 ; float a = 2.5f , d = 1.5f ; System . out . print ( sumOfAP ( a , d , n ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static int sumOfSeries ( int n ) { int x ; if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) ; else x = ( ( n + 1 ) / 2 ) * n ; return x * x ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( sumOfSeries ( n ) ) ; } }
class GFG { static final int MAX = 10 ; static int findValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) ans = Math . max ( ans , Math . abs ( arr [ i ] - arr [ j ] ) + Math . abs ( i - j ) ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 1 } ; int n = arr . length ; System . out . println ( findValue ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int findValue ( int arr [ ] , int n ) { int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; int tmp ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( arr [ i ] + i ) ; b [ i ] = ( arr [ i ] - i ) ; } int x = a [ 0 ] , y = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) x = a [ i ] ; if ( a [ i ] < y ) y = a [ i ] ; } int ans1 = ( x - y ) ; x = b [ 0 ] ; y = b [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] > x ) x = b [ i ] ; if ( b [ i ] < y ) y = b [ i ] ; } int ans2 = ( x - y ) ; return Math . max ( ans1 , ans2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 1 } ; int n = arr . length ; System . out . println ( findValue ( arr , n ) ) ; } }
class GFG { static int countsubarray ( int array [ ] , int n , int k ) { int count = 0 ; int i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; } public static void main ( String args [ ] ) { int array [ ] = { 1 , 2 , 3 , 4 } ; int k = 10 ; int size = array . length ; int count = countsubarray ( array , size , k ) ; System . out . print ( count ) ; } }
import java . util . * ; class GFG { static int MAX = 1000001 ; static int factor [ ] ; static void generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } } static int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ; int dup = factor [ n ] ; int c = 1 ; int j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; } public static void main ( String [ ] args ) { factor = new int [ MAX ] ; factor [ 0 ] = 0 ; generatePrimeFactors ( ) ; int a [ ] = { 10 , 30 , 100 , 450 , 987 } ; int q = a . length ; for ( int i = 0 ; i < q ; i ++ ) System . out . print ( calculateNoOFactors ( a [ i ] ) + " ▁ " ) ; } }
import java . lang . * ; import java . io . * ; class GFG { public static void digit_product_Sum ( int N ) { int a [ ] = new int [ N + 1 ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int N = 10 ; digit_product_Sum ( N ) ; } }
import java . math . * ; class GFG { static float geometricMean ( int arr [ ] , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = ( float ) Math . pow ( product , ( float ) 1 / n ) ; return gm ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = arr . length ; System . out . println ( geometricMean ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int SIZE = 4 ; static boolean productOfSingelDgt ( int n ) { if ( n >= 0 && n <= 9 ) return true ; int [ ] prime = { 2 , 3 , 5 , 7 } ; for ( int i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; } public static void main ( String [ ] args ) { int n = 24 ; if ( productOfSingelDgt ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int findSum ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) ; else return ( ( n + 1 ) / 2 ) * n ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( findSum ( n ) ) ; } }
class GFG { static int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; boolean [ ] arr = new boolean [ N + 1 ] ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; } public static void main ( String [ ] args ) { int N = 500 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }
import java . io . * ; class table { public static void main ( String arg [ ] ) { int n = 8 ; int range = 12 ; for ( int i = 1 ; i <= range ; ++ i ) System . out . println ( n + " ▁ * ▁ " + i + " ▁ = ▁ " + n * i ) ; } }
public class GFG { static boolean isPalindrome ( int n ) { bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } public static void main ( String args [ ] ) { if ( isPalindrome ( 1001 ) ) System . out . println ( " Yes , ▁ it ▁ is ▁ Palindrome " ) ; else System . out . println ( " No , ▁ not ▁ Palindrome " ) ; } }
public class Power_3 { static boolean check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; } public static void main ( String args [ ] ) { int n = 9 ; if ( check ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class Main { static String printDemlo ( String str ) { int len = str . length ( ) ; String res = " " ; for ( int i = 1 ; i <= len ; i ++ ) res += Integer . toString ( i ) ; for ( int i = len - 1 ; i >= 1 ; i -- ) res += Integer . toString ( i ) ; return res ; } public static void main ( String [ ] args ) { String str = "111111" ; System . out . println ( printDemlo ( str ) ) ; } }
public class GFG { static int NumberofTimes ( String str ) { int temporary_sum = 0 , count = 0 ; while ( str . length ( ) > 1 ) { temporary_sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) temporary_sum += ( str . charAt ( i ) - '0' ) ; str = temporary_sum + " " ; count ++ ; } return count ; } public static void main ( String [ ] args ) { String s = "991" ; System . out . println ( NumberofTimes ( s ) ) ; } }
class GFG { static int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } } public static void main ( String [ ] args ) { System . out . println ( calculateLeaps ( 4 ) ) ; } }
public class GFG { static int power ( long x , long y , long p ) { long res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return ( int ) res ; } static void printLastKDigits ( int a , int b , int k ) { System . out . print ( " Last ▁ " + k + " ▁ digits ▁ of ▁ " + a + " ^ " + b + " ▁ = ▁ " ) ; int temp = 1 ; for ( int i = 1 ; i <= k ; i ++ ) temp *= 10 ; temp = power ( a , b , temp ) ; for ( int i = 0 ; i < k - Integer . toString ( temp ) . length ( ) ; i ++ ) System . out . print ( 0 ) ; if ( temp != 0 ) System . out . print ( temp ) ; } public static void main ( String [ ] args ) { int a = 11 ; int b = 3 ; int k = 2 ; printLastKDigits ( a , b , k ) ; } }
public class Main { static int reverseDigits ( int num ) { int rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num /= 10 ; } return rev ; } static int square ( int num ) { return ( num * num ) ; } static boolean checkAdamNumber ( int num ) { int a = square ( num ) ; int b = square ( reverseDigits ( num ) ) ; if ( a == reverseDigits ( b ) ) return true ; return false ; } public static void main ( String [ ] args ) { int num = 12 ; if ( checkAdamNumber ( num ) ) System . out . println ( " Adam ▁ Number " ) ; else System . out . println ( " Not ▁ a ▁ Adam ▁ Number " ) ; } }
public class GFG { static int totalDigits ( int n ) { int number_of_digits = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; } public static void main ( String [ ] args ) { int n = 13 ; System . out . println ( totalDigits ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void numbersWith3Divisors ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } System . out . println ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : ▁ " ) ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) System . out . print ( i * i + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 96 ; numbersWith3Divisors ( n ) ; } }
import java . io . * ; class GFG { static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; } public static void main ( String [ ] args ) { int n = 2545 ; decToHexa ( n ) ; } }
import java . io . * ; class GFG { static void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNum [ j ] ) ; } public static void main ( String [ ] args ) { int n = 17 ; decToBinary ( n ) ; } }
import java . io . * ; class GFG { static long count_of_ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; } public static void main ( String [ ] args ) { long n = 3 ; System . out . println ( count_of_ways ( n ) ) ; } }
class GFG { static int flipSign ( int a ) { int neg = 0 ; int tmp = a < 0 ? 1 : - 1 ; while ( a != 0 ) { neg += tmp ; a += tmp ; } return neg ; } static boolean areDifferentSign ( int a , int b ) { return ( ( a < 0 && b > 0 ) || ( a > 0 && b < 0 ) ) ; } static int sub ( int a , int b ) { return a + flipSign ( b ) ; } static int mul ( int a , int b ) { if ( a < b ) return mul ( b , a ) ; int sum = 0 ; for ( int i = Math . abs ( b ) ; i > 0 ; i -- ) sum += a ; if ( b < 0 ) sum = flipSign ( sum ) ; return sum ; } static int division ( int a , int b ) { if ( b == 0 ) throw new ArithmeticException ( ) ; int quotient = 0 , dividend ; int divisor = flipSign ( Math . abs ( b ) ) ; for ( dividend = Math . abs ( a ) ; dividend >= Math . abs ( divisor ) ; dividend += divisor ) quotient ++ ; if ( areDifferentSign ( a , b ) ) quotient = flipSign ( quotient ) ; return quotient ; } public static void main ( String [ ] args ) { System . out . println ( " Subtraction ▁ is ▁ " + sub ( 4 , - 2 ) ) ; System . out . println ( " Product ▁ is ▁ " + mul ( - 9 , 6 ) ) ; try { System . out . println ( " Division ▁ is ▁ " + division ( 8 , 2 ) ) ; } catch ( ArithmeticException e ) { System . out . println ( " Exception ▁ : - ▁ Divide ▁ by ▁ 0" ) ; } } }
class GFG { static int numOfCombinations ( int arr [ ] , int N ) { int C [ ] = { 0 , 0 , 0 } ; for ( int i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 5 , 7 , 2 , 9 , 14 } ; System . out . print ( numOfCombinations ( arr1 , 6 ) + "NEW_LINE"); int arr2 [ ] = { 3 , 6 , 9 , 12 } ; System . out . print ( numOfCombinations ( arr2 , 4 ) + "NEW_LINE"); } }
public class Prime { static boolean isprime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; } static boolean isSumOfKprimes ( int N , int K ) { if ( N < 2 * K ) return false ; if ( K == 1 ) return isprime ( N ) ; if ( K == 2 ) { if ( N % 2 == 0 ) return true ; return isprime ( N - 2 ) ; } return true ; } public static void main ( String [ ] args ) { int n = 10 , k = 2 ; if ( isSumOfKprimes ( n , k ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . math . BigInteger ; class Test { static int FindLCM ( int a , int b ) { return ( a * b ) / new BigInteger ( a + " " ) . gcd ( new BigInteger ( b + " " ) ) . intValue ( ) ; } static int rangeDivisor ( int m , int n , int a , int b ) { int lcm = FindLCM ( a , b ) ; int a_divisor = n / a - ( m - 1 ) / a ; int b_divisor = n / b - ( m - 1 ) / b ; int common_divisor = n / lcm - ( m - 1 ) / lcm ; int ans = a_divisor + b_divisor - common_divisor ; return ans ; } public static void main ( String args [ ] ) { int m = 3 , n = 11 , a = 2 , b = 3 ; System . out . println ( rangeDivisor ( m , n , a , b ) ) ; m = 11 ; n = 1000000 ; a = 6 ; b = 35 ; System . out . println ( rangeDivisor ( m , n , a , b ) ) ; } }
class Test { static void printUnique ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { int num = i ; boolean visited [ ] = new boolean [ 10 ] ; while ( num != 0 ) { if ( visited [ num % 10 ] ) break ; visited [ num % 10 ] = true ; num = num / 10 ; } if ( num == 0 ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String args [ ] ) { int l = 1 , r = 20 ; printUnique ( l , r ) ; } }
import java . io . * ; class FibZero { static int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next > 0 ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; } public static void main ( String [ ] args ) { int p = 7 ; System . out . println ( " Minimal ▁ zero ▁ is ▁ " + findMinZero ( p ) ) ; } }
class Test { static void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { System . out . print ( j * j * j + " ▁ " ) ; break ; } } } } public static void main ( String [ ] args ) { int a = 1 , b = 100 ; System . out . println ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : " ) ; printCubes ( a , b ) ; } }
import java . lang . * ; import java . io . * ; import java . util . * ; class BinaryToString { static String printBinary ( double num ) { if ( num >= 1 num <= 0 ) return " ERROR " ; StringBuilder binary = new StringBuilder ( ) ; double frac = 0.5 ; binary . append ( " . " ) ; while ( num > 0 ) { if ( binary . length ( ) >= 32 ) return " ERROR " ; if ( num >= frac ) { binary . append ( 1 ) ; num -= frac ; } else binary . append ( 0 ) ; frac /= 2 ; } return binary . toString ( ) ; } public static void main ( String [ ] args ) { String output = printBinary ( num1 ) ; System . out . println ( " ( 0" + output + " ) ▁ in ▁ base ▁ 2" ) ; double num2 = 0.72 ; output = printBinary ( num2 ) ; System . out . println ( " ( " + output + " ) ▁ " ) ; } }
public class Digits { static long firstkdigits ( int n , int k ) { long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / Math . pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; } public static void main ( String [ ] args ) { int n = 15 ; int k = 4 ; System . out . println ( firstkdigits ( n , k ) ) ; } }
class IsDivisible { static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 9 == 0 ) ; } public static void main ( String [ ] args ) { String str = "99333" ; if ( check ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i ; j < N ; j ++ ) for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . length ; System . out . println ( getTotalXorOfSubarrayXors ( arr , N ) ) ; } }
import java . io . * ; public class GFG { static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . length ; System . out . println ( getTotalXorOfSubarrayXors ( arr , N ) ) ; } }
public class GCD { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findGCD ( int arr [ ] , int n ) { int result = 0 ; for ( int element : arr ) { result = gcd ( result , element ) ; if ( result == 1 ) { return 1 ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 16 } ; int n = arr . length ; System . out . println ( findGCD ( arr , n ) ) ; } }
public class Divisors { static int divSum ( int num ) { int result = 0 ; for ( int i = 1 ; i * i <= num ; ++ i ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return result ; } static boolean isSuperPerfect ( int n ) { int n1 = divSum ( n ) ; return ( 2 * n == divSum ( n1 ) ) ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . printf ( ( isSuperPerfect ( n ) ? "Yes " ▁ : ▁ " No ")); n = 6 ; System . out . printf ( ( isSuperPerfect ( n ) ? "Yes " ▁ : ▁ " No ")); } }
class GFG { static boolean isRefactorableNumber ( int n ) { int divCount = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; } public static void main ( String [ ] args ) { int n = 8 ; if ( isRefactorableNumber ( n ) ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; n = 14 ; if ( isRefactorableNumber ( n ) ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; } }
import java . io . * ; class GFG { static boolean isPerfectSquare ( int n ) { int sq = ( int ) Math . sqrt ( n ) ; return ( n == sq * sq ) ; } static int countPerfectDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; ++ i ) { if ( n % i == 0 ) { if ( isPerfectSquare ( i ) ) ++ count ; if ( n / i != i && isPerfectSquare ( n / i ) ) ++ count ; } } return count ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . print ( " Total ▁ perfect ▁ " + " divisors ▁ of ▁ " + n ) ; System . out . println ( " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; n = 12 ; System . out . print ( " Total ▁ perfect ▁ " + " divisors ▁ of ▁ " + n ) ; System . out . println ( " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static void nearestGcd ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; ++ i ) { int closest = - 1 ; for ( int j = i - 1 , k = i + 1 ; j > 0 k <= n ; -- j , ++ k ) { if ( j >= 0 && __gcd ( arr [ i ] , arr [ j ] ) > 1 ) { closest = j + 1 ; break ; } if ( k < n && __gcd ( arr [ i ] , arr [ k ] ) > 1 ) { closest = k + 1 ; break ; } } System . out . print ( closest + " ▁ " ) ; } } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void main ( String args [ ] ) { int [ ] arr = { 2 , 9 , 4 , 3 , 13 } ; int n = arr . length ; nearestGcd ( arr , n ) ; } }
class GFG { static int MAX = 100001 ; static int [ ] prime = new int [ MAX + 1 ] ; static int [ ] countdiv = new int [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 2 ; i * i <= MAX ; ++ i ) { if ( prime [ i ] == 0 ) for ( int j = i * 2 ; j <= MAX ; j += i ) prime [ j ] = i ; } for ( int i = 1 ; i < MAX ; ++ i ) if ( prime [ i ] == 0 ) prime [ i ] = i ; } static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int element = arr [ i ] ; while ( element > 1 ) { int div = prime [ element ] ; ++ countdiv [ div ] ; ans = Math . max ( ans , countdiv [ div ] ) ; while ( element % div == 0 ) element /= div ; } } return ans ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int arr [ ] = { 10 , 15 , 7 , 25 , 9 , 35 } ; int size = arr . length ; System . out . println ( largestGCDSubsequence ( arr , size ) ) ; } }
import java . util . LinkedList ; import java . util . Queue ; public class GFG { static int countOfBinaryNumberLessThanN ( int N ) { Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 1 ) ; int cnt = 0 ; int t ; while ( q . size ( ) > 0 ) { t = q . peek ( ) ; q . remove ( ) ; if ( t <= N ) { cnt ++ ; q . add ( t * 10 ) ; q . add ( t * 10 + 1 ) ; } } return cnt ; } static public void main ( String [ ] args ) { int N = 200 ; System . out . println ( countOfBinaryNumberLessThanN ( N ) ) ; } }
import java . io . * ; class GFG { static int sumofproduct ( int n ) { int ans = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { int y = n / x ; ans += ( y * x ) ; } return ans ; } static public void main ( String [ ] args ) { int n = 10 ; System . out . println ( sumofproduct ( n ) ) ; } }
import java . io . * ; class GFG { static int per ( int n ) { int a = 3 , b = 0 , c = 2 , i ; int m = 0 ; if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return c ; while ( n > 2 ) { m = a + b ; a = b ; b = c ; c = m ; n -- ; } return m ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . println ( per ( n ) ) ; } }
public class GFG { static int fact ( int n ) { int num = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { num = num * i ; } return num ; } static int Special_Factorial_Number ( int k ) { for ( int i = 1 ; i <= k ; i ++ ) { if ( fact ( i ) % k == 0 ) { return i ; } } return 0 ; } public static void main ( String [ ] args ) { int k = 16 ; System . out . println ( Special_Factorial_Number ( k ) ) ; } }
import java . io . * ; class GFG { static int countMaxChoco ( int money , int price , int wrap ) { if ( money < price ) return 0 ; int choc = money / price ; choc = choc + ( choc - 1 ) / ( wrap - 1 ) ; return choc ; } public static void main ( String [ ] args ) { int money = 15 ; int price = 1 ; int wrap = 3 ; System . out . println ( countMaxChoco ( money , price , wrap ) ) ; } }
class GFG { static int gcd ( int i , int j ) { if ( i == j ) return i ; if ( i > j ) return gcd ( i - j , j ) ; return gcd ( i , j - i ) ; } static boolean ispossible ( int x , int y , int a , int b ) { x = Math . abs ( x ) ; y = Math . abs ( y ) ; a = Math . abs ( a ) ; b = Math . abs ( b ) ; return ( gcd ( x , y ) == gcd ( a , b ) ) ; } public static void main ( String [ ] args ) { int x = 35 , y = 15 ; int a = 20 , b = 25 ; if ( ispossible ( x , y , a , b ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . Vector ; import static java . lang . Math . sqrt ; class GFG { static final int MAX = 10000 ; static Vector < Integer > primes = new Vector < Integer > ( MAX + 1 ) ; static void sieveSundaram ( ) { boolean marked [ ] = new boolean [ MAX / 2 + 1 ] ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . add ( 2 * i + 1 ) ; } static boolean isEquidigital ( int n ) { if ( n == 1 ) return true ; int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no / 10 ; } int pDigit = 0 , count_exp = 0 , p = 0 ; for ( int i = 0 ; primes . elementAt ( i ) <= n / 2 ; i ++ ) { while ( n % primes . elementAt ( i ) == 0 ) { p = primes . elementAt ( i ) ; n = n / p ; count_exp ++ ; } while ( p > 0 ) { pDigit ++ ; p = p / 10 ; } while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp / 10 ; } } if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n / 10 ; } } return ( pDigit == sumDigits ) ; } public static void main ( String [ ] args ) { sieveSundaram ( ) ; System . out . println ( " Printing ▁ first ▁ few ▁ Equidigital ▁ Numbers " + " ▁ using ▁ isEquidigital ( ) " ) ; for ( int i = 1 ; i < 20 ; i ++ ) if ( isEquidigital ( i ) ) System . out . print ( i + " ▁ " ) ; } }
class GFG { static int getMaximumSumWithLCMN ( int N ) { int sum = 0 ; int LIM = ( int ) Math . sqrt ( N ) ; for ( int i = 1 ; i <= LIM ; i ++ ) { if ( N % i == 0 ) { if ( i == ( N / i ) ) sum += i ; else sum += ( i + N / i ) ; } } return sum ; } public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( getMaximumSumWithLCMN ( N ) ) ; } }
class GFG { static long gcd ( long a , long b ) { if ( a % b != 0 ) return gcd ( b , a % b ) ; else return b ; } static long lcm ( long n ) { long ans = 1 ; for ( long i = 1 ; i <= n ; i ++ ) ans = ( ans * i ) / ( gcd ( ans , i ) ) ; return ans ; } public static void main ( String [ ] args ) { long n = 20 ; System . out . println ( lcm ( n ) ) ; } }
class GFG { static float y ( float x ) { return 1 / ( 1 + x * x ) ; } static float trapezoidal ( float a , float b , float n ) { float h = ( b - a ) / n ; float s = y ( a ) + y ( b ) ; for ( int i = 1 ; i < n ; i ++ ) s += 2 * y ( a + i * h ) ; return ( h / 2 ) * s ; } public static void main ( String [ ] args ) { float x0 = 0 ; float xn = 1 ; int n = 6 ; System . out . println ( " Value ▁ of ▁ integral ▁ is ▁ " + Math . round ( trapezoidal ( x0 , xn , n ) * 10000.0 ) / 10000.0 ) ; } }
class GFG { static double numberOfDigits ( double n ) { if ( n == 1 ) return 1 ; double d = ( n * Math . log10 ( 1.6180339887498948 ) ) - ( ( Math . log10 ( 5 ) ) / 2 ) ; return Math . ceil ( d ) ; } public static void main ( String [ ] args ) { double i ; for ( i = 1 ; i <= 10 ; i ++ ) System . out . println ( " Number ▁ of ▁ Digits ▁ in ▁ F ( " + i + " ) ▁ - ▁ " + numberOfDigits ( i ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { public static int countOddSquares ( int n , int m ) { return ( int ) Math . pow ( ( double ) m , 0.5 ) - ( int ) Math . pow ( ( double ) n - 1 , 0.5 ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 100 ; System . out . print ( " Count ▁ is ▁ " + countOddSquares ( n , m ) ) ; } }
class CountSquares { double countSquares ( int a , int b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; } } public class PerfectSquares { public static void main ( String [ ] args ) { int a = 9 , b = 25 ; CountSquares obj = new CountSquares ( ) ; System . out . print ( " Count ▁ of ▁ squares ▁ is ▁ " + ( int ) obj . countSquares ( a , b ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int findCountUpto ( int d ) { int GP1_Sum = 9 * ( ( int ) ( ( Math . pow ( 10 , d ) ) - 1 ) / 9 ) ; int GP2_Sum = 9 * ( ( int ) ( ( Math . pow ( 9 , d ) ) - 1 ) / 8 ) ; return GP1_Sum - GP2_Sum ; } public static void main ( String args [ ] ) { int d = 1 ; System . out . println ( findCountUpto ( d ) ) ; d = 2 ; System . out . println ( findCountUpto ( d ) ) ; d = 4 ; System . out . println ( findCountUpto ( d ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static void countDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) count += ( n / i == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) System . out . println ( " Even " ) ; else System . out . println ( " Odd " ) ; } public static void main ( String args [ ] ) { System . out . print ( " The ▁ count ▁ of ▁ divisor : ▁ " ) ; countDivisors ( 10 ) ; } }
import java . util . Arrays ; public class GFG { static int largestPower ( int n , int p ) { int x = 0 ; while ( n > 0 ) { n /= p ; x += n ; } return x ; } static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; s while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } static int modFact ( int n , int p ) { if ( n >= p ) { return 0 ; } int res = 1 ; boolean isPrime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( isPrime , true ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = 2 * i ; j <= n ; j += i ) { isPrime [ j ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime [ i ] ) { int k = largestPower ( n , i ) ; res = ( res * power ( i , k , p ) ) % p ; } } return res ; } static public void main ( String [ ] args ) { int n = 25 , p = 29 ; System . out . println ( modFact ( n , p ) ) ; } }
class GFG { static int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; } public static void main ( String [ ] args ) { int m = 4 , n = 3 ; System . out . println ( " Count ▁ of ▁ squares ▁ is ▁ " + countSquares ( m , n ) ) ; } }
public class GFG { static int add ( int x , int y ) { while ( y > 0 && y != 0 ) { x ++ ; y -- ; } while ( y < 0 && y != 0 ) { x -- ; y ++ ; } return x ; } public static void main ( String args [ ] ) { System . out . println ( add ( 43 , 23 ) ) ; System . out . println ( add ( 43 , - 23 ) ) ; } }
class GFG { static int countFact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; } public static void main ( String [ ] args ) { System . out . print ( " Count ▁ is ▁ " + countFact ( 2 , 720 ) ) ; } }
class GFG { static int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; } public static void main ( String [ ] args ) { System . out . println ( getPeriod ( 3 ) ) ; System . out . println ( getPeriod ( 7 ) ) ; } }
import java . io . * ; class GFG { static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; } public static void main ( String [ ] args ) { System . out . println ( getRemainder ( 100 , 7 ) ) ; } }
import java . io . * ; class GFG { static double sum ( int n ) { double sum = 0 ; int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( sum ( n ) ) ; } }
import java . io . * ; class GFG { static void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( ( 10 * rem ) / n ) ; rem = ( 10 * rem ) % n ; } } public static void main ( String [ ] args ) { int n = 7 , k = 3 ; print ( n , k ) ; System . out . println ( ) ; n = 21 ; k = 4 ; print ( n , k ) ; } }
import java . io . * ; class GFG { static double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . printf ( " Sum ▁ is ▁ % f " , sum ( n ) ) ; } }
class Test { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
class Rearrange { void rearrange ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] += ( arr [ arr [ i ] ] % n ) * n ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] /= n ; } void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { Rearrange rearrange = new Rearrange ( ) ; int arr [ ] = { 3 , 2 , 0 , 1 } ; int n = arr . length ; System . out . println ( " Given ▁ Array ▁ is ▁ : " ) ; rearrange . printArr ( arr , n ) ; rearrange . rearrange ( arr , n ) ; System . out . println ( " Modified ▁ Array ▁ is ▁ : " ) ; rearrange . printArr ( arr , n ) ; } }
class GfG { static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; return ; } static void printSequencesRecur ( int arr [ ] , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } } static void printSequences ( int n , int k ) { int arr [ ] = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; } public static void main ( String [ ] args ) { int n = 3 ; int k = 2 ; printSequences ( n , k ) ; } }
class GFG { static boolean isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) System . out . printf ( "%d is multiple of 5NEW_LINE", n); else System . out . printf ( "%d is not a multiple of 5NEW_LINE", n); } }
class GFG { static void CalculatePairs ( int a [ ] , int n ) { int cnt_zero = 0 ; int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } int total_XOR_pairs = cnt_zero * cnt_one ; int total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; int total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; System . out . println ( " cntXOR ▁ = ▁ " + total_XOR_pairs ) ; System . out . println ( " cntAND ▁ = ▁ " + total_AND_pairs ) ; System . out . println ( " cntOR ▁ = ▁ " + total_OR_pairs ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 4 , 2 } ; int n = a . length ; CalculatePairs ( a , n ) ; } }
import java . util . * ; class solution { static void alternate ( int a , int b , int x ) { x = a + b - x ; System . out . println ( " After ▁ change " + " " + " x is : "+x); } public static void main ( String args [ ] ) { int a = - 10 ; int b = 15 ; int x = a ; System . out . println ( " x ▁ is ▁ : ▁ " + x ) ; alternate ( a , b , x ) ; } }
class GFG { static int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; } public static void main ( String [ ] args ) { int n = 48 ; System . out . println ( highestPowerOf2 ( n ) ) ; } }
import java . io . * ; public class GFG { static void isSubsetAndZero ( int array [ ] , int length , int N ) { int arrAnd = array [ 0 ] ; for ( int i = 1 ; i < length ; i ++ ) { arrAnd = arrAnd & array [ i ] ; } if ( ( arrAnd & N ) == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int array [ ] = { 1 , 2 , 4 } ; int length = array . length ; int N = 3 ; isSubsetAndZero ( array , length , N ) ; } }
import java . io . * ; class GFG { static boolean findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( ( y & 1 ) > 0 ) return true ; return false ; } public static void main ( String [ ] args ) { if ( ( findParity ( 9 ) == false ) ) System . out . println ( " Even ▁ Parity " ) ; else System . out . println ( " Odd ▁ Parity " ) ; if ( findParity ( 13 ) == false ) System . out . println ( " Even ▁ Parity " ) ; else System . out . println ( " Odd ▁ Parity " ) ; } }
class GFG { static boolean allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return true ; return false ; } static boolean bitsAreComplement ( int a , int b , int l , int r ) { int xor_value = a ^ b ; return allBitsSetInTheGivenRange ( xor_value , l , r ) ; } public static void main ( String [ ] args ) { int a = 10 , b = 5 ; int l = 1 , r = 3 ; if ( bitsAreComplement ( a , b , l , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int calculate sum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( 1 << i ) ; } return sum ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( " Sum ▁ of ▁ the ▁ series ▁ : ▁ " + calculateSum ( n ) ) ; } } ;
import java . io . * ; class GFG { static void printCombinations ( int a [ ] , int n , int m ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int sum = 0 ; int num = 1 << ( n - 1 ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & num ) > 0 ) sum += a [ j ] ; else sum += ( - 1 * a [ j ] ) ; num = num >> 1 ; } if ( sum % m == 0 ) { num = 1 << ( n - 1 ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & num ) > 0 ) System . out . print ( " + " + a [ j ] + " ▁ " ) ; else System . out . print ( " - " + a [ j ] + " ▁ " ) ; num = num >> 1 ; } System . out . println ( ) ; } } } public static void main ( String args [ ] ) { int a [ ] = { 3 , 5 , 6 , 8 } ; int n = a . length ; int m = 5 ; printCombinations ( a , n , m ) ; } }
class GFG { static int __builtin_popcount ( int n ) { int d , t = 0 ; while ( n > 0 ) { d = n % 2 ; n = n / 2 ; if ( d == 1 ) t ++ ; } return t ; } static int smallerNumsWithSameSetBits ( int n ) { int temp = __builtin_popcount ( n ) ; int count = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( temp == __builtin_popcount ( i ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( smallerNumsWithSameSetBits ( n ) ) ; } }
class GFG { static int multiplyWith4 ( int n ) { return ( n << 2 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( multiplyWith4 ( n ) ) ; } }
class GFG { static int evenbitsetnumber ( int n ) { int count = 0 , res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( evenbitsetnumber ( n ) ) ; } }
import java . io . * ; class GFG { static int getmsb ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; } static int getevenbits ( int n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 1 ) n = n >> 1 ; return n ; } static int setallevenbits ( int n ) { return n | getevenbits ( n ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( setallevenbits ( n ) ) ; } }
class GFG { static int oddbitsetnumber ( int n ) { int count = 0 ; int res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( oddbitsetnumber ( n ) ) ; } }
class GFG { static int getmsb ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; } static int getevenbits ( int n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 0 ) n = n >> 1 ; return n ; } static int setalloddbits ( int n ) { return n | getevenbits ( n ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( setalloddbits ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static void printNumHavingAltBitPatrn ( int n ) { int curr_num = 1 , i = 1 ; System . out . print ( curr_num + " ▁ " ) ; while ( i != 0 ) { i ++ ; curr_num <<= 1 ; if ( n < curr_num ) break ; System . out . print ( curr_num + " ▁ " ) ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; System . out . print ( curr_num + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 50 ; printNumHavingAltBitPatrn ( n ) ; } }
import java . util . * ; class GFG { static int perfectPowerOf2 ( int n ) { int per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( " Perfect ▁ power ▁ of ▁ 2 ▁ greater ▁ than ▁ " + n + " : ▁ " + perfectPowerOf2 ( n ) ) ; } }
class GFG { static void findUniquePair ( int [ ] arr , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; int set_bit_no = XOR & ~ ( XOR - 1 ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ unique ▁ pair ▁ is ▁ ( " + x + " , " + y + " ) " ) ; } public static void main ( String [ ] args ) { int [ ] a = { 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 } ; int n = a . length ; findUniquePair ( a , n ) ; } }
class GFG { static int countUnsetBits ( int n ) { int x = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return Integer . bitCount ( x ^ n ) ; } public static void main ( String [ ] args ) { int n = 17 ; System . out . println ( countUnsetBits ( n ) ) ; } }
class GFG { static int countBits ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; n >>= 1 ; } return count ; } public static void main ( String [ ] arg ) { int i = 65 ; System . out . print ( countBits ( i ) ) ; } }
class GFG { static int toggle ( int n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; } public static void main ( String arg [ ] ) { int n = 10 ; n = toggle ( n ) ; System . out . print ( n ) ; } }
import java . io . * ; class GFG { static int INT_MAX = 2147483647 ; static int isKthBitSet ( int x , int k ) { return ( ( x & ( 1 << ( k - 1 ) ) ) > 0 ) ? 1 : 0 ; } static int leftmostSetBit ( int x ) { int count = 0 ; while ( x > 0 ) { count ++ ; x = x >> 1 ; } return count ; } static int isBinPalindrome ( int x ) { int l = leftmostSetBit ( x ) ; int r = 1 ; while ( l > r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; } static int findNthPalindrome ( int n ) { int pal_count = 0 ; int i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) > 0 ) { pal_count ++ ; } if ( pal_count == n ) break ; } return i ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . println ( findNthPalindrome ( n ) ) ; } }
class GFG { static void areSame ( int a , int b ) { if ( ( a - b ) == 0 ) System . out . println ( " Same " ) ; else System . out . println ( " Not ▁ Same " ) ; } public static void main ( String args [ ] ) { areSame ( 10 , 20 ) ; } }
import java . io . * ; class GFG { static int toggleBitsFromLToR ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( n ^ num ) ; } public static void main ( String [ ] args ) { int n = 50 ; int l = 2 , r = 5 ; System . out . println ( toggleBitsFromLToR ( n , l , r ) ) ; } }
class GFG { static int getRightMostSetBit ( int n ) { if ( n == 0 ) return 0 ; return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; } static int posOfRightMostDiffBit ( int m , int n ) { return getRightMostSetBit ( m ^ n ) ; } public static void main ( String arg [ ] ) { int m = 52 , n = 4 ; System . out . print ( " Position ▁ = ▁ " + posOfRightMostDiffBit ( m , n ) ) ; } }
import java . io . * ; class GFG { static int getNext ( int n ) { int c = n ; int c0 = 0 ; int c1 = 0 ; while ( ( ( c & 1 ) == 0 ) && ( c != 0 ) ) { c0 ++ ; c >>= 1 ; } while ( ( c & 1 ) == 1 ) { c1 ++ ; c >>= 1 ; } if ( c0 + c1 == 31 c0 + c1 == 0 ) return - 1 ; return n + ( 1 << c0 ) + ( 1 << ( c1 - 1 ) ) - 1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( getNext ( n ) ) ; n = 8 ; System . out . println ( getNext ( n ) ) ; } }
class GFG { static int totalFlips ( String A , String B , String C , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( A . charAt ( i ) == B . charAt ( i ) && C . charAt ( i ) == '1' ) ++ count ; else if ( A . charAt ( i ) != B . charAt ( i ) && C . charAt ( i ) == '0' ) ++ count ; } return count ; } public static void main ( String [ ] args ) { int N = 5 ; String a = "10100" ; String b = "00010" ; String c = "10011" ; System . out . print ( totalFlips ( a , b , c , N ) ) ; } }
class GFG { static int a , b , c ; static void swapThree ( ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; } public static void main ( String [ ] args ) { a = 10 ; b = 20 ; c = 30 ; System . out . println ( " Before ▁ swapping ▁ a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b + " , c ▁ = ▁ " + c ) ; swapThree ( ) ; System . out . println ( " After ▁ swapping ▁ a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } }
import java . util . * ; class GFG { static void findTwoMissingNumbers ( int arr [ ] , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n - 2 ; i ++ ) XOR ^= arr [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) XOR ^= i ; int set_bit_no = XOR & ~ ( XOR - 1 ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i & set_bit_no ) > 0 ) x = x ^ i ; else y = y ^ i ; } System . out . println ( " Two ▁ Missing ▁ Numbers ▁ are ▁ " ) ; System . out . println ( x + " ▁ " + y ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 6 } ; int n = 2 + arr . length ; findTwoMissingNumbers ( arr , n ) ; } }
class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static char findProffesion ( int level , int pos ) { int c = countSetBits ( pos - 1 ) ; return ( c % 2 != 0 ) ? ' d ' : ' e ' ; } public static void main ( String [ ] args ) { int level = 3 , pos = 4 ; String prof = ( findProffesion ( level , pos ) == ' e ' ) ? " Engineer " : " Doctor " ; System . out . print ( prof ) ; } }
import java . util . Random ; class GFG { static int rand2 ( ) { Random rand = new Random ( ) ; return ( rand . nextInt ( ) & 1 ) ; } static int rand3 ( ) { int r = 2 * rand2 ( ) + rand2 ( ) ; if ( r < 3 ) return r ; return rand3 ( ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 100 ; i ++ ) System . out . print ( rand3 ( ) ) ; } }
class GFG { static void findpair ( int l , int r ) { int ans1 = l ; int ans2 = 2 * l ; System . out . println ( ans1 + " , ▁ " + ans2 ) ; } public static void main ( String args [ ] ) { int l = 1 , r = 10 ; findpair ( l , r ) ; } }
import java . util . Arrays ; public class GFG { static boolean ElementsCalculationFunc ( int pre [ ] , int maxx [ ] , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; } static void MaxNumberOfElements ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; for ( int i = 0 ; i <= n ; ++ i ) { pre [ i ] = 0 ; maxx [ i ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] ; maxx [ i ] = Math . max ( maxx [ i - 1 ] , a [ i - 1 ] ) ; } int l = 1 , r = n , ans = 0 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( ElementsCalculationFunc ( pre , maxx , mid - 1 , k , n ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; } System . out . print ( ( int ) ans + "NEW_LINE"); } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 4 , 9 } ; int n = arr . length ; int k = 3 ; MaxNumberOfElements ( arr , n , k ) ; } }
import java . io . * ; class GFG { static int MAX_STR_LEN = 1000 ; static boolean P [ ] [ ] = new boolean [ MAX_STR_LEN ] [ MAX_STR_LEN ] ; static int [ ] Kpal = new int [ MAX_STR_LEN ] ; static void checkSubStrPal ( String str , int n ) { for ( int i = 0 ; i < MAX_STR_LEN ; i ++ ) { for ( int j = 0 ; j < MAX_STR_LEN ; j ++ ) P [ i ] [ j ] = false ; Kpal [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) P [ i ] [ i + 1 ] = true ; for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str . charAt ( i ) == str . charAt ( j ) && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; } } } static void countKPalindromes ( int i , int j , int k ) { if ( i == j ) { Kpal [ k ] ++ ; return ; } if ( P [ i ] [ j ] == false ) return ; Kpal [ k ] ++ ; int mid = ( i + j ) / 2 ; if ( ( j - i + 1 ) % 2 == 1 ) mid -- ; countKPalindromes ( i , mid , k + 1 ) ; } static void printKPalindromes ( String s ) { int n = s . length ( ) ; checkSubStrPal ( s , n ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - i ; j ++ ) countKPalindromes ( j , j + i , 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( Kpal [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { String s = " abacaba " ; printKPalindromes ( s ) ; } }
class Country { public static void countCountries ( int ans [ ] , int N ) { int total_countries = 0 , i = 0 ; boolean invalid = false ; while ( i < N ) { int curr_size = ans [ i ] ; int num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { System . out . print ( "Invalid AnswerNEW_LINE" ); return ; } else num -- ; i ++ ; } total_countries ++ ; } System . out . print ( " There ▁ are ▁ " + total_countries + " distinct companies in the group.NEW_LINE" ); } public static void main ( String [ ] args ) { int ans [ ] = { 1 , 1 , 2 , 2 , 4 , 4 , 4 , 4 } ; int n = 8 ; countCountries ( ans , n ) ; } }
import java . util . * ; class GFG { public static boolean check_elements ( int arr [ ] , int n , int A , int B ) { int range = B - A ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . abs ( arr [ i ] ) >= A && Math . abs ( arr [ i ] ) <= B ) { int z = Math . abs ( arr [ i ] ) - A ; if ( arr [ z ] > 0 ) { arr [ z ] = arr [ z ] * - 1 ; } } } int count = 0 ; for ( int i = 0 ; i <= range && i < n ; i ++ ) { if ( arr [ i ] > 0 ) return false ; else count ++ ; } if ( count != ( range + 1 ) ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 5 , 2 , 7 , 8 , 3 } ; int n = arr . length ; int A = 2 , B = 5 ; if ( check_elements ( arr , n , A , B ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { public static int findMinRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; } public static void main ( String args [ ] ) { int A [ ] = { 1 , 4 , 45 , 6 , - 50 , 10 , 2 } ; int n = A . length ; System . out . println ( findMinRec ( A , n ) ) ; } }
public class GFG { static boolean isPossible ( int arr [ ] , int n , int m , int curr_min ) { int studentsRequired = 1 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > curr_min ) return false ; if ( curr_sum + arr [ i ] > curr_min ) { studentsRequired ++ ; curr_sum = arr [ i ] ; if ( studentsRequired > m ) return false ; } else curr_sum += arr [ i ] ; } return true ; } static int findPages ( int arr [ ] , int n , int m ) { long sum = 0 ; if ( n < m ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int start = 0 , end = ( int ) sum ; int result = Integer . MAX_VALUE ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( isPossible ( arr , n , m , mid ) ) { result = mid ; end = mid - 1 ; } else start = mid + 1 ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 34 , 67 , 90 } ; System . out . println ( " Minimum ▁ number ▁ of ▁ pages ▁ = ▁ " + findPages ( arr , arr . length , m ) ) ; } }
import java . util . * ; class GFG { public static int countDistinct ( int arr [ ] , int n ) { HashSet < Integer > hs = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hs . add ( arr [ i ] ) ; } return hs . size ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 } ; System . out . println ( countDistinct ( arr , arr . length ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int findOptimalSolution ( int [ ] a , int N ) { Arrays . sort ( a ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; } public static void main ( String args [ ] ) { int [ ] a = { 1 , 4 , 2 , 3 , 9 } ; int N = a . length ; System . out . println ( findOptimalSolution ( a , N ) ) ; } }
import java . util . Arrays ; public class Improve { static int number_of_tower ( int house [ ] , int range , int n ) { Arrays . sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; } public static void main ( String args [ ] ) { int house [ ] = { 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 } ; int range = 2 ; int n = house . length ; System . out . println ( number_of_tower ( house , range , n ) ) ; } }
import java . util . Arrays ; public class GFG { static boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; char c [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s . charAt ( i ) ; } Arrays . sort ( c ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s . charAt ( i ) ) return false ; return true ; } public static void main ( String args [ ] ) { String s = " aabbbcc " ; if ( isAlphabaticOrder ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class SortExample { static void printOrder ( Integer [ ] arr , int k ) { int n = arr . length ; Arrays . sort ( arr , 0 , k ) ; Arrays . sort ( arr , k , n , Collections . reverseOrder ( ) ) ; } public static void main ( String [ ] args ) { Integer [ ] arr = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 } ; int k = 4 ; printOrder ( arr , k ) ; System . out . printf ( " % s " , Arrays . toString ( arr ) ) ; } }
import java . util . * ; class GFG { static void descOrder ( char [ ] s ) { Arrays . sort ( s ) ; reverse ( s ) ; } static void reverse ( char [ ] a ) { int i , n = a . length ; char t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } } public static void main ( String [ ] args ) { char [ ] s = " geeksforgeeks " . toCharArray ( ) ; System . out . println ( String . valueOf ( s ) ) ; } }
public class GFG { static final int MAX = 1000 ; static int findDuplicate ( int arr [ ] , int n , int k ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { System . out . println ( " Out ▁ of ▁ range " ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = arr . length ; System . out . println ( findDuplicate ( arr , n , k ) ) ; } }
import java . util . Arrays ; class Test { static void pendulumArrangement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int op [ ] = new int [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; System . out . println ( " Pendulum ▁ arrangement : " ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( op [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 14 , 6 , 19 , 21 , 12 } ; pendulumArrangement ( arr , arr . length ) ; } }
import java . io . * ; import java . util . * ; class GFG { static long minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 1 , 1 } ; int B [ ] = { 6 , 5 , 4 } ; int n = A . length ; ; System . out . println ( minValue ( A , B , n ) ) ; } }
class GFG { public static void printMaxNumber ( int n ) { if ( n % 2 != 0 ) { System . out . print ( "7" ) ; for ( int i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) System . out . print ( "1" ) ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) System . out . print ( "1" ) ; } } public static void main ( String [ ] args ) { int n = 5 ; printMaxNumber ( n ) ; } }
import java . util . Arrays ; class GFG { static int sorted_partitions ( int arr [ ] ) { int n = arr . length ; int [ ] right_min = new int [ n + 1 ] ; right_min [ n ] = Integer . MAX_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { right_min [ i ] = Math . min ( right_min [ i + 1 ] , arr [ i ] ) ; } int partitions = 0 ; for ( int current_max = arr [ 0 ] , i = 0 ; i < n ; i ++ ) { current_max = Math . max ( current_max , arr [ i ] ) ; if ( current_max <= right_min [ i + 1 ] ) partitions ++ ; } return partitions ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 3 , 1 , 2 , 4 , 100 , 7 , 9 } ; int ans = sorted_partitions ( arr ) ; System . out . println ( ans ) ; } }
import java . util . Collections ; import java . util . Arrays ; public class GfG { public static int getMinCost ( Integer arr [ ] , int n ) { int min_ele = Collections . min ( Arrays . asList ( arr ) ) ; return min_ele * ( n - 1 ) ; } public static void main ( String [ ] args ) { Integer [ ] arr = { 4 , 2 , 5 } ; int n = arr . length ; System . out . println ( getMinCost ( arr , n ) ) ; } }
public class GFG { public static void main ( String args [ ] ) { String st = " NNNWEWESSS " ; int len = st . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( st . charAt ( i ) == ' N ' ) n += 1 ; if ( st . charAt ( i ) == ' S ' ) s += 1 ; if ( st . charAt ( i ) == ' W ' ) w += 1 ; if ( st . charAt ( i ) == ' E ' ) e += 1 ; } if ( n == s && w == e ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . lang . * ; public class GFG { static int cost ( int [ ] a , int n ) { int min = a [ 0 ] ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; } static public void main ( String [ ] args ) { int [ ] a = { 4 , 3 , 2 } ; int n = a . length ; System . out . println ( cost ( a , n ) ) ; } }
import java . util . Arrays ; class GFG { static int minCost ( int coin [ ] , int n , int k ) { Arrays . sort ( coin ) ; int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; } public static void main ( String arg [ ] ) { int coin [ ] = { 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 } ; int n = coin . length ; int k = 3 ; System . out . print ( minCost ( coin , n , k ) ) ; } }
class GFG { static int countOddNumber ( int row_num ) { int count = 0 ; while ( row_num > 0 ) { count += row_num & 1 ; row_num >>= 1 ; } return ( 1 << count ) ; } static void gouldSequence ( int n ) { for ( int row_num = 0 ; row_num < n ; row_num ++ ) { System . out . print ( countOddNumber ( row_num ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 16 ; gouldSequence ( n ) ; } }
import java . io . * ; class GFG { static int countWays ( int n ) { int [ ] A = new int [ n + 1 ] ; int [ ] B = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 0 ; B [ 0 ] = 0 ; B [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; } return A [ n ] ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( countWays ( n ) ) ; } }
import java . io . * ; class GFG { static int sequence ( int n ) { if ( n == 1 n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( sequence ( n ) ) ; } }
import java . io . * ; class GFG { static int numberOfWays ( int x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; } public static void main ( String [ ] args ) { int x = 3 ; System . out . println ( numberOfWays ( x ) ) ; } }
import java . io . * ; class GFG { static int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; } public static void main ( String [ ] args ) { int x = 3 ; System . out . println ( numberOfWays ( x ) ) ; } }
static int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
class GFG { static int waysToArrange ( int N , int K , int [ ] k ) { int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } int [ ] dp = new int [ K + 1 ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; } public static void main ( String [ ] args ) { int N = 4 ; int [ ] k = new int [ ] { 2 , 2 } ; int K = k . length ; System . out . println ( waysToArrange ( N , K , k ) ) ; } }
class MinCellsDestination { static final int SIZE = 100 ; static int minCells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 2 , 3 , 2 , 1 , 4 } , { 3 , 2 , 5 , 8 , 2 } , { 1 , 1 , 2 , 2 , 1 } } ; int m = 3 , n = 5 ; System . out . println ( " Minimum ▁ number ▁ of ▁ cells " + " ▁ = ▁ " + minCells ( mat , m , n ) ) ; } }
class GFG { static final int R = 3 ; static final int C = 3 ; static int cal ( int ones [ ] [ ] , int x , int y , int k ) { return ones [ x + k - 1 ] [ y + k - 1 ] - ones [ x - 1 ] [ y + k - 1 ] - ones [ x + k - 1 ] [ y - 1 ] + ones [ x - 1 ] [ y - 1 ] ; } static int sol ( int mat [ ] [ ] ) { int ans = 0 ; int val = 0 ; int ones [ ] [ ] = new int [ R + 1 ] [ C + 1 ] ; for ( int i = 1 ; i <= R ; i ++ ) for ( int j = 1 ; j <= C ; j ++ ) { if ( mat [ i - 1 ] [ j - 1 ] == 1 ) val = 1 ; ones [ i ] [ j ] = ones [ i - 1 ] [ j ] + ones [ i ] [ j - 1 ] - ones [ i - 1 ] [ j - 1 ] + ( val ) ; } for ( int k = 1 ; k <= Math . min ( R , C ) ; k ++ ) for ( int i = 1 ; i + k - 1 <= R ; i ++ ) for ( int j = 1 ; j + k - 1 <= C ; j ++ ) ans = Math . max ( ans , ( ones [ R ] [ C ] + k * k - 2 * cal ( ones , i , j , k ) ) ) ; return ans ; } static public void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 0 , 1 } , { 0 , 0 , 1 } , { 1 , 0 , 1 } } ; System . out . println ( sol ( mat ) ) ; } }
import java . io . * ; class GFG { static int getMinSteps ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int min = dp [ i - 1 ] ; if ( i % 2 == 0 ) { min = Math . min ( min , dp [ i / 2 ] ) ; } if ( i % 3 == 0 ) { min = Math . min ( min , dp [ i / 3 ] ) ; } dp [ i ] = min + 1 ; } return dp [ n ] ; } public static void main ( String [ ] args ) { int n = 14 ; System . out . print ( getMinSteps ( n ) ) ; } }
import java . io . * ; class GFG { static int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 3 , 2 } ; int n = arr . length ; System . out . println ( longestSubseqWithDiffOne ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int catalanDP ( int n ) { int [ ] catalan = new int [ n + 1 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; } static int countWays ( int n ) { if ( n < 1 ) { System . out . println ( " Invalid " ) ; return 0 ; } return catalanDP ( n / 2 ) ; } public static void main ( String [ ] args ) { System . out . println ( countWays ( 6 ) + " ▁ " ) ; } }
import java . util . Arrays ; class GFG { static final int MAX = 100 ; static int dp [ ] [ ] [ ] [ ] = new int [ MAX ] [ MAX ] [ MAX ] [ 3 ] ; static int countWays ( int p , int q , int r , int last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( dp [ p ] [ q ] [ r ] [ last ] != - 1 ) return dp [ p ] [ q ] [ r ] [ last ] ; if ( last == 0 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; else if ( last == 1 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; else dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return dp [ p ] [ q ] [ r ] [ last ] ; } static int countUtil ( int p , int q , int r ) { for ( int [ ] [ ] [ ] row : dp ) { for ( int [ ] [ ] innerRow : row ) { for ( int [ ] innerInnerRow : innerRow ) { Arrays . fill ( innerInnerRow , - 1 ) ; } } } ; } public static void main ( String [ ] args ) { int p = 1 , q = 1 , r = 1 ; System . out . print ( countUtil ( p , q , r ) ) ; } }
import java . io . * ; class GFG { static int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( " Count ▁ of ▁ Derangements ▁ is ▁ " + countDer ( n ) ) ; } }
import java . io . * ; class GFG { static int countDer ( int n ) { int der [ ] = new int [ n + 1 ] ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( " Count ▁ of ▁ Derangements ▁ is ▁ " + countDer ( n ) ) ; } }
import java . util . Arrays ; class GFG { static int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ ] = new int [ rhs + 1 ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; } public static void main ( String [ ] args ) { int coeff [ ] = { 2 , 2 , 5 } ; int rhs = 4 ; int n = coeff . length ; System . out . print ( countSol ( coeff , n , rhs ) ) ; } }
import java . io . * ; class GFG { static int maxProd ( int n ) { if ( n == 2 n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; } public static void main ( String [ ] args ) { System . out . println ( " Maximum ▁ Product ▁ is ▁ " + maxProd ( 10 ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { public static long findWays ( int m , int n , int x ) { long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { for ( int k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; } public static void main ( String [ ] args ) { System . out . println ( findWays ( 4 , 2 , 1 ) ) ; System . out . println ( findWays ( 2 , 2 , 3 ) ) ; System . out . println ( findWays ( 6 , 3 , 8 ) ) ; System . out . println ( findWays ( 4 , 2 , 5 ) ) ; System . out . println ( findWays ( 4 , 3 , 5 ) ) ; } }
class GFG { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int lps ( char seq [ ] , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } public static void main ( String [ ] args ) { String seq = " GEEKSFORGEEKS " ; int n = seq . length ( ) ; System . out . printf ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d " , lps ( seq . toCharArray ( ) , 0 , n - 1 ) ) ; } }
class GFG { static int findCount ( String str1 , String str2 ) { int len = str1 . length ( ) ; int len2 = str2 . length ( ) ; int ans = Integer . MAX_VALUE ; int [ ] hash1 = new int [ 26 ] ; int [ ] hash2 = new int [ 26 ] ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ ( int ) ( str1 . charAt ( i ) - ' a ' ) ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ ( int ) ( str2 . charAt ( i ) - ' a ' ) ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] != 0 ) ans = Math . min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; } public static void main ( String [ ] args ) { String str1 = " geeksclassesatnoida " ; String str2 = " sea " ; System . out . println ( findCount ( str1 , str2 ) ) ; } }
public class Improve { static boolean isVowel ( char c ) { String vowel = " aeiou " ; for ( int i = 0 ; i < vowel . length ( ) ; ++ i ) if ( vowel . charAt ( i ) == c ) return true ; return false ; } static boolean printRLE ( String str , String typed ) { int n = str . length ( ) , m = typed . length ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != typed . charAt ( j ) ) return false ; if ( isVowel ( str . charAt ( i ) ) == false ) { j ++ ; continue ; } int count1 = 1 ; while ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) { count1 ++ ; i ++ ; } int count2 = 1 ; while ( j < m - 1 && typed . charAt ( j ) == str . charAt ( i ) ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) return false ; } return true ; } public static void main ( String args [ ] ) { String name = " alex " , typed = " aaalaeex " ; if ( printRLE ( name , typed ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static String censor ( String text , String word ) { String [ ] word_list = text . split ( " \\ s + " ) ; String result = " " ; String stars = " " ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) stars += ' * ' ; int index = 0 ; for ( String i : word_list ) { if ( i . compareTo ( word ) == 0 ) word_list [ index ] = stars ; index ++ ; } for ( String i : word_list ) result += i + ' ▁ ' ; return result ; } public static void main ( String [ ] args ) { String extract = " GeeksforGeeks ▁ is ▁ a ▁ computer ▁ science ▁ " + " portal ▁ for ▁ geeks . ▁ I ▁ am ▁ pursuing ▁ my ▁ " + " major ▁ in ▁ computer ▁ science . ▁ " ; String cen = " computer " ; System . out . println ( censor ( extract , cen ) ) ; } }
import java . util . * ; class GFG { static String getTime ( String s , int n ) { String res = " " ; int h = Integer . parseInt ( s . substring ( 0 , 0 + 2 ) ) ; int m = Integer . parseInt ( s . substring ( 3 , 3 + 2 ) ) ; int rev_h = ( h % 10 ) * 10 + ( ( h % 100 ) - ( h % 10 ) ) / 10 ; String rev_hs = Integer . toString ( rev_h ) ; if ( h == 23 && m >= 32 ) { res = " - 1" ; } else if ( m < rev_h ) { String temp = " " ; if ( h < 10 ) temp = "0" ; temp = temp + Integer . toString ( h ) ; if ( rev_h < 10 ) res = res + temp + " : 0" + rev_hs ; else res = res + temp + " : " + rev_hs ; } else { h ++ ; rev_h = ( h % 10 ) * 10 + ( ( h % 100 ) - ( h % 10 ) ) / 10 ; rev_hs = Integer . toString ( rev_h ) ; String temp = " " ; if ( h < 10 ) temp = "0" ; temp = temp + Integer . toString ( h ) ; if ( rev_h < 10 ) res = res + temp + " : 0" + rev_hs ; else res = res + temp + " : " + rev_hs ; } return res ; } public static void main ( String [ ] args ) { String s = "21:12" ; int n = s . length ( ) ; System . out . println ( getTime ( s , n ) ) ; } }
class GFG { static int CountSubstring ( char str [ ] , int n ) { int ans = ( n * ( n + 1 ) ) / 2 ; int a_index = 0 ; int b_index = 0 ; int c_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' a ' ) { a_index = i + 1 ; ans -= Math . min ( b_index , c_index ) ; } else if ( str [ i ] == ' b ' ) { b_index = i + 1 ; ans -= Math . min ( a_index , c_index ) ; } else { c_index = i + 1 ; ans -= Math . min ( a_index , b_index ) ; } } return ans ; } public static void main ( String [ ] args ) { char str [ ] = " babac " . toCharArray ( ) ; int n = str . length ; System . out . println ( CountSubstring ( str , n ) ) ; } }
class gfg { static boolean isValid ( String str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) return false ; } return true ; } public static void main ( String [ ] args ) { String str = "0110" ; int len = str . length ( ) ; if ( isValid ( str , len ) ) System . out . println ( " Valid " ) ; else System . out . println ( " Invalid " ) ; } }
class GFG { static int check ( String s , int K ) { for ( int ch = 0 ; ch < 26 ; ch ++ ) { char c = ( char ) ( ' a ' + ch ) ; int last = - 1 ; boolean found = true ; for ( int i = 0 ; i < K ; i ++ ) if ( s . charAt ( i ) == c ) last = i ; if ( last == - 1 ) continue ; for ( int i = K ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) last = i ; if ( last <= ( i - K ) ) { found = false ; break ; } } if ( found ) return 1 ; } return 0 ; } static int binarySearch ( String s ) { int low = 1 , high = s . length ( ) ; int ans = 0 ; while ( low <= high ) { int mid = ( high + low ) >> 1 ; if ( check ( s , mid ) == 1 ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; } public static void main ( String args [ ] ) { String s = " abcde " ; System . out . println ( binarySearch ( s ) ) ; s = " aaaa " ; System . out . println ( binarySearch ( s ) ) ; } }
import java . io . * ; import java . util . * ; public class Gfg { static int vowel_calc ( String s ) { int n = s . length ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) arr [ i ] = n ; else arr [ i ] = ( n - i ) + arr [ i - 1 ] - i ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s . charAt ( i ) ; if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) sum += arr [ i ] ; } return sum ; } public static void main ( String args [ ] ) { String s = " daceh " ; System . out . println ( vowel_calc ( s ) ) ; } }
import java . lang . * ; class GFG { public static boolean ispalindrome ( int x ) { int ans = 0 ; int temp = x ; while ( temp > 0 ) { ans = 10 * ans + temp % 10 ; temp = temp / 10 ; } return ans == x ; } public static int SuperPalindromes ( int L , int R ) { int LIMIT = 100000 ; int ans = 0 ; for ( int i = 0 ; i < LIMIT ; i ++ ) { String s = Integer . toString ( i ) ; StringBuilder rs = new StringBuilder ( ) ; rs . append ( s . substring ( 0 , Math . max ( 1 , s . length ( ) - 1 ) ) ) ; String srs = rs . reverse ( ) . toString ( ) ; String p = s + srs ; int p_sq = ( int ) ( Math . pow ( Integer . parseInt ( p ) , 2 ) ) ; if ( p_sq > R ) { break ; } if ( p_sq >= L && ispalindrome ( p_sq ) ) { ans = ans + 1 ; } } for ( int i = 0 ; i < LIMIT ; i ++ ) { String s = Integer . toString ( i ) ; StringBuilder rs = new StringBuilder ( ) ; rs . append ( s ) ; rs = rs . reverse ( ) ; String p = s + rs ; int p_sq = ( int ) ( Math . pow ( Integer . parseInt ( p ) , 2 ) ) ; if ( p_sq > R ) { break ; } if ( p_sq >= L && ispalindrome ( p_sq ) ) { ans = ans + 1 ; } } return ans ; } public static void main ( String [ ] args ) { String L = "4" ; String R = "1000" ; System . out . println ( SuperPalindromes ( Integer . parseInt ( L ) , Integer . parseInt ( R ) ) ) ; } }
import java . util . * ; class GFG { static void solve ( String s , int k ) { int count = 0 , length = 0 , pos = 0 ; HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; length ++ ; if ( length > k ) { m . put ( s . charAt ( pos ) , m . get ( s . charAt ( pos ) ) - 1 ) ; pos ++ ; length -- ; } if ( length == k && m . get ( s . charAt ( i ) ) == length ) count ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { String s = " aaaabbbccdddd " ; int k = 4 ; solve ( s , k ) ; } }
import java . util . * ; class GFG { public static boolean solve ( String n , int l ) { if ( l < 3 ) { if ( Integer . parseInt ( n ) % 8 == 0 ) return true ; n = new String ( ( new StringBuilder ( ) ) . append ( n ) . reverse ( ) ) ; if ( Integer . parseInt ( n ) % 8 == 0 ) return true ; return false ; } int [ ] hash = new int [ 10 ] ; for ( int i = 0 ; i < l ; i ++ ) hash [ n . charAt ( i ) - '0' ] ++ ; for ( int i = 104 ; i < 1000 ; i += 8 ) { int dup = i ; int [ ] freq = new int [ 10 ] ; freq [ dup % 10 ] ++ ; dup = dup / 10 ; freq [ dup % 10 ] ++ ; dup = dup / 10 ; freq [ dup % 10 ] ++ ; dup = i ; if ( freq [ dup % 10 ] > hash [ dup % 10 ] ) continue ; dup = dup / 10 ; if ( freq [ dup % 10 ] > hash [ dup % 10 ] ) continue ; dup = dup / 10 ; if ( freq [ dup % 10 ] > hash [ dup % 10 ] ) continue ; return true ; } return false ; } public static void main ( String [ ] args ) { String number = "31462708" ; int l = number . length ( ) ; if ( solve ( number , l ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static String newString ( String s , int k ) { String X = " " ; while ( s . length ( ) > 0 ) { char temp = s . charAt ( 0 ) ; for ( int i = 1 ; i < k && i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < temp ) { temp = s . charAt ( i ) ; } } X = X + temp ; for ( int i = 0 ; i < k ; i ++ ) { if ( s . charAt ( i ) == temp ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; break ; } } } return X ; } public static void main ( String [ ] args ) { String s = " gaurang " ; int k = 3 ; System . out . println ( newString ( s , k ) ) ; } }
import java . util . * ; class Node { static void strToBinary ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = Integer . valueOf ( s . charAt ( i ) ) ; String bin = " " ; while ( val > 0 ) { if ( val % 2 == 1 ) { bin += '1' ; } else bin += '0' ; val /= 2 ; } bin = reverse ( bin ) ; System . out . print ( bin + " ▁ " ) ; } } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = 0 ; r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; } public static void main ( String [ ] args ) { String s = " geeks " ; strToBinary ( s ) ; } }
import java . util . * ; class GFG { static String printSequence ( String arr [ ] , String input ) { String output = " " ; int n = input . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input . charAt ( i ) == ' ▁ ' ) output = output + "0" ; else { int position = input . charAt ( i ) - ' A ' ; output = output + arr [ position ] ; } } return output ; } public static void main ( String [ ] args ) { String str [ ] = { "2" , "22" , "222" , "3" , "33" , "333" , "4" , "44" , "444" , "5" , "55" , "555" , "6" , "66" , "666" , "7" , "77" , "777" , "7777" , "8" , "88" , "888" , "9" , "99" , "999" , "9999" } ; String input = " GEEKSFORGEEKS " ; System . out . println ( printSequence ( str , input ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static boolean isEven ( String s1 ) { int l = s1 . length ( ) ; char [ ] s = s1 . toCharArray ( ) ; boolean dotSeen = false ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' && dotSeen == false ) continue ; if ( s [ i ] == ' . ' ) { dotSeen = true ; continue ; } if ( ( s [ i ] - '0' ) % 2 == 0 ) return true ; return false ; } return false ; } public static void main ( String argc [ ] ) { String s = "100.70" ; if ( isEven ( s ) ) System . out . println ( " Even " ) ; else System . out . println ( " Odd " ) ; } }
class GFG { final static int NO_OF_CHARS = 256 ; static int max_distinct_char ( String str , int n ) { int count [ ] = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str . charAt ( i ) ] ++ ; } int max_distinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] != 0 ) { max_distinct ++ ; } } return max_distinct ; } static int smallesteSubstr_maxDistictChar ( String str ) { int n = str . length ( ) ; int max_distinct = max_distinct_char ( str , n ) ; int minl = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { String subs = null ; if ( i < j ) subs = str . substring ( i , j ) ; else subs = str . substring ( j , i ) ; int subs_lenght = subs . length ( ) ; int sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ; if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; } static public void main ( String [ ] args ) { String str = " AABBBCBB " ; int len = smallesteSubstr_maxDistictChar ( str ) ; System . out . println ( " ▁ The ▁ length ▁ of ▁ the ▁ smallest ▁ substring " + " ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ " + " characters ▁ : ▁ " + len ) ; } }
public class Evaluate_BoolExp { static int evaluateBoolExpr ( StringBuffer s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( i + 1 < n && i + 2 < n ) { if ( s . charAt ( i + 1 ) == ' A ' ) { if ( s . charAt ( i + 2 ) == '0' || s . charAt ( i ) == 0 ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } else if ( ( i + 1 ) < n && s . charAt ( i + 1 ) == ' B ' ) { if ( s . charAt ( i + 2 ) == '1' || s . charAt ( i ) == '1' ) s . setCharAt ( i + 2 , '1' ) ; else s . setCharAt ( i + 2 , '0' ) ; } else { if ( s . charAt ( i + 2 ) == s . charAt ( i ) ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } } } return s . charAt ( n - 1 ) - '0' ; } public static void main ( String [ ] args ) { String s = "1C1B1B0A0" ; StringBuffer sb = new StringBuffer ( s ) ; System . out . println ( evaluateBoolExpr ( sb ) ) ; } }
public class First_Repeated_char { static int FirstRepeated ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; } public static void main ( String args [ ] ) { String s = " abcfdeacf " ; int i = FirstRepeated ( s ) ; if ( i != - 1 ) System . out . println ( " Char ▁ = ▁ " + s . charAt ( i ) + " ▁ and ▁ Index ▁ = ▁ " + i ) ; else System . out . println ( " No ▁ repeated ▁ Char " ) ; } }
public class GFG { static int evenNumSubstring ( String str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str . charAt ( i ) - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; } public static void main ( String args [ ] ) { String str = "1234" ; System . out . println ( evenNumSubstring ( str ) ) ; } }
import java . util . * ; class GFG { static boolean isSubSequence ( String str1 , String str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; for ( int i = 0 ; i < n && j < m ; i ++ ) { if ( str1 . charAt ( j ) == str2 . charAt ( i ) ) { j ++ ; } } return ( j == m ) ; } static String findLongestString ( Vector < String > dict , String str ) { String result = " " ; int length = 0 ; for ( String word : dict ) { if ( length < word . length ( ) && isSubSequence ( word , str ) ) { result = word ; length = word . length ( ) ; } } return result ; } public static void main ( String [ ] args ) { String [ ] arr = { " ale " , " apple " , " monkey " , " plea " } ; Vector dict = new Vector ( Arrays . asList ( arr ) ) ; String str = " abpcplea " ; System . out . println ( findLongestString ( dict , str ) ) ; } }
class GFG { static boolean isEditDistanceOne ( String s1 , String s2 ) { int m = s1 . length ( ) , n = s2 . length ( ) ; if ( Math . abs ( m - n ) > 1 ) return false ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 . charAt ( i ) != s2 . charAt ( j ) ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; { i ++ ; j ++ ; } count ++ ; } { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; } public static void main ( String [ ] args ) { String s1 = " gfg " ; String s2 = " gf " ; if ( isEditDistanceOne ( s1 , s2 ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class CountSubString { int countSubStr ( char str [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == '1' ) res ++ ; } } } return res ; } public static void main ( String [ ] args ) { CountSubString count = new CountSubString ( ) ; String string = "00100101" ; char str [ ] = string . toCharArray ( ) ; int n = str . length ; System . out . println ( count . countSubStr ( str , n ) ) ; } }
import java . io . * ; class GFG { static int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; } public static void main ( String args [ ] ) { int A = 2 , B = 5 , C = 13 ; System . out . println ( " Power ▁ is ▁ " + exponentMod ( A , B , C ) ) ; } }
import java . io . * ; class GFG { static int power ( int x , int y , int p ) { int res = 1 x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; y = y / 2 x = ( x * x ) % p ; } return res ; } public static void main ( String [ ] args ) { int x = 2 ; int y = 5 ; int p = 13 ; System . out . print ( " Power ▁ is ▁ " + power ( x , y , p ) ) ; } }
import java . io . * ; class GFG { static double trianglearea ( double a ) { if ( a < 0 ) return - 1 ; double area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / 4 ; return area ; } public static void main ( String [ ] args ) { double a = 6 ; System . out . println ( trianglearea ( a ) ) ; } }
import java . util . * ; class solution { static void equation_ellipse ( float x1 , float y1 , float a , float b , float c , float e ) { float t = a * a + b * b ; float a1 = t - e * ( a * a ) ; float b1 = t - e * ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; float e1 = - 2 * e * a * b ; float f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; System . out . println ( " Equation ▁ of ▁ ellipse ▁ is ▁ " ) ; System . out . print ( a1 + " ▁ x ^ 2 ▁ + ▁ " + b1 + " ▁ y ^ 2 ▁ + ▁ " + c1 + " ▁ x ▁ + ▁ " + d1 + " ▁ y ▁ + ▁ " + e1 + " ▁ xy ▁ + ▁ " + f1 + " ▁ = ▁ 0" ) ; } public static void main ( String arr [ ] ) { float x1 = 1 , y1 = 1 , a = 1 , b = - 1 , c = 3 , e = ( float ) 0.5 * ( float ) 0.5 ; equation_ellipse ( x1 , y1 , a , b , c , e ) ; } }
import java . io . * ; class GFG { static double PI = 3.14 ; static double circle_inscribed ( int a ) { return PI * ( a * a ) / 12 ; } public static void main ( String [ ] args ) { int a = 4 ; System . out . println ( circle_inscribed ( a ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void findVolume ( double u , double v , double w , double U , double V , double W , double b ) { double uPow = Math . pow ( u , 2 ) ; double vPow = Math . pow ( v , 2 ) ; double wPow = Math . pow ( w , 2 ) ; double UPow = Math . pow ( U , 2 ) ; double VPow = Math . pow ( V , 2 ) ; double WPow = Math . pow ( W , 2 ) ; double a = 4 * ( uPow * vPow * wPow ) - uPow * Math . pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * Math . pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * Math . pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; double vol = Math . sqrt ( a ) ; vol /= b ; System . out . printf ( " % .4f " , vol ) ; } public static void main ( String args [ ] ) { double u = 1000 , v = 1000 , w = 1000 ; double U = 3 , V = 4 , W = 5 ; double b = 12 ; findVolume ( u , v , w , U , V , W , b ) ; } }
class GFG { static void makePolygon ( double a ) { double n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { double a = 90 ; makePolygon ( a ) ; } }
import java . io . * ; class GFG { static int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = ( int ) Math . pow ( ( PX - X ) , 2 ) + ( int ) Math . pow ( ( PY - Y ) , 2 ) ; if ( val > Math . pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; return 0 ; } public static void main ( String [ ] args ) { int X = 0 , Y = 3 ; int R = 2 ; int PX = 1 , PY = 4 ; int ans = getQuadrant ( X , Y , R , PX , PY ) ; if ( ans == - 1 ) System . out . println ( " Lies ▁ Outside ▁ the ▁ circle " ) ; else if ( ans == 0 ) System . out . println ( " Coincides ▁ with ▁ centre " ) ; else System . out . println ( ans + " ▁ Quadrant " ) ; } }
import java . io . * ; class GFG { static long hexadecagonalNum ( long n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; } public static void main ( String [ ] args ) { long n = 5 ; System . out . println ( n + " th ▁ " + " Hexadecagonal ▁ number ▁ : ▁ " + hexadecagonalNum ( n ) ) ; n = 9 ; System . out . println ( n + " th ▁ " + " Hexadecagonal ▁ number ▁ : ▁ " + hexadecagonalNum ( n ) ) ; } }
import java . io . * ; class GFG { static int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; } public static void main ( String [ ] args ) { int diameter = 5 ; int height = 10 ; System . out . println ( " Perimeter ▁ = ▁ " + perimeter ( diameter , height ) + " unitsNEW_LINE"); } }
public class ParallelogramPoints { public static void main ( String [ ] s ) { int ax = 5 , ay = 0 ; int bx = 1 , by = 1 ; int cx = 2 , cy = 5 ; System . out . println ( ax + bx - cx + " , ▁ " + ( ay + by - cy ) ) ; System . out . println ( ax + cx - bx + " , ▁ " + ( ay + cy - by ) ) ; System . out . println ( cx + bx - ax + " , ▁ " + ( cy + by - ax ) ) ; } }
class GFG { static float area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return ( float ) Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; } static boolean check ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 , int x , int y ) { float A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) + area ( x1 , y1 , x4 , y4 , x3 , y3 ) ; float A1 = area ( x , y , x1 , y1 , x2 , y2 ) ; float A2 = area ( x , y , x2 , y2 , x3 , y3 ) ; float A3 = area ( x , y , x3 , y3 , x4 , y4 ) ; float A4 = area ( x , y , x1 , y1 , x4 , y4 ) ; return ( A == A1 + A2 + A3 + A4 ) ; } public static void main ( String [ ] args ) { if ( check ( 0 , 10 , 10 , 0 , 0 , - 10 , - 10 , 0 , 10 , 15 ) ) System . out . print ( " yes " ) ; else System . out . print ( " no " ) ; } }
class GFG { static int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; } public static void main ( String arg [ ] ) { System . out . print ( findMaximumPieces ( 3 ) ) ; } }
class GFG { static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int mat [ ] [ ] = new int [ 2 ] [ W + 1 ] ; int i = 0 ; while ( i < n ) { int j = 0 ; if ( i % 2 != 0 ) { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; } else { mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; } else { mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } } i ++ ; } return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; } public static void main ( String [ ] args ) { int val [ ] = { 7 , 8 , 4 } , wt [ ] = { 3 , 8 , 6 } , W = 10 , n = 3 ; System . out . println ( KnapSack ( val , wt , n , W ) ) ; } }
import java . util . Arrays ; class GFG { static void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } static void findNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; reverse ( arr ) ; int freq [ ] = new int [ arr [ 0 ] + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int size = ( int ) Math . sqrt ( n ) ; int brr [ ] = new int [ size ] , x , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] ] > 0 && l < size ) { brr [ l ] = arr [ i ] ; freq [ brr [ l ] ] -- ; l ++ ; for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) { x = __gcd ( arr [ i ] , brr [ j ] ) ; freq [ x ] -= 2 ; } } } } printArr ( brr , size ) ; } public static void reverse ( int [ ] input ) { int last = input . length - 1 ; int middle = input . length / 2 ; for ( int i = 0 ; i <= middle ; i ++ ) { int temp = input [ i ] ; input [ i ] = input [ last - i ] ; input [ last - i ] = temp ; } } static int __gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5 , 5 , 5 , 7 , 10 , 12 , 2 , 2 } ; int n = arr . length ; findNumbers ( arr , n ) ; } }
import java . util . * ; class GFG { static void AlternateRearrange ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . add ( arr [ i ] ) ; else v2 . add ( arr [ i ] ) ; int index = 0 , i = 0 , j = 0 ; boolean flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ] = ( int ) v1 . get ( i ) ; i += 1 ; index += 1 ; flag = ! flag ; } else { arr [ index ] = ( int ) v2 . get ( j ) ; j += 1 ; index += 1 ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 8 , 13 , 2 , 19 , 14 } ; int n = arr . length ; AlternateRearrange ( arr , n ) ; } }
import java . util . * ; public class GFG { static int getNumToAdd ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; int numToAdd = - 1 ; boolean numAdded = false ; for ( int i = 2 ; i < n ; i ++ ) { int diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return - 1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return - 1 ; } } if ( numToAdd == - 1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 11 , 13 , 15 } ; int n = arr . length ; System . out . println ( getNumToAdd ( arr , n ) ) ; } }
import java . util . Arrays ; import java . io . * ; class GFG { static int items ( int n , int a [ ] ) { Arrays . sort ( a ) ; int z = a [ n - 1 ] ; int x = 1 ; int s = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; } public static void main ( String [ ] args ) { int n = 5 ; int a [ ] = { 5 , 3 , 1 , 5 , 6 } ; System . out . println ( items ( n , a ) ) ; } }
import java . util . * ; class solution { static int numBoxes ( int A [ ] , int n , int K ) { Arrays . sort ( A ) ; int i = 0 , j = n - 1 ; int ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; } public static void main ( String args [ ] ) { int A [ ] = { 3 , 2 , 2 , 1 } , K = 3 ; int n = A . length ; System . out . println ( numBoxes ( A , n , K ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int solve ( int N , int M , int cp [ ] , int sp [ ] ) { Integer [ ] profit = new Integer [ N ] ; for ( int i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; Arrays . sort ( profit , Collections . reverseOrder ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; } public static void main ( String args [ ] ) { int N = 5 , M = 3 ; int CP [ ] = { 5 , 10 , 35 , 7 , 23 } ; int SP [ ] = { 11 , 10 , 0 , 9 , 19 } ; System . out . println ( solve ( N , M , CP , SP ) ) ; } }
import java . * ; import java . util . Arrays ; class GFG { static int findMaxNum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int num = arr [ 0 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { num = num * 10 + arr [ i ] ; } return num ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 0 } ; int n = arr . length ; System . out . println ( findMaxNum ( arr , n ) ) ; } }
import java . util . Arrays ; class GFG { static int minimumSets ( int arr [ ] , int n , int key ) { int i , j ; Arrays . sort ( arr ) ; for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 5 , 3 , 4 } ; int n = arr . length ; int key = 5 ; System . out . println ( minimumSets ( arr , n , key ) ) ; } }
import java . util . LinkedList ; import java . util . Queue ; import java . util . Arrays ; public class GFG { static int minimumBox ( int [ ] arr , int n ) { Queue < Integer > q = new LinkedList < > ( ) ; Arrays . sort ( arr ) ; q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . element ( ) ; if ( arr [ i ] >= 2 * now ) q . remove ( ) ; q . add ( arr [ i ] ) ; } return q . size ( ) ; } public static void main ( String args [ ] ) { int [ ] arr = { 4 , 1 , 2 , 8 } ; int n = arr . length ; System . out . println ( minimumBox ( arr , n ) ) ; } }
import java . util . * ; class GFG { static void sortBinaryArray ( int a [ ] , int n ) { int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; int temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 } ; int n = a . length ; sortBinaryArray ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } }
public class GFG { static final int MAX = 1000 ; static int findDuplicate ( int arr [ ] , int n , int k ) { int res = MAX + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) count += 1 ; if ( count == k ) res = Math . min ( res , arr [ i ] ) ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = arr . length ; System . out . println ( findDuplicate ( arr , n , k ) ) ; } }
import java . util . Arrays ; public class GFG { static int findDuplicate ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < n ) { int j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = arr . length ; System . out . println ( findDuplicate ( arr , n , k ) ) ; } }
class Main { static boolean checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 3 , 2 } ; int n = arr . length ; if ( checkForSorting ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Arrays ; import java . io . * ; class GFG { static int ksmallest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; } public static void main ( String [ ] args ) { int k = 1 ; int arr [ ] = { 1 } ; int n = arr . length ; System . out . println ( ksmallest ( arr , n , k ) ) ; } }
class GFG { public static boolean isEven ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; } return true ; else return false ; } public static void main ( String [ ] args ) { int n = 101 ; if ( isEven ( n ) == true ) System . out . print ( " Even " ) ; else System . out . print ( " Odd " ) ; } }
import java . io . * ; class GFG { static int findSubsequenceCount ( String S , String T ) { int m = T . length ( ) ; int n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; } public static void main ( String [ ] args ) { String T = " ge " ; String S = " geeksforgeeks " ; System . out . println ( findSubsequenceCount ( S , T ) ) ; } }
using System ; using System . Collections ; class GfG { class GFG { public static String Check ( int a [ ] [ ] , int b [ ] [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( a [ i ] [ j ] > b [ i ] [ j ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = b [ i ] [ j ] ; b [ i ] [ j ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m - 1 ; j ++ ) if ( a [ i ] [ j ] >= a [ i ] [ j + 1 ] b [ i ] [ j ] >= b [ i ] [ j + 1 ] ) return " No " ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( a [ i ] [ j ] >= a [ i + 1 ] [ j ] b [ i ] [ j ] >= b [ i + 1 ] [ j ] ) return " No " ; return " Yes " ; } public static void main ( String [ ] args ) { int n = 2 , m = 2 ; int a [ ] [ ] = { { 2 , 10 } , { 11 , 5 } } ; int b [ ] [ ] = { { 9 , 4 } , { 3 , 12 } } ; System . out . print ( Check ( a , b , n , m ) ) ; } }
class GFG { static String smallestString ( int N , int [ ] A ) { char ch = ' a ' ; String S = " " ; if ( N < 1 A [ 0 ] != 1 ) { S = " - 1" ; return S ; } S += ch ; ch ++ ; for ( int i = 1 ; i < N ; i ++ ) { int diff = A [ i ] - A [ i - 1 ] ; if ( diff > 1 diff < 0 A [ i ] > 26 ) { S = " - 1" ; return S ; } else if ( diff == 0 ) S += ' a ' ; else { S += ch ; ch ++ ; } } return S ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 1 , 2 , 3 , 3 } ; int n = arr . length ; System . out . println ( smallestString ( n , arr ) ) ; } }
class GFG { static boolean canBePicked ( int digits [ ] , int num ) { int copyDigits [ ] = digits . clone ( ) ; while ( num > 0 ) { int digit = num % 10 ; if ( copyDigits [ digit ] == 0 ) return false ; else copyDigits [ digit ] -- ; num /= 10 ; } return true ; } static int countAlphabets ( int n ) { int i , count = 0 ; int digits [ ] = new int [ 10 ] ; while ( n > 0 ) { int digit = n % 10 ; digits [ digit ] ++ ; n /= 10 ; } for ( i = ' a ' ; i <= ' z ' ; i ++ ) if ( canBePicked ( digits , i ) ) count ++ ; for ( i = ' A ' ; i <= ' Z ' ; i ++ ) if ( canBePicked ( digits , i ) ) count ++ ; return count ; } public static void main ( String [ ] args ) { int n = 1623455078 ; System . out . println ( countAlphabets ( n ) ) ; } }
import java . util . * ; class Solution { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static void findTwoNumbers ( int sum , int gcd ) { if ( __gcd ( gcd , sum - gcd ) == gcd && sum != gcd ) System . out . println ( " a ▁ = ▁ " + Math . min ( gcd , sum - gcd ) + " , ▁ b ▁ = ▁ " + ( int ) ( sum - Math . min ( gcd , sum - gcd ) ) ) ; else System . out . println ( - 1 ) ; } public static void main ( String args [ ] ) { int sum = 8 ; int gcd = 2 ; findTwoNumbers ( sum , gcd ) ; } }
import java . util . * ; class GFG { static int findMaxDistance ( int numOfCities , int station [ ] , int n ) { boolean hasStation [ ] = new boolean [ numOfCities + 1 ] ; for ( int city = 0 ; city < n ; city ++ ) { hasStation [ station [ city ] ] = true ; } int dist = 0 ; int maxDist = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { maxDist = Math . min ( station [ i ] , maxDist ) ; } for ( int city = 0 ; city < numOfCities ; city ++ ) { if ( hasStation [ city ] == true ) { maxDist = Math . max ( ( dist + 1 ) / 2 , maxDist ) ; dist = 0 ; } else dist += 1 ; } return Math . max ( maxDist , dist ) ; } public static void main ( String args [ ] ) { int numOfCities = 6 ; int station [ ] = { 3 , 1 } ; int n = station . length ; System . out . println ( " Max ▁ Distance : " + findMaxDistance ( numOfCities , station , n ) ) ; } }
class GFG { static void split ( int x , int n ) { if ( x < n ) System . out . print ( " - 1 ▁ " ) ; else if ( x % n == 0 ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ( x / n ) + " ▁ " ) ; } else { int zp = n - ( x % n ) ; int pp = x / n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i >= zp ) System . out . print ( ( pp + 1 ) + " ▁ " ) ; else System . out . print ( pp + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int x = 5 ; int n = 3 ; split ( x , n ) ; } }
class GFG { static long cal_minimum_time ( long X ) { long t = 0 ; long sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; } public static void main ( String [ ] args ) { long n = 6 ; long ans = cal_minimum_time ( n ) ; System . out . println ( " The ▁ minimum ▁ time ▁ required ▁ is ▁ : ▁ " + ans ) ; } }
import java . io . * ; class GFG { static int solve ( int [ ] [ ] v , int n ) { int ans , ul , ll ; int first = 0 ; int second = 1 ; ll = v [ 0 ] [ first ] ; ul = v [ 0 ] [ second ] ; ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( v [ i ] [ first ] <= ul && v [ i ] [ first ] >= ll ) || ( v [ i ] [ second ] >= ll && v [ i ] [ second ] <= ul ) ) { if ( v [ i ] [ first ] > ll ) { ll = v [ i ] [ first ] ; } if ( v [ i ] [ second ] < ul ) { ul = v [ i ] [ second ] ; } } else if ( v [ i ] [ first ] > ul ) { ans += Math . abs ( ul - v [ i ] [ first ] ) ; ul = v [ i ] [ first ] ; ll = v [ i ] [ first ] ; } else if ( v [ i ] [ second ] < ll ) { ans += Math . abs ( ll - v [ i ] [ second ] ) ; ul = v [ i ] [ second ] ; ll = v [ i ] [ second ] ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] [ ] v = { { 1 , 3 } , { 2 , 5 } , { 6 , 8 } , { 1 , 2 } , { 2 , 3 } } ; int n = 5 ; System . out . println ( solve ( v , n ) ) ; } }
import java . util . * ; class GFG { static Vector < String > preProcess ( int n ) { Vector < String > preProcessedCubes = new Vector < > ( ) ; for ( int i = 1 ; i * i * i <= n ; i ++ ) { int iThCube = i * i * i ; String cubeString = String . valueOf ( iThCube ) ; preProcessedCubes . add ( cubeString ) ; } return preProcessedCubes ; } static String findLargestCubeUtil ( String num , Vector < String > preProcessedCubes ) { Collections . reverse ( preProcessedCubes ) ; int totalCubes = preProcessedCubes . size ( ) ; for ( int i = 0 ; i < totalCubes ; i ++ ) { String currCube = preProcessedCubes . get ( i ) ; int digitsInCube = currCube . length ( ) ; int index = 0 ; int digitsInNumber = num . length ( ) ; for ( int j = 0 ; j < digitsInNumber ; j ++ ) { if ( num . charAt ( j ) == currCube . charAt ( index ) ) { index ++ ; } if ( digitsInCube == index ) { return currCube ; } } } return " Not ▁ Possible " ; } static void findLargestCube ( int n ) { Vector < String > preProcessedCubes = preProcess ( n ) ; String num = String . valueOf ( n ) ; String ans = findLargestCubeUtil ( num , preProcessedCubes ) ; System . out . println ( " Largest ▁ Cube ▁ that ▁ can ▁ be ▁ formed ▁ from ▁ " + n + " ▁ is ▁ " + ans ) ; } public static void main ( String [ ] args ) { int n ; n = 4125 ; findLargestCube ( n ) ; n = 876 ; findLargestCube ( n ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static String noAdjacentDup ( String s1 ) { int n = s1 . length ( ) ; char [ ] s = s1 . toCharArray ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( new String ( s ) ) ; } public static void main ( String argc [ ] ) { String s = " geeksforgeeks " ; System . out . println ( noAdjacentDup ( s ) ) ; } }
import java . io . * ; class GFG { static int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; } public static void main ( String args [ ] ) { int a [ ] = { 2 , 1 , 3 , 4 , 5 } ; int n = a . length ; int k = 2 ; System . out . println ( winner ( a , n , k ) ) ; } }
import java . io . * ; class GFG { static int MAX = 100000 ; static int bitscount = 32 ; static int [ ] [ ] prefix_count = new int [ bitscount ] [ MAX ] ; static void findPrefixCount ( int arr [ ] , int n ) { for ( int i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] ; } } } static int rangeOr ( int l , int r ) { int ans = 0 ; for ( int i = 0 ; i < bitscount ; i ++ ) { int x ; if ( l == 0 ) x = prefix_count [ i ] [ r ] ; else x = prefix_count [ i ] [ r ] - prefix_count [ i ] [ l - 1 ] ; if ( x != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 5 , 3 , 5 , 2 , 3 } ; int n = arr . length ; findPrefixCount ( arr , n ) ; int queries [ ] [ ] = { { 1 , 3 } , { 4 , 5 } } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( rangeOr ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; } }
class GFG { static void BellmanFord ( int graph [ ] [ ] , int V , int E , int src ) { int [ ] dis = new int [ V ] ; for ( int i = 0 ; i < V ; i ++ ) dis [ i ] = Integer . MAX_VALUE ; dis [ src ] = 0 ; for ( int i = 0 ; i < V - 1 ; i ++ ) { for ( int j = 0 ; j < E ; j ++ ) { if ( dis [ graph [ j ] [ 0 ] ] != Integer . MAX_VALUE && dis [ graph [ j ] [ 0 ] ] + graph [ j ] [ 2 ] < dis [ graph [ j ] [ 1 ] ] ) dis [ graph [ j ] [ 1 ] ] = dis [ graph [ j ] [ 0 ] ] + graph [ j ] [ 2 ] ; } } for ( int i = 0 ; i < E ; i ++ ) { int x = graph [ i ] [ 0 ] ; int y = graph [ i ] [ 1 ] ; int weight = graph [ i ] [ 2 ] ; if ( dis [ x ] != Integer . MAX_VALUE && dis [ x ] + weight < dis [ y ] ) System . out . println ( " Graph ▁ contains ▁ negative " + " ▁ weight ▁ cycle " ) ; } System . out . println ( " Vertex ▁ Distance ▁ from ▁ Source " ) ; for ( int i = 0 ; i < V ; i ++ ) System . out . println ( i + " TABSYMBOL TABSYMBOL " + dis [ i ] ) ; } public static void main ( String [ ] args ) { int graph [ ] [ ] = { { 0 , 1 , - 1 } , { 0 , 2 , 4 } , { 1 , 2 , 3 } , { 1 , 3 , 2 } , { 1 , 4 , 2 } , { 3 , 2 , 5 } , { 3 , 1 , 1 } , { 4 , 3 , - 3 } } ; BellmanFord ( graph , V , E , 0 ) ; } }
class GFG { static int maxn = 16 ; static int [ ] precompute ( ) { int dp [ ] = new int [ maxn ] , arr [ ] = { 4 , 6 , 9 } ; for ( int i = 0 ; i < maxn ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < maxn ; ++ i ) { for ( int k = 0 ; k < 3 ; k ++ ) { int j = arr [ k ] ; if ( i >= j && dp [ i - j ] != - 1 ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } } return dp ; } static int Maximum_Summands ( int [ ] dp , int n ) { if ( n < maxn ) return dp [ n ] ; else { int t = ( n - maxn ) / 4 + 1 ; return t + dp [ n - 4 * t ] ; } } public static void main ( String args [ ] ) { int n = 12 ; int [ ] dp = precompute ( ) ; System . out . println ( Maximum_Summands ( dp , n ) ) ; } }
class GfG { static int N = 4 ; static int getSum ( int r1 , int r2 , int c1 , int c2 , int dp [ ] [ ] ) { return dp [ r2 ] [ c2 ] - dp [ r2 ] [ c1 ] - dp [ r1 ] [ c2 ] + dp [ r1 ] [ c1 ] ; } static boolean sumFound ( int K , int S , int grid [ ] [ ] ) { int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] - dp [ i ] [ j ] + grid [ i ] [ j ] ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int sum = getSum ( i , i + K , j , j + K , dp ) ; if ( sum == S ) { return true ; } } } return false ; } public static void main ( String [ ] args ) { int grid [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int K = 2 ; int S = 14 ; if ( sumFound ( K , S , grid ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class GFG { static int findMinOperations ( String S ) { S = reverse ( S ) ; int n = S . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ 2 ] ; if ( S . charAt ( 0 ) == '0' ) { dp [ 0 ] [ 0 ] = 0 ; } else { dp [ 0 ] [ 0 ] = 1 ; } dp [ 0 ] [ 1 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S . charAt ( i ) == '0' ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = 1 + Math . min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] ) ; } else { dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] = 1 + Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; } } return dp [ n - 1 ] [ 0 ] ; } static String reverse ( String input ) { char [ ] temparray = input . toCharArray ( ) ; int left , right = 0 ; right = temparray . length - 1 ; for ( left = 0 ; left < right ; left ++ , right -- ) { char temp = temparray [ left ] ; temparray [ left ] = temparray [ right ] ; temparray [ right ] = temp ; } return String . valueOf ( temparray ) ; } public static void main ( String [ ] args ) { String S = "100" ; System . out . println ( findMinOperations ( S ) ) ; S = "111" ; System . out . println ( findMinOperations ( S ) ) ; } }
public class GFG { static void solve ( int N , int K ) { int Array [ ] = new int [ N + 1 ] ; if ( N <= K ) { System . out . println ( "1" ) ; return ; } int i = 0 ; int sum = K ; for ( i = 1 ; i <= K ; ++ i ) { Array [ i ] = 1 ; } Array [ i ] = sum ; for ( i = K + 2 ; i <= N ; ++ i ) { Array [ i ] = sum - Array [ i - K - 1 ] + Array [ i - 1 ] ; sum = Array [ i ] ; } System . out . println ( Array [ N ] ) ; } public static void main ( String args [ ] ) { int N = 4 , K = 2 ; solve ( N , K ) ; } }
public class GFG { final static int MAX_VAL = 10000000 ; static int dp [ ] [ ] = new int [ 100 ] [ 100 ] ; static int find ( int index , int openbrk , int n , int adj [ ] [ ] ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != - 1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = Math . min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; } public static void main ( String args [ ] ) { int n = 4 ; int adj [ ] [ ] = { { 5000 , 3000 } , { 6000 , 2000 } , { 8000 , 1000 } , { 9000 , 6000 } } ; for ( int i = 0 ; i < dp . length ; i ++ ) for ( int j = 0 ; j < dp . length ; j ++ ) dp [ i ] [ j ] = - 1 ; System . out . println ( find ( 1 , 1 , n , adj ) + adj [ 0 ] [ 1 ] ) ; } }
import java . util . * ; import java . lang . Math ; class GFG { public static int find ( int start , String adj , int n , int dp [ ] ) { if ( start == n ) return 0 ; if ( dp [ start ] != - 1 ) return dp [ start ] ; dp [ start ] = 0 ; int one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj . charAt ( k ) == '1' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; } public static void main ( String [ ] args ) { String adj = "100110001010001" ; int n = adj . length ( ) ; int dp [ ] = new int [ n + 1 ] ; Arrays . fill ( dp , - 1 ) ; System . out . println ( find ( 0 , adj , n , dp ) ) ; } }
class GFG { static boolean isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; return false ; } static int lcs ( String X , String Y , int m , int n ) { int L [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) && isVowel ( X . charAt ( i - 1 ) ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } public static void main ( String [ ] args ) { String X = " aieef " ; String Y = " klaief " ; int m = X . length ( ) ; int n = Y . length ( ) ; System . out . println ( " Length ▁ of ▁ LCS ▁ = ▁ " + lcs ( X , Y , m , n ) ) ; } }
class Geeks { static boolean check ( int i , int val ) { if ( i - val < 0 ) return false ; else return true ; } static double MinimumPrimes ( int n ) { double [ ] dp ; dp = new double [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 1e9 ; dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( check ( i , 2 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 2 ] ) ; if ( check ( i , 3 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 3 ] ) ; if ( check ( i , 5 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 5 ] ) ; if ( check ( i , 7 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 7 ] ) ; } if ( dp [ n ] == ( 1e9 ) ) return - 1 ; else return dp [ n ] ; } public static void main ( String args [ ] ) { int n = 12 ; int minimal = ( int ) MinimumPrimes ( n ) ; if ( minimal != - 1 ) System . out . println ( " Minimum ▁ number ▁ of ▁ single ▁ " + " digit ▁ primes ▁ required : ▁ " + minimal ) ; else System . out . println ( " Not ▁ Possible " ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int numberOfBST ( int n ) { int dp [ ] = new int [ n + 1 ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { dp [ i ] = dp [ i ] + ( dp [ i - j ] * dp [ j - 1 ] ) ; } } return dp [ n ] ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( " Number ▁ of ▁ structurally ▁ " + " Unique ▁ BST ▁ with ▁ " + n + " ▁ keys ▁ are ▁ : ▁ " + numberOfBST ( n ) ) ; } }
import java . io . * ; class GFG { static int MAX = 100 ; static int summation ( int n ) { return n << ( n - 1 ) ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( summation ( n ) ) ; } }
class GFG { static int findMaxProduct ( int arr [ ] , int n ) { int i ; int ans = Integer . MIN_VALUE ; int maxval = 1 ; int minval = 1 ; int prevMax ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ] ; minval = Math . min ( 1 , minval * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { minval = 1 ; maxval = 0 ; } else if ( arr [ i ] < 0 ) { prevMax = maxval ; maxval = minval * arr [ i ] ; minval = prevMax * arr [ i ] ; } ans = Math . max ( ans , maxval ) ; if ( maxval <= 0 ) { maxval = 1 ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , - 4 , 0 , - 2 } ; int n = arr . length ; System . out . println ( findMaxProduct ( arr , n ) ) ; } }
import java . io . * ; import java . lang . * ; public class GFG { static double INF = 1e9 ; static int MAX = 50 ; static void minMaxValues ( int [ ] arr , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } boolean dp [ ] [ ] = new boolean [ MAX + 1 ] [ MAX * MAX + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { for ( int k = Math . min ( n , i + 1 ) ; k >= 1 ; k -- ) { for ( int j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ] = true ; } } } double max_value = - 1 * INF , min_value = INF ; for ( int i = 0 ; i < MAX * MAX + 1 ; i ++ ) { if ( dp [ n ] [ i ] ) { int temp = i - 50 * n ; max_value = Math . max ( max_value , temp * ( sum - temp ) ) ; min_value = Math . min ( min_value , temp * ( sum - temp ) ) ; } } System . out . print ( " Maximum ▁ Value : ▁ " + ( int ) max_value + "NEW_LINE" +  " Minimum ▁ Value : ▁ " + ( int ) min_value + "NEW_LINE"); } public static void main ( String args [ ] ) { int n = 2 , m = 2 ; int [ ] arr = { 1 , 2 , 3 , 4 } ; minMaxValues ( arr , n , m ) ; } }
import java . util . * ; class GFG { public static int findGolomb ( int n ) { if ( n == 1 ) return 1 ; return 1 + findGolomb ( n - findGolomb ( findGolomb ( n - 1 ) ) ) ; } public static void printGolomb ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( findGolomb ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 9 ; printGolomb ( n ) ; } }
class GFG { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; System . out . println ( res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { System . out . print ( wt [ i - 1 ] + " ▁ " ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } } public static void main ( String arg [ ] ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; printknapSack ( W , wt , val , n ) ; } }
import java . util . * ; class GFG { static int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 10 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; } public static void main ( String arg [ ] ) { int n = 7 , a = 5 , b = 2 , c = 5 ; System . out . print ( maximumSegments ( n , a , b , c ) ) ; } }
class GFG { public static void sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; System . out . print ( f [ 1 ] + " ▁ " + f [ 2 ] + " ▁ " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; System . out . print ( f [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 13 ; sequence ( n ) ; } }
import java . util . * ; class GFG { static int zigzag ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; } public static void main ( String [ ] args ) { int n = 4 , k = 3 ; System . out . println ( zigzag ( n , k ) ) ; } }
import java . util . * ; class GFG { static int binomialCoeff ( int n , int k ) { int C [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } static int lobb ( int n , int m ) { return ( ( 2 * m + 1 ) * binomialCoeff ( 2 * n , m + n ) ) / ( m + n + 1 ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 3 ; System . out . println ( lobb ( n , m ) ) ; } }
import java . util . * ; class Counting { static int MAXN = 109 ; public static int countarray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; } public static void main ( String [ ] args ) { int n = 4 , k = 3 , x = 2 ; System . out . println ( countarray ( n , k , x ) ) ; } }
class GFG { static final int MAX = 100 ; static final int MAX_CHAR = 26 ; static void precompute ( String s , int n , int l [ ] [ ] , int r [ ] [ ] ) { l [ s . charAt ( 0 ) - ' a ' ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) l [ j ] [ i ] += l [ j ] [ i - 1 ] ; l [ s . charAt ( i ) - ' a ' ] [ i ] ++ ; } r [ s . charAt ( n - 1 ) - ' a ' ] [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) r [ j ] [ i ] += r [ j ] [ i + 1 ] ; r [ s . charAt ( i ) - ' a ' ] [ i ] ++ ; } } static int countPalindromes ( int k , int n , int l [ ] [ ] , int r [ ] [ ] ) { int ans = 0 ; if ( k == 1 ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += l [ i ] [ n - 1 ] ; return ans ; } if ( k == 2 ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += ( ( l [ i ] [ n - 1 ] * ( l [ i ] [ n - 1 ] - 1 ) ) / 2 ) ; return ans ; } for ( int i = 1 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < MAX_CHAR ; j ++ ) ans += l [ j ] [ i - 1 ] * r [ j ] [ i + 1 ] ; return ans ; } public static void main ( String [ ] args ) { String s = " aabab " ; int k = 2 ; int n = s . length ( ) ; int l [ ] [ ] = new int [ MAX_CHAR ] [ MAX ] ; int r [ ] [ ] = new int [ MAX_CHAR ] [ MAX ] ; precompute ( s , n , l , r ) ; System . out . println ( countPalindromes ( k , n , l , r ) ) ; } }
import java . io . * ; class MaxSumPath { static int maxSum ( int [ ] [ ] mat , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ ] [ ] = new int [ n ] [ n ] ; int maxSum = Integer . MIN_VALUE , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = Integer . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 5 , 6 , 1 , 7 } , { - 2 , 10 , 8 , - 1 } , { 3 , - 7 , - 9 , 11 } , { 12 , - 4 , 2 , 6 } } ; int n = 4 ; System . out . println ( " Maximum ▁ Sum ▁ = ▁ " + maxSum ( mat , n ) ) ; } }
import java . util . * ; class GFG { static String longestRepeatedSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; String res = " " ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str . charAt ( i - 1 ) ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } String reverse = " " ; for ( int k = res . length ( ) - 1 ; k >= 0 ; k -- ) { reverse = reverse + res . charAt ( k ) ; } return reverse ; } public static void main ( String args [ ] ) { String str = " AABEBCDD " ; System . out . println ( longestRepeatedSubSeq ( str ) ) ; } }
import java . util . Arrays ; public class GFG { static boolean ElementsCalculationFunc ( int pre [ ] , int maxx [ ] , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; } static void MaxNumberOfElements ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; for ( int i = 0 ; i <= n ; ++ i ) { pre [ i ] = 0 ; maxx [ i ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] ; maxx [ i ] = Math . max ( maxx [ i - 1 ] , a [ i - 1 ] ) ; } int l = 1 , r = n , ans = 0 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( ElementsCalculationFunc ( pre , maxx , mid - 1 , k , n ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; } System . out . print ( ( int ) ans + "NEW_LINE"); } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 4 , 9 } ; int n = arr . length ; int k = 3 ; MaxNumberOfElements ( arr , n , k ) ; } }
public class GFG { static final int MAX = 50 ; static int solve ( int dp [ ] [ ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) { return a [ low ] * turn ; } if ( dp [ low ] [ high ] != 0 ) { return dp [ low ] [ high ] ; } dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 1 , 5 , 2 } ; int n = arr . length ; int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; System . out . println ( solve ( dp , arr , 0 , n - 1 , 1 ) ) ; } }
class GFG { static int maxSumBitonicSubArr ( int arr [ ] , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = Integer . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 9 , 2 , 7 , 6 , 4 } ; int n = arr . length ; System . out . println ( " Maximum ▁ Sum ▁ = ▁ " + maxSumBitonicSubArr ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int countWays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; } public static void main ( String [ ] args ) { int n = 7 ; int m = 4 ; System . out . println ( " Number ▁ of ▁ ways ▁ = ▁ " + countWays ( n , m ) ) ; } }
import java . io . * ; class GFG { static int MAX = 100 ; static int largestZigZagSumRec ( int mat [ ] [ ] , int i , int j , int n ) { if ( i == n - 1 ) return mat [ i ] [ j ] ; int zzs = 0 ; for ( int k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = Math . max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return zzs + mat [ i ] [ j ] ; } static int largestZigZag ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int j = 0 ; j < n ; j ++ ) res = Math . max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; } public static void main ( String [ ] args ) { int n = 3 ; int mat [ ] [ ] = { { 4 , 2 , 1 } , { 3 , 9 , 6 } , { 11 , 3 , 15 } } ; System . out . println ( " Largest ▁ zigzag ▁ sum : ▁ " + largestZigZag ( mat , n ) ) ; } }
import java . io . * ; class GFG { static int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countStr ( n , 1 , 2 ) ) ; } }
import java . util . * ; class GFG { static int N = 4 ; static int MaximumPath ( int Mat [ ] [ ] ) { int result = 0 ; int dp [ ] [ ] = new int [ N ] [ N + 2 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; } public static void main ( String arg [ ] ) { int Mat [ ] [ ] = { { 4 , 2 , 3 , 4 } , { 2 , 9 , 1 , 10 } , { 15 , 1 , 3 , 0 } , { 16 , 92 , 41 , 44 } } ; System . out . println ( MaximumPath ( Mat ) ) ; } }
import java . math . * ; class GFG { static int MAX = 100001 ; static double dp [ ] = new double [ MAX ] ; static double probability ( int k , int n ) { double ans = 0.0 ; for ( int i = k ; i <= n ; ++ i ) { double res = dp [ n ] - dp [ i ] - dp [ n - i ] - n ; ans += Math . pow ( 2.0 , res ) ; } return ans ; } static void precompute ( ) { for ( int i = 2 ; i < MAX ; ++ i ) dp [ i ] = ( Math . log ( i ) / Math . log ( 2 ) ) + dp [ i - 1 ] ; } public static void main ( String args [ ] ) { precompute ( ) ; System . out . println ( probability ( 2 , 3 ) ) ; System . out . println ( probability ( 3 , 6 ) ) ; System . out . println ( probability ( 500 , 1000 ) ) ; } }
import java . util . * ; class GFG { static void printMaxSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 1 , 4 , 6 , 5 } ; int n = arr . length ; printMaxSum ( arr , n ) ; } }
public class GFG { static int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( min > arr [ i ] ) min = arr [ i ] ; } if ( min == arr [ 0 ] ) { return arr [ 0 ] ; } int dec [ ] = new int [ n ] ; int inc [ ] = new int [ n ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 2 , 3 , 5 , 7 , 9 , 10 } ; System . out . println ( " Maximum ▁ sum ▁ = ▁ " + maxAlternateSum ( arr , arr . length ) ) ; } }
import java . io . * ; class GFG { static int pad ( int n ) { padv [ 0 ] = padv [ 1 ] = padv [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { padv [ i ] = padv [ i - 2 ] + padv [ i - 3 ] ; } return padv [ n - 1 ] ; } public static void main ( String args [ ] ) { int n = 12 ; System . out . println ( pad ( n ) ) ; } }
class GFG { static int lucas ( int n ) { int a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; } public static void main ( String args [ ] ) { int n = 9 ; System . out . println ( lucas ( n ) ) ; } }
import java . io . * ; class GFG { final int MAX = 1000000 ; static int breakSum ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; } public static void main ( String [ ] args ) { int n = 24 ; System . out . println ( breakSum ( n ) ) ; } }
import java . io . * ; class GFG { static int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + Math . min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 10 , 5 , 2 , 7 , 10 } ; int n1 = arr1 . length ; System . out . println ( minTime ( arr1 , n1 ) ) ; int arr2 [ ] = { 10 , 5 , 7 , 10 } ; int n2 = arr2 . length ; System . out . println ( minTime ( arr2 , n2 ) ) ; int arr3 [ ] = { 10 , 5 , 2 , 4 , 8 , 6 , 7 , 10 } ; int n3 = arr3 . length ; System . out . println ( minTime ( arr3 , n3 ) ) ; } }
import java . io . * ; class GFG { static void multiply ( int a [ ] [ ] , int b [ ] [ ] ) { int mul [ ] [ ] = new int [ 3 ] [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { mul [ i ] [ j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; } } for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) a [ i ] [ j ] = mul [ i ] [ j ] ; } static int power ( int F [ ] [ ] , int n ) { int M [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 1 ) return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ; return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; } static int findNthTerm ( int n ) { int F [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; return power ( F , n - 2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( " F ( 5 ) ▁ is ▁ " + findNthTerm ( n ) ) ; } }
import java . io . * ; class Grid { static int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( " Count ▁ of ▁ ways ▁ is : ▁ " + count ( n ) ) ; } }
import java . io . * ; class GFG { static int bellNumber ( int n ) { int [ ] [ ] bell = new int [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; } public static void main ( String [ ] args ) { for ( int n = 0 ; n <= 5 ; n ++ ) System . out . println ( " Bell ▁ Number ▁ " + n + " ▁ is ▁ " + bellNumber ( n ) ) ; } }
import java . io . * ; class GFG { static int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; } public static void main ( String [ ] args ) { int dist = 4 ; System . out . println ( printCountDP ( dist ) ) ; } }
class GFG { static int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . print ( " Count ▁ of ▁ sequences ▁ is ▁ " ) ; System . out . println ( countSeq ( n ) ) ; } }
class GFG { static int min ( int a , int b ) { return ( a < b ) ? a : b ; } static int min ( int arr [ ] , int l , int h ) { int mn = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) { if ( mn > arr [ i ] ) { mn = arr [ i ] ; } } return mn ; } static int max ( int arr [ ] , int l , int h ) { int mx = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) { if ( mx < arr [ i ] ) { mx = arr [ i ] ; } } return mx ; } static int minRemovalsDP ( int arr [ ] , int n ) { int table [ ] [ ] = new int [ n ] [ n ] , gap , i , j , mn , mx ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { mn = min ( arr , i , j ) ; mx = max ( arr , i , j ) ; table [ i ] [ j ] = ( 2 * mn > mx ) ? 0 : min ( table [ i ] [ j - 1 ] + 1 , table [ i + 1 ] [ j ] + 1 ) ; } } return table [ 0 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 4 , 1 , 3 } ; int n = arr . length ; System . out . println ( minRemovalsDP ( arr , n ) ) ; } }
class GFG { static int numberOfPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; } public static void main ( String args [ ] ) { System . out . println ( numberOfPaths ( 3 , 3 ) ) ; } }
class GFG { static int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; } public static void main ( String [ ] args ) { System . out . println ( numberOfPaths ( 3 , 3 ) ) ; } }
import java . io . * ; class GFG { static int lenghtOfLongestAP ( int set [ ] , int n ) { if ( n <= 2 ) return n ; int L [ ] [ ] = new int [ n ] [ n ] ; int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 1 ; j -- ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2 ; i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = Math . max ( llap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i ] [ j ] = 2 ; i -- ; } } return llap ; } public static void main ( String [ ] args ) { int set1 [ ] = { 1 , 7 , 10 , 13 , 14 , 19 } ; int n1 = set1 . length ; System . out . println ( lenghtOfLongestAP ( set1 , n1 ) ) ; int set2 [ ] = { 1 , 7 , 10 , 15 , 27 , 29 } ; int n2 = set2 . length ; System . out . println ( lenghtOfLongestAP ( set2 , n2 ) ) ; int set3 [ ] = { 2 , 4 , 6 , 8 , 10 } ; int n3 = set3 . length ; System . out . println ( lenghtOfLongestAP ( set3 , n3 ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class LBS { static int lbs ( int arr [ ] , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 } ; int n = arr . length ; System . out . println ( " Length ▁ of ▁ LBS ▁ is ▁ " + lbs ( arr , n ) ) ; } }
class EggDrop { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int eggDrop ( int n , int k ) { int eggFloor [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = Integer . MAX_VALUE ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; } public static void main ( String args [ ] ) { int n = 2 , k = 10 ; System . out . println ( " Minimum ▁ number ▁ of ▁ trials ▁ in ▁ worst " + " ▁ case ▁ with ▁ " + n + " ▁ eggs ▁ and ▁ " + k + " ▁ floors ▁ is ▁ " + eggDrop ( n , k ) ) ; } }
class Knapsack { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } public static void main ( String args [ ] ) { int val [ ] = new int [ ] { 60 , 100 , 120 } ; int wt [ ] = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; System . out . println ( knapSack ( W , wt , val , n ) ) ; } }
import java . io . * ; class GFG { static int factorial ( int n ) { int res = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { res *= i ; } return res ; } static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static int catalan ( int n ) { int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } static int countBST ( int n ) { int count = catalan ( n ) ; return count ; } static int countBT ( int n ) { int count = catalan ( n ) ; return count * factorial ( n ) ; } public static void main ( String [ ] args ) { int count1 , count2 , n = 5 ; count1 = countBST ( n ) ; count2 = countBT ( n ) ; System . out . println ( " Count ▁ of ▁ BST ▁ with ▁ " + n + " ▁ nodes ▁ is ▁ " + count1 ) ; System . out . println ( " Count ▁ of ▁ binary ▁ " + " trees ▁ with ▁ " + n + " ▁ nodes ▁ is ▁ " + count2 ) ; } }
import java . util . Vector ; class GFG { static void printPermutation ( int N , int K ) { Vector < Integer > res = new Vector < > ( ) ; int l = 1 , r = N , flag = 0 ; for ( int i = 0 ; i < K ; i ++ ) { if ( flag == 0 ) { res . add ( l ) ; l ++ ; } else { res . add ( r ) ; r -- ; } flag ^= 1 ; } if ( flag != 1 ) { for ( int i = r ; i >= l ; i -- ) { res . add ( i ) ; } } else { for ( int i = l ; i <= r ; i ++ ) { res . add ( i ) ; } } for ( Integer i : res ) { System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 10 , K = 4 ; printPermutation ( N , K ) ; } }
import java . io . * ; class GFG { public static int fact ( int N ) { int i , product = 1 ; for ( i = 1 ; i <= N ; i ++ ) product = product * i ; return product ; } public static int nthTerm ( int N ) { return ( N * N ) * fact ( N ) ; } public static void main ( String [ ] args ) { System . out . println ( nthTerm ( N ) ) ; } }
public class Main { public final static int d = 256 ; static void search ( String pat , String txt , int q ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i , j ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat . charAt ( i ) ) % q ; t = ( d * t + txt . charAt ( i ) ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; } if ( j == M ) System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } if ( i < N - M ) { t = ( d * ( t - txt . charAt ( i ) * h ) + txt . charAt ( i + M ) ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } public static void main ( String [ ] args ) { String txt = " GEEKS ▁ FOR ▁ GEEKS " ; String pat = " GEEK " ; int q = 101 ; search ( pat , txt , q ) ; } }
import java . util . Arrays ; public class Improve { static int number_of_tower ( int house [ ] , int range , int n ) { Arrays . sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; } public static void main ( String args [ ] ) { int house [ ] = { 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 } ; int range = 2 ; int n = house . length ; System . out . println ( number_of_tower ( house , range , n ) ) ; } }
public class GFG { static final int MAX = 1000 ; static int findDuplicate ( int arr [ ] , int n , int k ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { System . out . println ( " Out ▁ of ▁ range " ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = arr . length ; System . out . println ( findDuplicate ( arr , n , k ) ) ; } }
import java . util . Arrays ; class Test { static void pendulumArrangement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int op [ ] = new int [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; System . out . println ( " Pendulum ▁ arrangement : " ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( op [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 14 , 6 , 19 , 21 , 12 } ; pendulumArrangement ( arr , arr . length ) ; } }
public class GFG { static final int MAX = 256 ; static int freq [ ] [ ] ; static void preCalculate ( String str , int n ) { freq [ ( int ) str . charAt ( 0 ) ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str . charAt ( i ) ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = ( char ) j ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } } static int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch ] [ r ] ; else return ( freq [ ( int ) ch ] [ r ] - freq [ ( int ) ch ] [ l - 1 ] ) ; } static String lastNonRepeating ( String str , int n , int l , int r ) { for ( int i = r ; i >= l ; i -- ) { char ch = str . charAt ( i ) ; if ( getFrequency ( ch , l , r ) == 1 ) return ( " " + ch ) ; } return " - 1" ; } public static void main ( String [ ] args ) { String str = " GeeksForGeeks " ; int n = str . length ( ) ; int queries [ ] [ ] = { { 2 , 9 } , { 2 , 3 } , { 0 , 12 } } ; int q = queries . length ; freq = new int [ MAX ] [ n ] ; preCalculate ( str , n ) ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( lastNonRepeating ( str , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; } } }
import java . util . Arrays ; class GFG { static int minCost ( String str , int K ) { int n = str . length ( ) ; int res = 999999999 , count = 0 , a , b ; int cnt [ ] = new int [ 27 ] ; Arrays . fill ( cnt , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) cnt [ str . charAt ( i ) - ' a ' + 1 ] ++ ; for ( int i = 1 ; i < ( 26 - K + 1 ) ; i ++ ) { a = i ; b = i + K ; count = 0 ; for ( int j = 1 ; j <= 26 ; j ++ ) { if ( cnt [ j ] > 0 ) { if ( j >= a && j >= b ) count = count + ( Math . min ( j - b , 25 - j + a + 1 ) ) * cnt [ j ] ; else if ( j <= a && j <= b ) count = count + ( Math . min ( a - j , 25 + j - b + 1 ) ) * cnt [ j ] ; } } res = Math . min ( res , count ) ; } for ( int i = 26 - K + 1 ; i <= 26 ; i ++ ) { a = i ; b = ( i + K ) % 26 ; count = 0 ; for ( int j = 1 ; j <= 26 ; j ++ ) { if ( cnt [ j ] > 0 ) { if ( j >= b && j <= a ) count = count + ( Math . min ( j - b , a - j ) ) * cnt [ j ] ; } } res = Math . min ( res , count ) ; } return res ; } public static void main ( String [ ] args ) { String str = " abcdefghi " ; int K = 2 ; System . out . println ( minCost ( str , K ) ) ; } }
class GFG { static void printLastChar ( String str ) { str = str + " ▁ " ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) System . out . print ( str . charAt ( i - 1 ) + " ▁ " ) ; } } public static void main ( String s [ ] ) { String str = " Geeks ▁ for ▁ Geeks " ; printLastChar ( str ) ; } }
class GFG { static int maxBalancedStr ( String s ) { int open1 = 0 , close1 = 0 ; int open2 = 0 , close2 = 0 ; int open3 = 0 , close3 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { switch ( s . charAt ( i ) ) { case ' ( ' : open1 ++ ; break ; case ' ) ' : close1 ++ ; break ; case ' { ' : open2 ++ ; break ; case ' } ' : close2 ++ ; break ; case ' [ ' : open3 ++ ; break ; case ' ] ' : close3 ++ ; break ; } } int maxLen = 2 * Math . min ( open1 , close1 ) + 2 * Math . min ( open2 , close2 ) + 2 * Math . min ( open3 , close3 ) ; return maxLen ; } public static void main ( String [ ] args ) { String s = " ) ) [ ] ] ( ( " ; System . out . println ( maxBalancedStr ( s ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static String extractSecretMessage ( String Str , String Sub ) { Str = Str . replaceAll ( Sub , " ▁ " ) ; Str = Str . trim ( ) ; return Str ; } public static void main ( String args [ ] ) { String Str = " LIELIEILIEAMLIECOOL " ; String Sub = " LIE " ; System . out . println ( extractSecretMessage ( Str , Sub ) ) ; } }
class GFG { static int binarySearch ( String [ ] arr , String x ) { int l = 0 , r = arr . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; int res = x . compareTo ( arr [ m ] ) ; if ( res == 0 ) return m ; if ( res > 0 ) l = m + 1 ; else r = m - 1 ; } return - 1 ; } public static void main ( String [ ] args ) { String [ ] arr = { " contribute " , " geeks " , " ide " , " practice " } ; String x = " ide " ; int result = binarySearch ( arr , x ) ; if ( result == - 1 ) System . out . println ( " Element ▁ not ▁ present " ) ; else System . out . println ( " Element ▁ found ▁ at ▁ " + " index ▁ " + result ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static void getStudentsList ( String [ ] file ) { int avgScore ; int maxAvgScore = Integer . MIN_VALUE ; ArrayList < String > names = new ArrayList < > ( ) ; for ( int i = 0 ; i < file . length ; i += 4 ) { avgScore = ( Integer . parseInt ( file [ i + 1 ] ) + Integer . parseInt ( file [ i + 2 ] ) + Integer . parseInt ( file [ i + 3 ] ) ) / 3 ; if ( avgScore > maxAvgScore ) { maxAvgScore = avgScore ; names . clear ( ) ; names . add ( file [ i ] ) ; } else if ( avgScore == maxAvgScore ) names . add ( file [ i ] ) ; } for ( int i = 0 ; i < names . size ( ) ; i ++ ) { System . out . print ( names . get ( i ) + " ▁ " ) ; } System . out . print ( maxAvgScore ) ; } public static void main ( String args [ ] ) { String [ ] file = { " Shrikanth " , "20" , "30" , "10" , " Ram " , "100" , "50" , "10" } ; getStudentsList ( file ) ; } }
import java . io . * ; class GFG { static int strScore ( String str [ ] , String s , int n ) { int score = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) score += s . charAt ( j ) - ' a ' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; } public static void main ( String [ ] args ) { String str [ ] = { " sahil " , " shashanak " , " sanjit " , " abhinav " , " mohit " } ; String s = " abhinav " ; int n = str . length ; int score = strScore ( str , s , n ) ; System . out . println ( score ) ; } }
public class GFG { static int minParentheses ( String p ) { int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . length ( ) ; ++ i ) { bal += p . charAt ( i ) == ' ( ' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; } public static void main ( String args [ ] ) { String p = " ( ) ) " ; System . out . println ( minParentheses ( p ) ) ; } }
import java . util . * ; class GFG { static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = 0 ; r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; } static boolean isPalindrome ( String r ) { String p = r ; p = reverse ( p ) ; return ( r . equals ( p ) ) ; } static boolean CheckStr ( String s ) { int l = s . length ( ) ; int i ; for ( i = 2 ; i <= l ; i ++ ) { if ( isPalindrome ( s . substring ( 0 , i ) ) ) { break ; } } if ( i == ( l + 1 ) ) { return false ; } i = 2 ; for ( i = 2 ; i <= l ; i ++ ) { if ( isPalindrome ( s . substring ( l - i , l ) ) ) { return true ; } } return false ; } public static void main ( String args [ ] ) { String s = " abccbarfgdbd " ; if ( CheckStr ( s ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class solution { static int oddEquivalent ( String s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) count ++ ; } return count ; } public static void main ( String ar [ ] ) { String s = "1011011" ; int n = s . length ( ) ; System . out . println ( oddEquivalent ( s , n ) ) ; } }
class GFG { static int findNumberOfTimes ( String str1 , String str2 ) { int freq [ ] = new int [ 26 ] ; int freq2 [ ] = new int [ 26 ] ; int l1 = str1 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { freq [ str1 . charAt ( i ) - ' a ' ] += 1 ; } int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l2 ; i ++ ) { freq2 [ str2 . charAt ( i ) - ' a ' ] += 1 ; } int count = Integer . MAX_VALUE ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( freq2 [ str2 . charAt ( i ) - ' a ' ] != 0 ) count = Math . min ( count , freq [ str2 . charAt ( i ) - ' a ' ] / freq2 [ str2 . charAt ( i ) - ' a ' ] ) ; } return count ; } public static void main ( String [ ] args ) { String str1 = " foreeksgekseg " ; String str2 = " geeks " ; System . out . println ( findNumberOfTimes ( str1 , str2 ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static boolean solve ( String s1 , String s2 ) { boolean flag1 = false , flag2 = false ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; int l = s1 . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s1 . charAt ( i ) == '1' ) flag1 = true ; if ( s2 . charAt ( i ) == '1' ) flag2 = true ; if ( flag1 == true && flag2 == true ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; } public static void main ( String args [ ] ) { String s1 = "100101" ; String s2 = "100000" ; if ( solve ( s1 , s2 ) == true ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GfG { public static int subzero ( String s , int k ) { int ans = 0 , curr = 0 ; int len = s . length ( ) ; char [ ] str = s . toCharArray ( ) ; for ( int i = 0 ; i < len ; ++ i ) { if ( str [ i ] == '0' ) curr ++ ; else curr = 0 ; ans = Math . max ( ans , curr ) ; } if ( ans == len ) return len * k ; else { int pre = 0 , suff = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) pre ++ ; else break ; } for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) suff ++ ; else break ; } if ( k > 1 ) ans = Math . max ( ans , pre + suff ) ; return ans ; } } public static void main ( String [ ] args ) { String str = "00100110" ; int k = 5 ; System . out . println ( subzero ( str , k ) ) ; } }
import java . util . * ; class solution { static String Dragon_Curve_Sequence ( int n ) { String s = "1" ; for ( int i = 2 ; i <= n ; i ++ ) { String temp = "1" ; char prev = '1' , zero = '0' , one = '1' ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { temp += s . charAt ( j ) ; if ( prev == '0' ) { temp += one ; prev = one ; } else { temp += zero ; prev = zero ; } } s = temp ; } return s ; } public static void main ( String args [ ] ) { int n = 4 ; String s = Dragon_Curve_Sequence ( n ) ; System . out . println ( s ) ; } }
import java . io . * ; public class GFG { static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; } public static void main ( String args [ ] ) { String s = " abcde " ; System . out . println ( countNonEmptySubstr ( s ) ) ; } }
class GFG { static int MAX = 26 ; static boolean targetstring ( String str1 , String str2 ) { int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; if ( l1 != l2 ) return false ; int [ ] map = new int [ MAX ] ; for ( int i = 0 ; i < l1 ; i ++ ) map [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) { map [ str2 . charAt ( i ) - ' a ' ] -- ; if ( map [ str2 . charAt ( i ) - ' a ' ] < 0 ) return false ; } return true ; } public static void main ( String args [ ] ) { String str1 = " geeksforgeeks " ; String str2 = " geegeeksksfor " ; if ( targetstring ( str1 , str2 ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
class GFG { static boolean isDigitPresent ( int x , int d ) { while ( x > 0 ) { if ( x % 10 == d ) break ; x = x / 10 ; } return ( x > 0 ) ; } static void printNumbers ( int n , int d ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i == d || isDigitPresent ( i , d ) ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 47 , d = 7 ; printNumbers ( n , d ) ; } }
import java . io . * ; class GFG { static char findExtraCharcter ( String strA , String strB ) { int res = 0 , i ; for ( i = 0 ; i < strA . length ( ) ; i ++ ) { res ^= strA . charAt ( i ) ; } for ( i = 0 ; i < strB . length ( ) ; i ++ ) { res ^= strB . charAt ( i ) ; } return ( ( char ) ( res ) ) ; } public static void main ( String args [ ] ) { String strA = " abcd " ; String strB = " cbdad " ; System . out . println ( findExtraCharcter ( strA , strB ) ) ; } }
import java . io . * ; class GFG { public static int calculateSum ( String arr [ ] , int n ) { if ( n == 0 ) return 0 ; String s = arr [ 0 ] ; int value = Integer . parseInt ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = Integer . parseInt ( s ) ; char operation = arr [ i - 1 ] . charAt ( 0 ) ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; } public static void main ( String [ ] args ) { String arr [ ] = { "3" , " + " , "4" , " - " , "7" , " + " , "13" } ; int n = arr . length ; System . out . println ( calculateSum ( arr , n ) ) ; } }
import java . lang . * ; import java . io . * ; import java . util . Arrays ; class Geek { public static void LargestString ( String na [ ] ) { int N = na . length ; int c [ ] = new int [ N ] ; int m = 0 ; for ( int j = 0 ; j < N ; j ++ ) { boolean character [ ] = new boolean [ 26 ] ; for ( int k = 0 ; k < na [ j ] . length ( ) ; k ++ ) { int x = na [ j ] . charAt ( k ) - ' A ' ; if ( ( na [ j ] . charAt ( k ) != ' ▁ ' ) && ( character [ x ] == false ) ) { c [ j ] ++ ; character [ x ] = true ; } } if ( c [ j ] > c [ m ] ) m = j ; } System . out . println ( na [ m ] ) ; } public static void main ( String [ ] args ) { String na [ ] = { " BOB " , " A ▁ AB ▁ C ▁ JOHNSON " , " ANJALI " , " ASKRIT " , " ARMAN ▁ MALLIK " } ; LargestString ( na ) ; } }
class GFG { static String morseEncode ( char x ) { switch ( x ) { case ' a ' : return " . - " ; case ' b ' : return " - . . . " ; case ' c ' : return " - . - . " ; case ' d ' : return " - . . " ; case ' e ' : return " . " ; case ' f ' : return " . . - . " ; case ' g ' : return " - - . " ; case ' h ' : return " . . . . " ; case ' i ' : return " . . " ; case ' j ' : return " . - - - " ; case ' k ' : return " - . - " ; case ' l ' : return " . - . . " ; case ' m ' : return " - - " ; case ' n ' : return " - . " ; case ' o ' : return " - - - " ; case ' p ' : return " . - - . " ; case ' q ' : return " - - . - " ; case ' r ' : return " . - . " ; case ' s ' : return " . . . " ; case ' t ' : return " - " ; case ' u ' : return " . . - " ; case ' v ' : return " . . . - " ; case ' w ' : return " . - - " ; case ' x ' : return " - . . - " ; case ' y ' : return " - . - - " ; case ' z ' : return " - - . . " ; case '1' : return " . - - - - " ; case '2' : return " . . - - - " ; case '3' : return " . . . - - " ; case '4' : return " . . . . - " ; case '5' : return " . . . . . " ; case '6' : return " - . . . . " ; case '7' : return " - - . . . " ; case '8' : return " - - - . . " ; case '9' : return " - - - - . " ; case '0' : return " - - - - - " ; } return " " ; } static void morseCode ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) System . out . print ( morseEncode ( s . charAt ( i ) ) ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; morseCode ( s ) ; } }
class GFG { static void polybiusCipher ( String s ) { int row , col ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { row = ( int ) Math . ceil ( ( s . charAt ( i ) - ' a ' ) / 5 ) + 1 ; col = ( ( s . charAt ( i ) - ' a ' ) % 5 ) + 1 ; if ( s . charAt ( i ) == ' k ' ) { row = row - 1 ; col = 5 - col + 1 ; } else if ( s . charAt ( i ) >= ' j ' ) { if ( col == 1 ) { col = 6 ; row = row - 1 ; } col = col - 1 ; } System . out . print ( row + " " + col ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; polybiusCipher ( s ) ; } }
import java . util . Arrays ; class GFG { static final int MAX_CHAR = 26 ; static int minRemoval ( String str ) { int hash [ ] = new int [ MAX_CHAR ] ; Arrays . fill ( hash , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) hash [ str . charAt ( i ) - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( hash [ i ] % 2 == 1 ) count ++ ; return ( count == 0 ) ? 0 : count - 1 ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . println ( minRemoval ( str ) ) ; } }
import java . io . * ; import java . util . * ; class GfG { static int findLUSlength ( String a , String b ) { if ( a . equals ( b ) == true ) return 0 ; return Math . max ( a . length ( ) , b . length ( ) ) ; } public static void main ( String [ ] args ) { String a = " abcdabcd " , b = " abcabc " ; System . out . println ( findLUSlength ( a , b ) ) ; } }
import java . io . * ; class ns { public static void swapTwoHalves ( String a , String b ) { int la = a . length ( ) ; int lb = b . length ( ) ; String c = a . substring ( 0 , la / 2 ) + b . substring ( lb / 2 , lb ) ; String d = b . substring ( 0 , lb / 2 ) + a . substring ( la / 2 , la ) ; System . out . println ( c + "NEW_LINE" + d); } public static void main ( String args [ ] ) { String a = " remuneration " ; String b = " day " ; swapTwoHalves ( a , b ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public final static int SIZE = 26 ; public static int longSubstring ( String str1 , int k ) { int [ ] freq = new int [ SIZE ] ; char [ ] str = str1 . toCharArray ( ) ; int start = 0 ; int maxLen = 0 ; char ch ; int n = str1 . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ch = str [ i ] ; freq [ ch - ' a ' ] ++ ; if ( freq [ ch - ' a ' ] > k ) { if ( maxLen < ( i - start ) ) maxLen = i - start ; while ( freq [ ch - ' a ' ] > k ) { freq [ str [ start ] - ' a ' ] -- ; start ++ ; } } } if ( maxLen < ( n - start ) ) maxLen = n - start ; return maxLen ; } public static void main ( String argc [ ] ) { String str = " babcaag " ; int k = 1 ; System . out . println ( " Length ▁ = ▁ " + longSubstring ( str , k ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int solve ( int [ ] A , int n ) { int i , cnt = 0 , j ; int [ ] parent = new int [ n + 1 ] ; int [ ] vis = new int [ n + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { parent [ i ] = - 1 ; vis [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + A [ j ] + 1 ) % n ; } } } } return cnt ; } public static void main ( String args [ ] ) { int [ ] A = { 0 , 0 , 0 , 2 } ; int n = A . length ; System . out . print ( solve ( A , n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class TugOfWar { public int min_diff ; void TOWUtil ( int arr [ ] , int n , boolean curr_elements [ ] , int no_of_selected_elements , boolean soln [ ] , int sum , int curr_sum , int curr_position ) { if ( curr_position == n ) return ; if ( ( n / 2 - no_of_selected_elements ) > ( n - curr_position ) ) return ; TOWUtil ( arr , n , curr_elements , no_of_selected_elements , soln , sum , curr_sum , curr_position + 1 ) ; no_of_selected_elements ++ ; curr_sum = curr_sum + arr [ curr_position ] ; curr_elements [ curr_position ] = true ; if ( no_of_selected_elements == n / 2 ) { if ( Math . abs ( sum / 2 - curr_sum ) < min_diff ) { min_diff = Math . abs ( sum / 2 - curr_sum ) ; for ( int i = 0 ; i < n ; i ++ ) soln [ i ] = curr_elements [ i ] ; } } else { TOWUtil ( arr , n , curr_elements , no_of_selected_elements , soln , sum , curr_sum , curr_position + 1 ) ; } curr_elements [ curr_position ] = false ; } void tugOfWar ( int arr [ ] ) { int n = arr . length ; boolean [ ] curr_elements = new boolean [ n ] ; boolean [ ] soln = new boolean [ n ] ; min_diff = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; curr_elements [ i ] = soln [ i ] = false ; } TOWUtil ( arr , n , curr_elements , 0 , soln , sum , 0 , 0 ) ; System . out . print ( " The ▁ first ▁ subset ▁ is : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( soln [ i ] == true ) System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . print ( " The second subset is : "); for ( int i = 0 ; i < n ; i ++ ) { if ( soln [ i ] == false ) System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 23 , 45 , - 34 , 12 , 0 , 98 , - 99 , 4 , 189 , - 1 , 4 } ; TugOfWar a = new TugOfWar ( ) ; a . tugOfWar ( arr ) ; } }
class GFG { final static int NO_OF_CHARS = 256 ; static int max_distinct_char ( String str , int n ) { int count [ ] = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str . charAt ( i ) ] ++ ; } int max_distinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] != 0 ) { max_distinct ++ ; } } return max_distinct ; } static int smallesteSubstr_maxDistictChar ( String str ) { int n = str . length ( ) ; int max_distinct = max_distinct_char ( str , n ) ; int minl = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { String subs = null ; if ( i < j ) subs = str . substring ( i , j ) ; else subs = str . substring ( j , i ) ; int subs_lenght = subs . length ( ) ; int sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ; if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; } static public void main ( String [ ] args ) { String str = " AABBBCBB " ; int len = smallesteSubstr_maxDistictChar ( str ) ; System . out . println ( " ▁ The ▁ length ▁ of ▁ the ▁ smallest ▁ substring " + " ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ " + " characters ▁ : ▁ " + len ) ; } }
public class GFG { static int evenNumSubstring ( String str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str . charAt ( i ) - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; } public static void main ( String args [ ] ) { String str = "1234" ; System . out . println ( evenNumSubstring ( str ) ) ; } }
class GFG { static int findIndex ( int a [ ] , int n ) { int res = 0 ; long min_diff = Long . MAX_VALUE ; long prod [ ] = new long [ n ] ; prod [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long curr_diff = Math . abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; } public static void main ( String arg [ ] ) { int arr [ ] = { 3 , 2 , 5 , 7 , 2 , 9 } ; int N = arr . length ; System . out . println ( findIndex ( arr , N ) ) ; } }
class GFG { static void printNumbers ( int a [ ] , int n , int x ) { boolean flag = false ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; int g = __gcd ( num , x ) ; while ( g != 1 ) { num /= g ; g = __gcd ( num , x ) ; } if ( num == 1 ) { flag = true ; System . out . print ( a [ i ] + " ▁ " ) ; } } if ( ! flag ) System . out . println ( " There ▁ are ▁ no ▁ such ▁ numbers " ) ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int x = 60 ; int a [ ] = { 2 , 5 , 10 , 7 , 17 } ; int n = a . length ; printNumbers ( a , n , x ) ; } }
class GFG { static void print ( int rStation [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( rStation [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } static void radiated_Station ( int station [ ] , int n ) { int rStation [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { int li = i - 1 , ri = i + 1 ; int lRad = station [ i ] - 1 , rRad = station [ i ] - 1 ; rStation [ i ] += station [ i ] ; while ( li >= 1 && lRad >= 1 ) { rStation [ li -- ] += lRad -- ; } while ( ri <= n && rRad >= 1 ) { rStation [ ri ++ ] += rRad -- ; } } print ( rStation , n ) ; } public static void main ( String [ ] args ) { int station [ ] = { 0 , 7 , 9 , 12 , 2 , 5 } ; int n = station . length - 1 ; radiated_Station ( station , n ) ; } }
class GFG { static int findMaximumDiff ( int [ ] a , int n ) { int ind1 = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( a [ 0 ] != a [ i ] ) { ind1 = i ; break ; } } int ind2 = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ n - 1 ] != a [ i ] ) { ind2 = ( n - 1 - i ) ; break ; } } return Math . max ( ind1 , ind2 ) ; } public static void main ( String args [ ] ) { int [ ] a = { 1 , 2 , 3 , 2 , 3 } ; int n = a . length ; System . out . println ( findMaximumDiff ( a , n ) ) ; } }
class GFG { static int sum ( int k , int n ) { int sum = ( int ) ( Math . pow ( k , n + 1 ) - Math . pow ( k - 1 , n + 1 ) ) ; return sum ; } public static void main ( String args [ ] ) { int n = 3 ; int K = 3 ; System . out . print ( sum ( K , n ) ) ; } }
class GfG { static boolean is_prime ( int num ) { int count = 0 ; for ( int i = 1 ; i * i <= ( num ) ; i ++ ) { if ( ( num ) % i == 0 ) { if ( i * i != ( num ) ) count += 2 ; else count ++ ; } } if ( count == 2 ) return true ; else return false ; } static String is_divisible ( int n ) { if ( n == 1 ) { return " YES " ; } else { if ( is_prime ( n + 1 ) ) return " NO " ; else return " YES " ; } } public static void main ( String [ ] args ) { int n ; n = 3 ; System . out . println ( is_divisible ( n ) ) ; n = 4 ; System . out . println ( is_divisible ( n ) ) ; } }
class GFG { static int mod = ( int ) ( 1e9 + 7 ) ; static int BitOperations ( String a , int n , String b , int m ) { char [ ] ch1 = a . toCharArray ( ) ; reverse ( ch1 ) ; a = new String ( ch1 ) ; char [ ] ch2 = b . toCharArray ( ) ; reverse ( ch2 ) ; b = new String ( ch2 ) ; int c = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( b . charAt ( i ) == '1' ) c ++ ; int [ ] power = new int [ n ] ; power [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) power [ i ] = ( power [ i - 1 ] * 2 ) % mod ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a . charAt ( i ) == '1' ) { ans += c * power [ i ] ; if ( ans >= mod ) ans %= mod ; } if ( b . charAt ( i ) == '1' ) c -- ; if ( c == 0 ) break ; } return ans ; } static void reverse ( char a [ ] ) { int i , k , n = a . length ; char t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } } public static void main ( String [ ] args ) { String a = "1001" , b = "10101" ; int n = a . length ( ) , m = b . length ( ) ; System . out . println ( BitOperations ( a , n , b , m ) ) ; } }
import java . util . Arrays ; class GFG { static void sieve ( int maxEle , int prime [ ] ) { prime [ 0 ] = prime [ 1 ] = 1 ; for ( int i = 2 ; i * i <= maxEle ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = 2 * i ; j <= maxEle ; j += i ) prime [ j ] = 1 ; } } } static int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n = n / 10 ; } return sum ; } static void printAdditivePrime ( int arr [ ] , int n ) { int maxEle = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int prime [ ] = new int [ maxEle + 1 ] ; sieve ( maxEle , prime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 0 ) { int sum = digitSum ( arr [ i ] ) ; if ( prime [ sum ] == 0 ) System . out . print ( arr [ i ] + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int a [ ] = { 2 , 4 , 6 , 11 , 12 , 18 , 7 } ; int n = a . length ; printAdditivePrime ( a , n ) ; } }
class GFG { static long nthTerm ( long n ) { long nth ; if ( n % 2 == 0 ) nth = 2 * ( ( n * n ) - n ) ; else nth = ( 2 * n * n ) - n ; return nth ; } public static void main ( String [ ] args ) { long n ; n = 5 ; System . out . println ( nthTerm ( n ) ) ; n = 25 ; System . out . println ( nthTerm ( n ) ) ; n = 25000000 ; System . out . println ( nthTerm ( n ) ) ; n = 250000007 ; System . out . println ( nthTerm ( n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static int nthTerm ( int n ) { int An = ( ( int ) Math . pow ( 1 , n ) + ( int ) Math . pow ( 2 , n ) ) * ( int ) Math . pow ( 3 , n ) ; return An ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( nthTerm ( n ) ) ; } }
public class GFG { static int countDivisors ( int n ) { int x = 0 , ans = 1 ; while ( n % 2 == 0 ) { x ++ ; n = n / 2 ; } ans = ans * ( x + 1 ) ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { x = 0 ; while ( n % i == 0 ) { x ++ ; n = n / i ; } ans = ans * ( x + 1 ) ; } if ( n > 2 ) ans = ans * 2 ; return ans ; } static int getTotalCount ( int n , int k ) { int k_count = countDivisors ( k ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( k_count == countDivisors ( i ) ) count ++ ; if ( k < n ) count = count - 1 ; return count ; } public static void main ( String [ ] args ) { int n = 500 , k = 6 ; System . out . println ( getTotalCount ( n , k ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static int nthTerm ( int n ) { int d = 2 ; int a1 = 0 ; int An = a1 + ( n - 1 ) * d ; return ( int ) Math . pow ( An , 3 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( nthTerm ( n ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static final int MAX_VAL = 200000 ; static int countIntervals ( int [ ] [ ] arr , int V , int N ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; int li , ri ; int [ ] freq = new int [ MAX_VAL ] ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; } public static void main ( String args [ ] ) { int [ ] [ ] arr = { { 1 , 10 } , { 5 , 10 } , { 15 , 25 } , { 7 , 12 } , { 20 , 25 } } ; int V = 7 ; int N = arr . length ; System . out . println ( countIntervals ( arr , V , N ) ) ; } }
import java . io . * ; class GFG { static void printGroups ( int n ) { int x = 1 ; int y = n * n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n / 2 ; j ++ ) { System . out . print ( " { ▁ " + x + " , ▁ " + y + " } ▁ " ) ; x ++ ; y -- ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 4 ; printGroups ( n ) ; } }
import java . io . * ; import java . lang . * ; class GFG { public static int breakEvenPoint ( int exp1 , int S , int M ) { double earn = S - M ; double exp = exp1 ; double res = Math . ceil ( exp / earn ) ; int res1 = ( int ) res ; return res1 ; } public static void main ( String [ ] args ) { int exp = 3550 , S = 90 , M = 65 ; System . out . println ( breakEvenPoint ( exp , S , M ) ) ; } }
import java . util . * ; class solution { static int minimum ( int n ) { int product = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; } public static void main ( String arr [ ] ) { int n = 20 ; System . out . println ( minimum ( n ) ) ; } }
class GFG { static int numbers ( int n , int arr [ ] , int m ) { int isZero = 0 , isFive = 0 ; int result = 0 ; if ( m < n ) { return - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { if ( arr [ i ] == 0 ) { isZero = 1 ; } if ( arr [ i ] == 5 ) { isFive = 1 ; } } if ( isZero == 1 && isFive == 1 ) { result = 2 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else if ( isZero == 1 isFive == 1 ) { result = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else { result = - 1 ; } return result ; } public static void main ( String [ ] args ) { int n = 3 , m = 6 ; int arr [ ] = { 2 , 3 , 5 , 6 , 7 , 9 } ; System . out . println ( numbers ( n , arr , m ) ) ; } }
import java . io . * ; class GFG { public static void main ( String [ ] args ) { int a = 5 , b = 7 , c = 10 ; if ( a <= b && a <= c ) System . out . println ( a + " ▁ is ▁ the ▁ smallest " ) ; else if ( b <= a && b <= c ) System . out . println ( b + " ▁ is ▁ the ▁ smallest " ) ; else System . out . println ( c + " ▁ is ▁ the ▁ smallest " ) ; } }
import java . util . Arrays ; class GFG { static void maxSum ( int [ ] a , int n ) { int maxAnd = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } System . out . println ( ( maxAnd + maxOR ) ) ; } public static void main ( String [ ] args ) { int n = 4 ; int [ ] a = { 3 , 5 , 6 , 1 } ; maxSum ( a , n ) ; } }
class GFG { static int getMin ( int arr [ ] , int n , int k ) { int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { res = Math . min ( res , arr [ i ] ) ; } } return res ; } static int getMax ( int arr [ ] , int n , int k ) { int res = Integer . MIN_VALUE ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { res = Math . max ( res , arr [ i ] ) ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 1230 , 45 , 67 , 1 } ; int k = 10 ; int n = arr . length ; System . out . println ( " Minimum ▁ element ▁ of ▁ array ▁ which ▁ is ▁ divisible ▁ by ▁ k : ▁ " + getMin ( arr , n , k ) ) ; System . out . println ( " Maximum ▁ element ▁ of ▁ array ▁ which ▁ is ▁ divisible ▁ by ▁ k : ▁ " + getMax ( arr , n , k ) ) ; } }
import java . io . * ; class GFG { static void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) System . out . print ( " - 1" ) ; else { System . out . print ( d ) ; k -- ; while ( k -- > 0 ) System . out . print ( "0" ) ; } } public static void main ( String [ ] args ) { int k = 4 , d = 4 ; printNumberWithDR ( k , d ) ; } }
public class GFG { static int countNumbers ( int n ) { int c = 0 ; int limit = ( int ) Math . sqrt ( n ) ; int prime [ ] = new int [ limit + 1 ] ; for ( int i = 1 ; i <= limit ; i ++ ) { prime [ i ] = i ; } for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( prime [ i ] == i ) { for ( int j = i * i ; j <= limit ; j += i ) { if ( prime [ j ] == j ) { prime [ j ] = i ; } } } } for ( int i = 2 ; i <= limit ; i ++ ) { int p = prime [ i ] ; int q = prime [ i / prime [ i ] ] ; if ( p * q == i && q != 1 && p != q ) { c += 1 ; } else if ( prime [ i ] == i ) { if ( Math . pow ( i , 8 ) <= n ) { c += 1 ; } } } return c ; } public static void main ( String [ ] args ) { int n = 1000 ; System . out . println ( countNumbers ( n ) ) ; } }
class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } static boolean isInterprime ( int n ) { if ( n < 4 ) return false ; int prev_prime = n ; int next_prime = n ; while ( ! isPrime ( prev_prime ) ) { prev_prime -- ; } while ( ! isPrime ( next_prime ) ) { next_prime ++ ; } if ( ( prev_prime + next_prime ) == 2 * n ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 9 ; if ( isInterprime ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; class GFG { static int get_unit_digit ( int N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; } public static void main ( String [ ] args ) { int N = 1 ; for ( N = 0 ; N <= 10 ; N ++ ) System . out . println ( " For ▁ N ▁ = ▁ " + N + " ▁ : ▁ " + get_unit_digit ( N ) ) ; } }
class gfg { static int [ ] f = new int [ 1000 ] ; public static int fib ( int n ) { if ( n == 0 ) { return 0 ; } if ( n == 1 n == 2 ) { return ( f [ n ] = 1 ) ; } if ( f [ n ] > 0 ) { return f [ n ] ; } int k = ( ( n & 1 ) > 0 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( ( n & 1 ) > 0 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; } public static int calculateSumOfSquares ( int n ) { return fib ( n ) * fib ( n + 1 ) ; } } class geek { public static void main ( String [ ] args ) { gfg g = new gfg ( ) ; int n = 6 ; System . out . println ( " Sum ▁ of ▁ Squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " + g . calculateSumOfSquares ( n ) ) ; } }
import java . io . * ; class GFG { static int NumberOfSolutions ( int x , int y , int z , int n ) { int ans = 0 ; for ( int i = 0 ; i <= x ; i ++ ) { for ( int j = 0 ; j <= y ; j ++ ) { int temp = n - i - j ; if ( temp >= 0 ) { temp = Math . min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; } public static void main ( String [ ] args ) { int x = 1 , y = 2 , z = 3 , n = 4 ; System . out . println ( NumberOfSolutions ( x , y , z , n ) ) ; } }
import java . io . * ; class GFG { static int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 4 * n ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class GFG { static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static boolean isProduct ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; } static void findNumbers ( int N ) { Vector < Integer > vec = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isProduct ( i ) && ! isPerfectSquare ( i ) ) { vec . add ( i ) ; } } Iterator < Integer > itr = vec . iterator ( ) ; while ( itr . hasNext ( ) ) { System . out . print ( itr . next ( ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 30 ; findNumbers ( N ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 3 ) + ( int ) Math . pow ( n , 2 ) ; } public static void main ( String arr [ ] ) { int N = 3 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static long NthTerm ( long n ) { long x = ( 2 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; } public static void main ( String args [ ] ) { long N = 4 ; System . out . println ( NthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; } public static void main ( String arr [ ] ) { int N = 3 ; System . out . println ( findSum ( N ) ) ; } }
class GFG { static int nthTerm ( int N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( nthTerm ( N ) ) ; } }
public class GFG { private static final int MAX = 16 ; static long nCr [ ] [ ] = new long [ MAX ] [ MAX ] ; static void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } } static double findTanNTheta ( double tanTheta , int n ) { double ans = 0 , numerator = 0 , denominator = 0 ; long toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * Math . pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } denominator = 1 ; toggle = - 1 ; for ( int i = 2 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * Math . pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } ans = numerator / denominator ; return ans ; } public static void main ( String args [ ] ) { binomial ( ) ; double tanTheta = 0.3 ; int n = 10 ; System . out . println ( findTanNTheta ( tanTheta , n ) ) ; } }
class GFG { static int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; } public static void main ( String arg [ ] ) { System . out . print ( findMaximumPieces ( 3 ) ) ; } }
import java . io . * ; class GFG { static boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n += d * 2 ; } return ( n % 19 == 0 ) ; } public static void main ( String [ ] args ) { long n = 101156 ; if ( isDivisible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int calculateSum ( int n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( " Sum ▁ = ▁ " + calculateSum ( n ) ) ; } }
import java . io . * ; class GFG { static void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { System . out . println ( i + " ▁ " + j + " ▁ " + k ) ; return ; } } } } } } } public static void main ( String [ ] args ) { int n = 233 ; printCombination ( n ) ; } }
class GFG { static int percent ( int a , int b ) { float result = 0 ; result = ( ( b - a ) * 100 ) / a ; return ( int ) result ; } public static void main ( String [ ] args ) { int a = 20 , b = 25 ; System . out . println ( percent ( a , b ) + " % " ) ; } }
import java . util . * ; class GFG { public static int calculate ( int ar [ ] , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 4 , 6 } ; int size = a . length ; System . out . print ( calculate ( a , size ) ) ; } }
class Test { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
import java . io . * ; class GFG { static long dig ( long a ) { long count = 0 ; while ( a > 0 ) { a /= 10 ; count ++ ; } return count ; } static void required_number ( long num , long n , long d ) { long i , j , power = 1 , a , flag = 0 ; for ( i = num ; i >= 1 ; i -- ) { power = ( long ) Math . pow ( 10 , i ) ; a = n % power ; if ( d > a ) { flag = 1 ; break ; } } if ( flag > 0 ) { long t = 0 ; for ( j = 0 ; j < i ; j ++ ) { t += 9 * Math . pow ( 10 , j ) ; } if ( n % power == t ) System . out . print ( n ) ; else { System . out . print ( n - ( n % power ) - 1 ) ; } } else System . out . print ( n ) ; } public static void main ( String [ ] args ) { long n = 1029 , d = 102 ; long num = dig ( n ) ; required_number ( num , n , d ) ; } }
import java . io . * ; class GFG { static int twoEggDrop ( int k ) { return ( int ) Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8 * k ) ) / 2.0 ) ; } public static void main ( String [ ] args ) { int k = 100 ; System . out . println ( twoEggDrop ( k ) ) ; } }
import java . io . * ; class GFG { static float findArea ( float a ) { float area ; area = ( float ) ( 5 * Math . sqrt ( 3 ) * a * a ) ; return area ; } static float findVolume ( float a ) { float volume ; volume = ( float ) ( ( ( float ) 5 / 12 ) * ( 3 + Math . sqrt ( 5 ) ) * a * a * a ) ; return volume ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( " Area : ▁ " + findArea ( a ) ) ; System . out . println ( " Volume : ▁ " + findVolume ( a ) ) ; } }
public class GFG { static int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( " Total ▁ ways ▁ are : ▁ " + ways ( n ) ) ; } }
import java . io . * ; class GFG { static int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + ( int ) Math . floor ( ans ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( countDigits ( n ) + "NEW_LINE"); } }
import java . io . * ; class GFG { public static void main ( String [ ] args ) { double cm , meter , kilometer ; cm = 1000 ; meter = cm / 100.0 ; kilometer = cm / 100000.0 ; System . out . println ( " Length ▁ in ▁ meter ▁ = ▁ " + meter + " m " ) ; System . out . println ( " Length ▁ in ▁ Kilometer ▁ = ▁ " + kilometer + " km " ) ; } }
public class GFG { static boolean everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) { return false ; } if ( x1 > x2 && v1 >= v2 ) { return false ; } if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } return ( ( x1 - x2 ) % ( v1 - v2 ) == 0 ) ; } static void swap ( int a , int b ) { int t = a ; a = b ; b = t ; } public static void main ( String [ ] args ) { int x1 = 5 , v1 = 8 , x2 = 4 , v2 = 7 ; if ( everMeet ( x1 , x2 , v1 , v2 ) ) { System . out . printf ( " Yes " ) ; } else { System . out . printf ( " No " ) ; } } }
class GFG { public static void main ( String args [ ] ) { int a = 4 ; int b = 3 ; int val = ( a + b - 1 ) / b ; System . out . println ( " The ▁ ceiling ▁ value ▁ of ▁ 4/3 ▁ is ▁ " + val ) ; a = 6 ; b = 3 ; val = ( a + b - 1 ) / b ; System . out . println ( " The ▁ ceiling ▁ value ▁ of ▁ 6/3 ▁ is ▁ " + val ) ; } }
class GFG { static double sumTillX ( double x , double n ) { double odd = Math . ceil ( n / 2.0 ) ; if ( x <= odd ) return x * x ; double even = x - odd ; return ( ( odd * odd ) + ( even * even ) + even ) ; } static double rangeSum ( double N , double L , double R ) { return sumTillX ( R , N ) - sumTillX ( L - 1 , N ) ; } public static void main ( String args [ ] ) { long N = 10 , L = 1 , R = 6 ; int n = 101 ; System . out . println ( ( int ) rangeSum ( N , L , R ) ) ; } }
import java . io . * ; class GFG { static void printTwinPrime ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n - 2 ; i ++ ) { if ( prime [ i ] == true && prime [ i + 2 ] == true ) System . out . print ( " ▁ ( " + i + " , ▁ " + ( i + 2 ) + " ) " ) ; } } public static void main ( String args [ ] ) { int n = 25 ; printTwinPrime ( n ) ; } }
class GFG { public static boolean isCubeFree ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i * i <= n ; i ++ ) if ( n % ( i * i * i ) == 0 ) return false ; return true ; } public static void printCubeFree ( int n ) { for ( int i = 2 ; i <= n ; i ++ ) { if ( isCubeFree ( i ) ) { System . out . print ( i + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int n = 20 ; printCubeFree ( n ) ; } }
import java . io . * ; class GFG { static int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n != 0 ; n = n >> 1 ) inv ^= n ; return inv ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( inversegrayCode ( n ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static long productPrimeFactors ( int n ) { long product = 1 ; if ( n % 2 == 0 ) { product *= 2 ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { product = product * i ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) product = product * n ; return product ; } public static void main ( String [ ] args ) { int n = 44 ; System . out . print ( productPrimeFactors ( n ) ) ; } }
class GFG { static double calculateProbability ( int N ) { double probability = ( double ) N / ( N + 1 ) ; return probability ; } public static void main ( String [ ] args ) { int N ; double probabilityMax ; N = 1 ; probabilityMax = calculateProbability ( N ) ; System . out . println ( " Maximum ▁ Probability ▁ for " + " ▁ N ▁ = ▁ " + N + " ▁ is , ▁ " + Math . round ( probabilityMax * 10000.0 ) / 10000.0 ) ; N = 2 ; probabilityMax = calculateProbability ( N ) ; System . out . println ( " Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ " + N + " ▁ is , ▁ " + Math . round ( probabilityMax * 10000.0 ) / 10000.0 ) ; N = 10 ; probabilityMax = calculateProbability ( N ) ; System . out . println ( " Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ " + N + " ▁ is , ▁ " + Math . round ( probabilityMax * 10000.0 ) / 10000.0 ) ; } }
import java . io . * ; class GFG { static float mean ( float mid [ ] , int freq [ ] , int n ) { float sum = 0 , freqSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; } static float groupedSD ( float lower_limit [ ] , float upper_limit [ ] , int freq [ ] , int n ) { float mid [ ] = new float [ n ] ; float sum = 0 , freqSum = 0 , sd ; for ( int i = 0 ; i < n ; i ++ ) { mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 ; sum = sum + freq [ i ] * mid [ i ] * mid [ i ] ; freqSum = freqSum + freq [ i ] ; } sd = ( float ) Math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) ; return sd ; } public static void main ( String [ ] args ) { float lower_limit [ ] = { 50 , 61 , 71 , 86 , 96 } ; float upper_limit [ ] = { 60 , 70 , 85 , 95 , 100 } ; int freq [ ] = { 9 , 7 , 9 , 12 , 8 } ; int n = lower_limit . length ; System . out . println ( groupedSD ( lower_limit , upper_limit , freq , n ) ) ; } }
import java . io . * ; class GFG { static int avg_of_even_num ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return ( sum / n ) ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . print ( avg_of_even_num ( n ) ) ; } }
import java . io . * ; class GFG { static int avg_of_even_num ( int n ) { return n + 1 ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( avg_of_even_num ( n ) ) ; } }
import java . io . * ; class GFG { static int squareSum ( int n ) { return n * ( 4 * n * n - 1 ) / 3 ; } public static void main ( String args [ ] ) { System . out . println ( squareSum ( 8 ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static boolean isPrime ( int n ) { if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i * i <= n ; i += 2 ) if ( n % i == 0 ) return false ; return true ; } public static int nextPrime ( int start ) { int next = start + 1 ; while ( ! isPrime ( next ) ) next ++ ; return next ; } public static boolean areAdjacentPrimes ( int a , int b , int c ) { if ( ! isPrime ( a ) || ! isPrime ( b ) || ! isPrime ( c ) ) return false ; int next = nextPrime ( a ) ; if ( next != b ) return false ; if ( nextPrime ( b ) != c ) return false ; return true ; } public static void main ( String [ ] args ) { if ( areAdjacentPrimes ( 11 , 13 , 19 ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static int checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) while ( num % i == 0 ) { num /= i ; ++ cnt ; } if ( num > 1 ) ++ cnt ; return cnt == 2 ? 1 : 0 ; } static void semiprime ( int n ) { if ( checkSemiprime ( n ) != 0 ) System . out . printf ( "TrueNEW_LINE"); else System . out . printf ( "FalseNEW_LINE"); } public static void main ( String [ ] args ) { int n = 6 ; semiprime ( n ) ; n = 8 ; semiprime ( n ) ; } }
public class GfG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( sumOfSeries ( n ) ) ; } }
public class GfG { static int sumOfSeries ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } public static void main ( String s [ ] ) { int n = 10 ; System . out . println ( sumOfSeries ( n ) ) ; } }
import java . io . * ; class GFG { static int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } static int maxcoefficientvalue ( int n ) { if ( n % 2 == 0 ) return binomialCoeff ( n , n / 2 ) ; else return binomialCoeff ( n , ( n + 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( maxcoefficientvalue ( n ) ) ; } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) { return a ; } else { return __gcd ( b , a % b ) ; } } static int LCM ( int x , int y , int z ) { int ans = ( ( x * y ) / ( __gcd ( x , y ) ) ) ; return ( ( z * ans ) / ( __gcd ( ans , z ) ) ) ; } static int findDivisible ( int n , int x , int y , int z ) { int lcm = LCM ( x , y , z ) ; int ndigitnumber = ( int ) Math . pow ( 10 , n - 1 ) ; int reminder = ndigitnumber % lcm ; if ( reminder == 0 ) return ndigitnumber ; ndigitnumber += lcm - reminder ; if ( ndigitnumber < Math . pow ( 10 , n ) ) return ndigitnumber ; else return 0 ; } static public void main ( String [ ] args ) { int n = 4 , x = 2 , y = 3 , z = 5 ; int res = findDivisible ( n , x , y , z ) ; if ( res != 0 ) System . out . println ( res ) ; else System . out . println ( " Not ▁ possible " ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static int squaresum ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( squaresum ( n ) ) ; } }
class GFG { static double distance ( int x1 , int y1 , int x2 , int y2 ) { return Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; } public static void main ( String [ ] args ) { System . out . println ( Math . round ( distance ( 3 , 4 , 4 , 3 ) * 100000.0 ) / 100000.0 ) ; } }
import java . util . * ; class GFG { public static boolean isDivisible ( String S ) { int n = S . length ( ) ; if ( S . charAt ( n - 1 ) != '5' && S . charAt ( n - 1 ) != '0' ) return false ; int sum = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) sum += ( int ) S . charAt ( i ) ; if ( sum % 3 == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { String S = "15645746327462384723984023940239" ; if ( isDivisible ( S ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; String S1 = "15645746327462384723984023940235" ; if ( isDivisible ( S1 ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . lang . Math ; import java . io . * ; class GFG { static boolean checkPerfectSquare ( double n ) { double d = Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } static int largestPerfectSquareNumber ( int a [ ] , double n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectSquare ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; } public static void main ( String [ ] args ) { int [ ] a = { 16 , 20 , 25 , 2 , 3 , 10 } ; double n = a . length ; System . out . println ( largestPerfectSquareNumber ( a , n ) ) ; } }
import java . util . * ; public class ACE { static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } static int find_LCM ( int x , int y ) { return ( x * y ) / gcd ( x , y ) ; } static int CountPairs ( int n , int m , int A , int B ) { int cnt = 0 ; int lcm = find_LCM ( A , B ) ; for ( int i = 1 ; i <= n ; i ++ ) cnt += ( m + ( i % lcm ) ) / lcm ; return cnt ; } public static void main ( String [ ] args ) { int n = 60 , m = 90 , A = 5 , B = 10 ; System . out . println ( CountPairs ( n , m , A , B ) ) ; } }
import java . util . * ; class GFG { static int MAX = 1001 ; static int prefix [ ] [ ] = new int [ MAX ] [ MAX ] ; static int ar [ ] = new int [ MAX ] ; static void cal_prefix ( int n , int arr [ ] ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) ar [ i + 1 ] = arr [ i ] ; for ( i = 1 ; i <= 1000 ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) prefix [ i ] [ j ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { prefix [ i ] [ j ] = prefix [ i ] [ j - 1 ] + ( int ) ( ar [ j ] <= i ? 1 : 0 ) ; } } } static int ksub ( int l , int r , int n , int k ) { int lo , hi , mid ; lo = 1 ; hi = 1000 ; while ( lo + 1 < hi ) { mid = ( lo + hi ) / 2 ; if ( prefix [ mid ] [ r ] - prefix [ mid ] [ l - 1 ] >= k ) hi = mid ; else lo = mid + 1 ; } if ( prefix [ lo ] [ r ] - prefix [ lo ] [ l - 1 ] >= k ) hi = lo ; return hi ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 2 , 3 , 5 , 7 , 6 } ; int n = arr . length ; int k = 4 ; cal_prefix ( n , arr ) ; int queries [ ] [ ] = { { 1 , n , 1 } , { 2 , n - 2 , 2 } , { 3 , n - 1 , 3 } } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( ksub ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , n , queries [ i ] [ 2 ] ) ) ; } }
class GFG { static int max_min ( int a [ ] , int n ) { if ( n <= 1 ) return Integer . MAX_VALUE ; int f_min = a [ 0 ] , s_min = Integer . MAX_VALUE ; int f_max = a [ 0 ] , s_max = Integer . MIN_VALUE ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= f_min ) { s_min = f_min ; f_min = a [ i ] ; } else if ( a [ i ] < s_min ) { s_min = a [ i ] ; } if ( a [ i ] >= f_max ) { s_max = f_max ; f_max = a [ i ] ; } else if ( a [ i ] > s_max ) { s_max = a [ i ] ; } } return Math . min ( ( f_max - s_min ) , ( s_max - f_min ) ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 3 , 7 } ; int n = a . length ; System . out . println ( max_min ( a , n ) ) ; } }
class Solution { static int minimal ( int a [ ] , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; } public static void main ( String args [ ] ) { int a [ ] = { 8 , 5 , 4 , 3 , 4 , 10 } ; int n = a . length ; int ind = minimal ( a , n ) ; System . out . println ( a [ ind ] ) ; } }
public class GFG { public static void findIndices ( int arr [ ] , int n ) { int leftMin = 0 , rightMin = 0 ; int leftMax = 0 , rightMax = 0 ; int min = arr [ 0 ] , max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) { leftMin = rightMin = i ; min = arr [ i ] ; } else if ( arr [ i ] == min ) rightMin = i ; if ( arr [ i ] > max ) { leftMax = rightMax = i ; max = arr [ i ] ; } else if ( arr [ i ] == max ) rightMax = i ; } System . out . println ( " Minimum ▁ left ▁ : ▁ " + leftMin ) ; System . out . println ( " Minimum ▁ right ▁ : ▁ " + rightMin ) ; System . out . println ( " Maximum ▁ left ▁ : ▁ " + leftMax ) ; System . out . println ( " Maximum ▁ right ▁ : ▁ " + rightMax ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 1 , 2 , 1 , 5 , 6 , 5 } ; int n = arr . length ; findIndices ( arr , n ) ; } }
public class GFG { static void diagonalsMinMax ( int [ ] [ ] mat ) { int n = mat . length ; if ( n == 0 ) return ; int principalMin = mat [ 0 ] [ 0 ] , principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] , secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( i == j ) { if ( mat [ i ] [ j ] < principalMin ) { principalMin = mat [ i ] [ j ] ; } if ( mat [ i ] [ j ] > principalMax ) { principalMax = mat [ i ] [ j ] ; } } if ( ( i + j ) == ( n - 1 ) ) { if ( mat [ i ] [ j ] < secondaryMin ) { secondaryMin = mat [ i ] [ j ] ; } if ( mat [ i ] [ j ] > secondaryMax ) { secondaryMax = mat [ i ] [ j ] ; } } } } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; } static public void main ( String [ ] args ) { int [ ] [ ] matrix = { { 1 , 2 , 3 , 4 , - 10 } , { 5 , 6 , 7 , 8 , 6 } , { 1 , 2 , 11 , 3 , 4 } , { 5 , 6 , 70 , 5 , 8 } , { 4 , 9 , 7 , 1 , - 5 } } ; diagonalsMinMax ( matrix ) ; } }
import java . io . * ; class GFG { static void indexedSequentialSearch ( int arr [ ] , int n , int k ) { int elements [ ] = new int [ 20 ] ; int indices [ ] = new int [ 20 ] ; int temp , i ; int j = 0 , ind = 0 , start = 0 , end = 0 , set = 0 ; for ( i = 0 ; i < n ; i += 3 ) { elements [ ind ] = arr [ i ] ; indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { System . out . println ( " Not ▁ found " ) ; return ; } else { for ( i = 1 ; i <= ind ; i ++ ) if ( k <= elements [ i ] ) { start = indices [ i - 1 ] ; set = 1 ; end = indices [ i ] ; break ; } } if ( set == 0 ) { start = indices [ i - 1 ] ; end = n ; } for ( i = start ; i <= end ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) System . out . println ( " Found ▁ at ▁ index ▁ " + i ) ; else System . out . println ( " Not ▁ found " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 7 , 8 , 9 , 10 } ; int n = arr . length ; int k = 8 ; indexedSequentialSearch ( arr , n , k ) ; } }
import java . io . * ; class GFG { static int countSegments ( int a [ ] , int n , int x ) { boolean flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; } public static void main ( String [ ] args ) { int a [ ] = { 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 } ; int n = a . length ; int x = 13 ; System . out . println ( countSegments ( a , n , x ) ) ; } }
class GFG { static long count_triples ( int n , int k ) { int i = 0 , j = 0 , l = 0 ; int count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { for ( l = 1 ; l <= n ; l ++ ) { if ( ( i + j ) % k == 0 && ( i + l ) % k == 0 && ( j + l ) % k == 0 ) count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int n = 3 ; int k = 2 ; long ans = count_triples ( n , k ) ; System . out . println ( ans ) ; } }
import java . util . Arrays ; class GFG { static int maxs = 1000001 ; static int kthSmallestLargest ( int [ ] arr , int n , int k ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int hash [ ] = new int [ max_val + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } int count = 0 ; for ( int i = 0 ; i <= max_val ; i ++ ) { while ( hash [ i ] > 0 ) { count ++ ; if ( count == k ) { return i ; } hash [ i ] -- ; } } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 6 , 2 , 9 , 4 , 3 , 16 } ; int n = arr . length , k = 3 ; System . out . println ( " kth ▁ smallest ▁ number ▁ is : ▁ " + kthSmallestLargest ( arr , n , k ) ) ; } }
import java . util . Vector ; import com . google . common . math . BigIntegerMath ; import java . math . * ; class GFG { static int bsearch ( Vector < Integer > A , int key_to_search ) { int n = ( int ) A . size ( ) ; int lg = BigIntegerMath . log2 ( BigInteger . valueOf ( n - 1 ) , RoundingMode . UNNECESSARY ) + 1 ; int pos = 0 ; for ( int i = lg - 1 ; i >= 0 ; i -- ) { if ( A . get ( pos ) == key_to_search ) { return pos ; } int new_pos = pos | ( 1 << i ) ; if ( ( new_pos < n ) && ( A . get ( new_pos ) <= key_to_search ) ) { pos = new_pos ; } } return ( ( A . get ( pos ) == key_to_search ) ? pos : - 1 ) ; } static public void main ( String [ ] args ) { Vector < Integer > A = new Vector < Integer > ( ) ; int [ ] arr = { - 2 , 10 , 100 , 250 , 32315 } ; for ( int i = 0 ; i < arr . length ; i ++ ) { A . add ( arr [ i ] ) ; } System . out . println ( bsearch ( A , 10 ) ) ; } }
import java . io . * ; class GFG { static float findmedian ( int a [ ] , int n1 , int b [ ] , int n2 ) { int i = 0 ; int j = 0 ; int k ; int m1 = - 1 , m2 = - 1 ; for ( k = 0 ; k <= ( n1 + n2 ) / 2 ; k ++ ) { if ( i < n1 && j < n2 ) { if ( a [ i ] < b [ j ] ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } else { m2 = m1 ; m1 = b [ j ] ; j ++ ; } } else if ( i == n1 ) { m2 = m1 ; m1 = b [ j ] ; j ++ ; } else if ( j == n2 ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } } if ( ( n1 + n2 ) % 2 == 0 ) { return ( m1 + m2 ) * ( float ) 1.0 / 2 ; } return m1 ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 12 , 15 , 26 , 38 } ; int b [ ] = { 2 , 13 , 24 } ; int n1 = a . length ; int n2 = b . length ; System . out . println ( findmedian ( a , n1 , b , n2 ) ) ; } }
class Main { static void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " ▁ - - ▁ " + next ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = arr . length ; printNSE ( arr , n ) ; } }
public class Demo { public static int longestSubarray ( int [ ] input ) { int prev = - 1 ; int current , next ; int prevCount = 0 , currentCount = 1 ; int longest = 1 ; current = input [ 0 ] ; for ( int i = 1 ; i < input . length ; i ++ ) { next = input [ i ] ; if ( next == current ) { currentCount ++ ; } else if ( next == prev ) { prevCount += currentCount ; prev = current ; current = next ; currentCount = 1 ; } else { longest = Math . max ( longest , currentCount + prevCount ) ; prev = current ; prevCount = currentCount ; current = next ; currentCount = 1 ; } } return Math . max ( longest , currentCount + prevCount ) ; } public static void main ( String [ ] args ) { int [ ] input = { 5 , 5 , 6 , 7 , 6 } ; System . out . println ( longestSubarray ( input ) ) ; } }
class GFG { static int binarySearch ( int [ ] searchSpace , int s , int e , int num ) { int ans = 0 ; while ( s <= e ) { int mid = ( s + e ) / 2 ; if ( searchSpace [ mid ] >= num ) { ans = mid ; e = mid - 1 ; } else s = mid + 1 ; } return ans ; } static int longestSubArr ( int [ ] arr , int n ) { int [ ] searchSpace = new int [ n ] ; int [ ] index = new int [ n ] ; int j = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( j == 0 searchSpace [ j - 1 ] < arr [ i ] ) { searchSpace [ j ] = arr [ i ] ; index [ j ] = i ; j ++ ; } int idx = binarySearch ( searchSpace , 0 , j - 1 , arr [ i ] ) ; ans = Math . max ( ans , i - index [ idx ] + 1 ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { - 5 , - 1 , 7 , 5 , 1 , - 2 } ; int n = arr . length ; System . out . println ( longestSubArr ( arr , n ) ) ; } }
class GFG { static boolean isSuffix ( String s1 , String s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 . charAt ( n1 - i - 1 ) != s2 . charAt ( n2 - i - 1 ) ) return false ; return true ; } public static void main ( String [ ] args ) { String s1 = " geeks " , s2 = " geeksforgeeks " ; boolean result = isSuffix ( s1 , s2 ) ; if ( result ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static boolean checkIfAllTogether ( String s , char c ) { boolean oneSeen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s . charAt ( i ) == c ) { if ( oneSeen == true ) return false ; while ( i < n && s . charAt ( i ) == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; } public static void main ( String [ ] args ) { String s = "110029" ; if ( checkIfAllTogether ( s , '1' ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static boolean search ( int arr [ ] , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 } ; int x = 130 ; int n = arr . length ; if ( search ( arr , n , x ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; class Even_odd { public static int findValue ( int X , int Y , int P ) { if ( P % 2 == 0 ) return ( Math . max ( X , Y ) / Math . min ( X , Y ) ) ; else return ( Math . max ( 2 * X , Y ) / Math . min ( 2 * X , Y ) ) ; } public static void main ( String [ ] args ) { int X = 1 , Y = 2 , P = 1 ; System . out . println ( findValue ( X , Y , P ) ) ; X = 3 ; Y = 7 ; P = 2 ; System . out . print ( findValue ( X , Y , P ) ) ; } }
import java . util . * ; import java . io . * ; class GFG { static int sum ( int arr [ ] , int from , int to ) { int total = 0 ; for ( int i = from ; i <= to ; i ++ ) total += arr [ i ] ; return total ; } static int findMax ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ 1 ] [ i ] = sum ( arr , 0 , i - 1 ) ; for ( int i = 1 ; i <= k ; i ++ ) dp [ i ] [ 1 ] = arr [ 0 ] ; for ( int j = 2 ; j <= n ; j ++ ) { int best = Integer . MAX_VALUE ; for ( int p = 1 ; p <= j ; p ++ ) best = Math . min ( best , Math . max ( dp [ i - 1 ] [ p ] , sum ( arr , p , j - 1 ) ) ) ; dp [ i ] [ j ] = best ; } } return dp [ k ] [ n ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 20 , 60 , 50 , 30 , 40 } ; int n = arr . length ; int k = 3 ; System . out . println ( findMax ( arr , n , k ) ) ; } }
class GFG { static int countCrossLine ( int arr [ ] , int n ) { int count_crossline = 0 ; int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 4 , 3 , 1 , 2 } ; int n = arr . length ; System . out . print ( countCrossLine ( arr , n ) ) ; } }
import java . util . * ; class GFG { public static int findMaxRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; } public static void main ( String args [ ] ) { int A [ ] = { 1 , 4 , 45 , 6 , - 50 , 10 , 2 } ; int n = A . length ; System . out . println ( findMaxRec ( A , n ) ) ; } }
import java . util . * ; class GFG { static int mod ( int x ) { if ( x >= 0 ) return x ; return - x ; } static void findSquare ( int n ) { int points [ ] [ ] = { { 1 , 2 } , { - 3 , 4 } , { 1 , 78 } , { - 3 , - 7 } } ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x , y ; x = points [ i ] [ 0 ] ; y = points [ i ] [ 1 ] ; a [ i ] = Math . max ( mod ( x ) , mod ( y ) ) ; } Arrays . sort ( a ) ; int index = ( int ) ( Math . floor ( n / 2 ) - 1 ) ; System . out . println ( " Minimum ▁ M ▁ required ▁ is : ▁ " + a [ index ] ) ; } public static void main ( String [ ] args ) { int N ; N = 4 ; findSquare ( N ) ; } }
import java . util . * ; class GFG { static void odd_even ( int arr [ ] , int n ) { Vector < Integer > odd_indexes = new Vector < Integer > ( ) ; Vector < Integer > even_indexes = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . add ( arr [ i ] ) ; else even_indexes . add ( arr [ i ] ) ; } Collections . sort ( odd_indexes ) ; Collections . sort ( even_indexes ) ; for ( int i = 0 ; i < odd_indexes . size ( ) ; i ++ ) System . out . print ( odd_indexes . get ( i ) + " ▁ " ) ; for ( int i = 0 ; i < even_indexes . size ( ) ; i ++ ) System . out . print ( even_indexes . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 7 , 6 , 8 } ; int n = arr . length ; odd_even ( arr , n ) ; } }
import java . util . * ; class GFG { static int minimumIncrease ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; Arrays . sort ( arr ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; } public static void main ( String [ ] args ) { int a = 3 , b = 5 , c = 10 ; System . out . println ( minimumIncrease ( a , b , c ) ) ; } }
import java . lang . * ; import java . util . * ; public class GFG { static int absSumDidd ( int a [ ] ) { Arrays . sort ( a ) ; int midValue = a [ a . length / 2 ] ; int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum = sum + Math . abs ( a [ i ] - midValue ) ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 11 , 14 , 10 , 17 , 15 } ; System . out . print ( absSumDidd ( arr ) ) ; }
import java . util . * ; import java . lang . * ; public class GfG { public final static int SIZE = 26 ; public static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static int countSubsequences ( String str , String str3 ) { int [ ] freq1 = new int [ SIZE ] ; int [ ] freq2 = new int [ SIZE ] ; char [ ] str1 = str . toCharArray ( ) ; char [ ] str2 = str3 . toCharArray ( ) ; int n1 = str . length ( ) ; int n2 = str3 . length ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; int count = 1 ; for ( int i = 0 ; i < SIZE ; i ++ ) if ( freq2 [ i ] != 0 ) { if ( freq2 [ i ] <= freq1 [ i ] ) count = count * binomialCoeff ( freq1 [ i ] , freq2 [ i ] ) ; else return 0 ; } return count ; } public static void main ( String argc [ ] ) { String str1 = " abacd " ; String str2 = " abc " ; System . out . println ( " Count ▁ = ▁ " + countSubsequences ( str1 , str2 ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int findOccurrences ( String str1 , String substr1 ) { int counter = 0 ; char [ ] str = str1 . toCharArray ( ) ; char [ ] substr = substr1 . toCharArray ( ) ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) { for ( int j = i + 1 ; j < str1 . length ( ) ; j ++ ) { if ( str [ j ] == substr [ 1 ] ) { for ( int k = j + 1 ; k < str1 . length ( ) ; k ++ ) { if ( str [ k ] == substr [ 2 ] ) counter ++ ; } } } } } return counter ; } public static void main ( String argc [ ] ) { String str = " GFGFGYSYIOIWIN " ; String substr = " GFG " ; System . out . println ( findOccurrences ( str , substr ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int findOccurrences ( String str1 , String substr1 ) { int n = str1 . length ( ) ; char [ ] str = str1 . toCharArray ( ) ; char [ ] substr = substr1 . toCharArray ( ) ; int [ ] preLeft = new int [ n ] ; int [ ] preRight = new int [ n ] ; if ( str [ 0 ] == substr [ 0 ] ) preLeft [ 0 ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) preLeft [ i ] = preLeft [ i - 1 ] + 1 ; else preLeft [ i ] = preLeft [ i - 1 ] ; } if ( str [ n - 1 ] == substr [ 2 ] ) preRight [ n - 1 ] ++ ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == substr [ 2 ] ) preRight [ i ] = preRight [ i + 1 ] + 1 ; else preRight [ i ] = preRight [ i + 1 ] ; } int counter = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ 1 ] ) { int total = preLeft [ i - 1 ] * preRight [ i + 1 ] ; counter += total ; } } return counter ; } public static void main ( String argc [ ] ) { String str = " GFGFGYSYIOIWIN " ; String substr = " GFG " ; System . out . println ( findOccurrences ( str , substr ) ) ; } }
class GFG { static void findString ( String str , int n , int k ) { if ( k == 0 ) { System . out . println ( str ) ; ; return ; } String str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 . charAt ( i ) != ' a ' ) { str2 = str2 . substring ( 0 , i ) + ' a ' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } if ( p < k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == ' a ' ) { str2 = str2 . substring ( 0 , i ) + ' b ' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } System . out . println ( str2 ) ; } public static void main ( String [ ] args ) { String str = " pqrs " ; int n = str . length ( ) ; int k = 2 ; findString ( str , n , k ) ; } }
import java . util . * ; class GFG { static void printSubsequences ( String s ) { char [ ] str = s . toCharArray ( ) ; int n = str . length ; int opsize = ( int ) ( Math . pow ( 2 , n - 1 ) ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { String str = " AB " ; printSubsequences ( str ) ; } }
import java . util . * ; class GFG { static int countDeletions ( String s ) { int ans = 0 ; char [ ] str = s . toCharArray ( ) ; for ( int i = 0 ; i < str . length - 1 ; i ++ ) if ( str [ i ] == str [ i + 1 ] ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { String str = " AAABBB " ; System . out . println ( countDeletions ( str ) ) ; } }
import java . io . * ; class GFG { static String evenlength ( String n ) { String res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n . charAt ( j ) ; return res ; } public static void main ( String [ ] args ) { String n = "10" ; System . out . println ( evenlength ( n ) ) ; } }
import java . util . * ; class GfG { boolean uniqueCharacters ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) return false ; return true ; } public static void main ( String args [ ] ) { GfG obj = new GfG ( ) ; String input = " GeeksforGeeks " ; if ( obj . uniqueCharacters ( input ) ) System . out . println ( " The ▁ String ▁ " + input + " ▁ has ▁ all ▁ unique ▁ characters " ) ; else System . out . println ( " The ▁ String ▁ " + input + " ▁ has ▁ duplicate ▁ characters " ) ; } }
public class GFG { static int findIndex ( String str ) { int len = str . length ( ) ; int open [ ] = new int [ len + 1 ] ; int close [ ] = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str . charAt ( 0 ) == ' ( ' ) open [ 1 ] = 1 ; if ( str . charAt ( len - 1 ) == ' ) ' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ' ) ' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; } public static void main ( String [ ] args ) { String str = " ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) " ; System . out . println ( findIndex ( str ) ) ; } }
import java . util . * ; class GFG { static String decimalToBinary ( double num , int k_prec ) { String binary = " " ; int Integral = ( int ) num ; double fractional = num - Integral ; while ( Integral > 0 ) { int rem = Integral % 2 ; binary += ( ( char ) ( rem + '0' ) ) ; Integral /= 2 ; } binary = reverse ( binary ) ; binary += ( ' . ' ) ; while ( k_prec -- > 0 ) { fractional *= 2 ; int fract_bit = ( int ) fractional ; if ( fract_bit == 1 ) { fractional -= fract_bit ; binary += ( char ) ( 1 + '0' ) ; } else { binary += ( char ) ( 0 + '0' ) ; } } return binary ; } static String reverse ( String input ) { char [ ] temparray = input . toCharArray ( ) ; int left , right = 0 ; right = temparray . length - 1 ; for ( left = 0 ; left < right ; left ++ , right -- ) { char temp = temparray [ left ] ; temparray [ left ] = temparray [ right ] ; temparray [ right ] = temp ; } return String . valueOf ( temparray ) ; } public static void main ( String [ ] args ) { double n = 4.47 ; int k = 3 ; System . out . println ( decimalToBinary ( n , k ) ) ; n = 6.986 ; k = 5 ; System . out . println ( decimalToBinary ( n , k ) ) ; } }
class GFG { static boolean isSmaller ( String str1 , String str2 ) { int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; if ( n1 < n2 ) return true ; if ( n2 < n1 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 . charAt ( i ) < str2 . charAt ( i ) ) return true ; else if ( str1 . charAt ( i ) > str2 . charAt ( i ) ) return false ; } return false ; } static String findDiff ( String str1 , String str2 ) { if ( isSmaller ( str1 , str2 ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; int diff = n1 - n2 ; int carry = 0 ; for ( int i = n2 - 1 ; i >= 0 ; i -- ) { int sub = ( ( ( int ) str1 . charAt ( i + diff ) - ( int ) '0' ) - ( ( int ) str2 . charAt ( i ) - ( int ) '0' ) - carry ) ; if ( sub < 0 ) { sub = sub + 10 ; carry = 1 ; } else carry = 0 ; str += String . valueOf ( sub ) ; } for ( int i = n1 - n2 - 1 ; i >= 0 ; i -- ) { if ( str1 . charAt ( i ) == '0' && carry > 0 ) { str += "9" ; continue ; } int sub = ( ( ( int ) str1 . charAt ( i ) - ( int ) '0' ) - carry ) ; str += String . valueOf ( sub ) ; carry = 0 ; } return new StringBuilder ( str ) . reverse ( ) . toString ( ) ; } public static void main ( String [ ] args ) { String str1 = "88" ; String str2 = "1079" ; System . out . println ( findDiff ( str1 , str2 ) ) ; } }
public class GFG { static final int MAX_CHAR = 26 ; static boolean areKAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] hash_str1 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hash_str1 [ str1 . charAt ( i ) - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 . charAt ( i ) - ' a ' ] > 0 ) hash_str1 [ str2 . charAt ( i ) - ' a ' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; } public static void main ( String args [ ] ) { String str1 = " fodr " ; String str2 = " gork " ; int k = 2 ; if ( areKAnagrams ( str1 , str2 , k ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static char getDigit ( int N , int d ) { String str = Integer . toString ( N ) ; return str . charAt ( d - 1 ) ; } static char getNthChar ( int N ) { int sum = 0 , nine = 9 ; int dist = 0 , len ; for ( len = 1 ; ; len ++ ) { sum += nine * len ; dist += nine ; if ( sum >= N ) { sum -= nine * len ; dist -= nine ; N -= sum ; break ; } nine *= 10 ; } int diff = ( int ) ( Math . ceil ( ( double ) ( N ) / ( double ) ( len ) ) ) ; int d = N % len ; if ( d == 0 ) d = len ; return getDigit ( dist + diff , d ) ; } public static void main ( String [ ] args ) { int N = 251 ; System . out . println ( getNthChar ( N ) ) ; } }
class GFG { static int findCount ( String str ) { int result = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == ( str . charAt ( i ) - ' a ' ) || i == ( str . charAt ( i ) - ' A ' ) ) { result ++ ; } } return result ; } public static void main ( String [ ] args ) { String str = " AbgdeF " ; System . out . print ( findCount ( str ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class binStr { public static void print ( char str [ ] , int index ) { if ( index == str . length ) { System . out . println ( str ) ; return ; } if ( str [ index ] == ' ? ' ) { str [ index ] = '0' ; print ( str , index + 1 ) ; str [ index ] = '1' ; print ( str , index + 1 ) ; str [ index ] = ' ? ' ; } else print ( str , index + 1 ) ; } public static void main ( String [ ] args ) { String input = "1 ? ? 0?101" ; char [ ] str = input . toCharArray ( ) ; print ( str , 0 ) ; } }
import java . io . * ; class GFG { static int countOccurrences ( int x , int d ) { int count = 0 ; while ( x > 0 ) { if ( x % 10 == d ) count ++ ; x = x / 10 ; } return count ; } static int maxOccurring ( int x ) { if ( x < 0 ) x = - x ; int result = 0 ; int max_count = 1 ; for ( int d = 0 ; d <= 9 ; d ++ ) { int count = countOccurrences ( x , d ) ; if ( count >= max_count ) { max_count = count ; result = d ; } } return result ; } public static void main ( String [ ] args ) { int x = 1223355 ; System . out . println ( " Max ▁ occurring ▁ digit ▁ is ▁ " + maxOccurring ( x ) ) ; } }
class GFG { static int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 8 , 1 , 2 , 12 } ; int n = arr . length ; System . out . println ( " Max ▁ subarray ▁ XOR ▁ is ▁ " + maxSubarrayXOR ( arr , n ) ) ; } }
class GFG { static final int NO_OF_CHARS = 256 ; static char count [ ] = new char [ NO_OF_CHARS ] ; static void getCharCountArray ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) ] ++ ; } static int firstNonRepeating ( String str ) { getCharCountArray ( str ) ; int index = - 1 , i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( count [ str . charAt ( i ) ] == 1 ) { index = i ; break ; } } return index ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int index = firstNonRepeating ( str ) ; System . out . println ( index == - 1 ? " Either ▁ all ▁ characters ▁ are ▁ repeating ▁ or ▁ string ▁ " + " is ▁ empty " : " First ▁ non - repeating ▁ character ▁ is ▁ " + str . charAt ( index ) ) ; } }
class GFG { static void divideString ( String str , int n ) { int str_size = str . length ( ) ; int part_size ; if ( str_size % n != 0 ) { System . out . println ( " Invalid ▁ Input : ▁ String ▁ size " + " is ▁ not ▁ divisible ▁ by ▁ n " ) ; return ; } part_size = str_size / n ; for ( int i = 0 ; i < str_size ; i ++ ) { if ( i % part_size == 0 ) System . out . println ( ) ; System . out . print ( str . charAt ( i ) ) ; } } public static void main ( String [ ] args ) { String str = " a _ simple _ divide _ string _ quest " ; divideString ( str , 4 ) ; } }
class GfG { static int MAX = 100 ; static int MOD = 1000000009 ; static int power ( int n ) { if ( n <= 1 ) { return 1 ; } n -- ; int res [ ] [ ] = { { 1 , 0 } , { 0 , 1 } } ; int tMat [ ] [ ] = { { 2 , 3 } , { 1 , 0 } } ; while ( n > 0 ) { if ( n % 2 == 1 ) { int tmp [ ] [ ] = new int [ 2 ] [ 2 ] ; tmp [ 0 ] [ 0 ] = ( res [ 0 ] [ 0 ] * tMat [ 0 ] [ 0 ] + res [ 0 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 0 ] [ 1 ] = ( res [ 0 ] [ 0 ] * tMat [ 0 ] [ 1 ] + res [ 0 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; tmp [ 1 ] [ 0 ] = ( res [ 1 ] [ 0 ] * tMat [ 0 ] [ 0 ] + res [ 1 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 1 ] [ 1 ] = ( res [ 1 ] [ 0 ] * tMat [ 0 ] [ 1 ] + res [ 1 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; res [ 0 ] [ 0 ] = tmp [ 0 ] [ 0 ] ; res [ 0 ] [ 1 ] = tmp [ 0 ] [ 1 ] ; res [ 1 ] [ 0 ] = tmp [ 1 ] [ 0 ] ; res [ 1 ] [ 1 ] = tmp [ 1 ] [ 1 ] ; } n = n / 2 ; int tmp [ ] [ ] = new int [ 2 ] [ 2 ] ; tmp [ 0 ] [ 0 ] = ( tMat [ 0 ] [ 0 ] * tMat [ 0 ] [ 0 ] + tMat [ 0 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 0 ] [ 1 ] = ( tMat [ 0 ] [ 0 ] * tMat [ 0 ] [ 1 ] + tMat [ 0 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; tmp [ 1 ] [ 0 ] = ( tMat [ 1 ] [ 0 ] * tMat [ 0 ] [ 0 ] + tMat [ 1 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 1 ] [ 1 ] = ( tMat [ 1 ] [ 0 ] * tMat [ 0 ] [ 1 ] + tMat [ 1 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; tMat [ 0 ] [ 0 ] = tmp [ 0 ] [ 0 ] ; tMat [ 0 ] [ 1 ] = tmp [ 0 ] [ 1 ] ; tMat [ 1 ] [ 0 ] = tmp [ 1 ] [ 0 ] ; tMat [ 1 ] [ 1 ] = tmp [ 1 ] [ 1 ] ; } return ( res [ 0 ] [ 0 ] * 1 + res [ 0 ] [ 1 ] * 1 ) % MOD ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( power ( n ) ) ; } }
import java . util . Arrays ; class GFG { static boolean isFeasible ( int mid , int arr [ ] , int n , int k ) { int pos = arr [ 0 ] ; int elements = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - pos >= mid ) { pos = arr [ i ] ; elements ++ ; if ( elements == k ) return true ; } } return false ; } static int largestMinDist ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int res = - 1 ; int left = 1 , right = arr [ n - 1 ] ; while ( left < right ) { int mid = ( left + right ) / 2 ; if ( isFeasible ( mid , arr , n , k ) ) { res = Math . max ( res , mid ) ; left = mid + 1 ; } else right = mid ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 8 , 4 , 9 } ; int n = arr . length ; int k = 3 ; System . out . print ( largestMinDist ( arr , n , k ) ) ; } }
public class Test { public static int floorSqrt ( int x ) { if ( x == 0 x == 1 ) return x ; long start = 1 , end = x , ans = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid == x ) return ( int ) mid ; if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } end = mid - 1 ; } return ( int ) ans ; } public static void main ( String args [ ] ) { int x = 11 ; System . out . println ( floorSqrt ( x ) ) ; } }
import java . io . * ; class GFG { static int countOdd ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = ( n - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } else { m = ( ( n - 1 ) - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } } return coun ; } static int countEven ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = ( ( n - 1 ) - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } else { m = ( n - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } } return coun ; } public static void main ( String [ ] args ) { int n = 5 ; if ( n >= 1 ) System . out . println ( countOdd ( n ) ) ; else System . out . println ( countEven ( n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static float ellipse ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float x = ( float ) ( 3.14 * l * b ) / 4 ; return x ; } public static void main ( String args [ ] ) { float a = 5 , b = 3 ; System . out . println ( ellipse ( a , b ) ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static void noOfSquares ( int x1 , int y1 , int x2 , int y2 ) { int dx = Math . abs ( x2 - x1 ) ; int dy = Math . abs ( y2 - y1 ) ; int ans = dx + dy - __gcd ( dx , dy ) ; System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int x1 = 1 , y1 = 1 , x2 = 4 , y2 = 3 ; noOfSquares ( x1 , y1 , x2 , y2 ) ; } }
class GfG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long countPaths ( int x1 , int y1 , int x2 , int y2 ) { int m = Math . abs ( x1 - x2 ) ; int n = Math . abs ( y1 - y2 ) ; return ( binomialCoeff ( m + n , n ) ) ; } public static void main ( String [ ] args ) { int x1 = 2 , y1 = 3 , x2 = 4 , y2 = 5 ; System . out . println ( countPaths ( x1 , y1 , x2 , y2 ) ) ; } }
class GFG { static double areaCircle ( double b ) { double area = ( double ) 3.1415926 * b * b ; return area ; } public static void main ( String args [ ] ) { float a = 10 , b = 8 ; System . out . println ( areaCircle ( b ) ) ; } }
import java . util . * ; class solution { static void section ( double x1 , double x2 , double y1 , double y2 , double z1 , double z2 , double m , double n ) { double x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; double y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; double z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; System . out . print ( " ( " + x + " , ▁ " ) ; System . out . print ( y + " , ▁ " ) ; System . out . println ( z + " ) " ) ; } public static void main ( String arr [ ] ) { double x1 = 2 , x2 = 4 , y1 = - 1 , y2 = 3 , z1 = 4 , z2 = 2 , m = 2 , n = 3 ; section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) ; } }
import java . io . * ; class GFG { static float findRadiusOfcircumcircle ( float n , float a ) { if ( n < 0 a < 0 ) return - 1 ; float radius = ( float ) ( a / Math . sqrt ( 2 - ( 2 * Math . cos ( 360 / n ) ) ) ) ; return radius ; } public static void main ( String [ ] args ) { float n = 5 , a = 6 ; System . out . println ( findRadiusOfcircumcircle ( n , a ) ) ; } }
import java . io . * ; class GFG { static float findRadiusOfIncircle ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; float p = ( a + b + c ) / 2 ; float area = ( float ) Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float radius = area / p ; return radius ; } public static void main ( String [ ] args ) { float a = 2 , b = 2 , c = 3 ; System . out . println ( findRadiusOfIncircle ( a , b , c ) ) ; } }
import java . util . * ; class solution { static float area ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { double a = Math . pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ; float area = ( float ) Math . sqrt ( a ) ; area = area / 2 ; return area ; } public static void main ( String arr [ ] ) { int x1 = - 2 ; int y1 = 0 ; int z1 = - 5 ; int x2 = 1 ; int y2 = - 2 ; int z2 = - 1 ; float a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) ; System . out . println ( " Area = ▁ " + a ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static float trapezoidarea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 3 * ( float ) Math . sqrt ( 3 ) * ( float ) Math . pow ( r , 2 ) ) / 4 ; return a ; } public static void main ( String args [ ] ) { float r = 5 ; System . out . printf ( " % .3f " , trapezoidarea ( r ) ) ; } }
class GFG { static float rectanglearea ( float r ) { if ( r < 0 ) return - 1 ; float a = r * r ; return a ; } public static void main ( String [ ] args ) { float r = 5 ; System . out . println ( ( int ) rectanglearea ( r ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int maxLines ( int n , int x1 [ ] , int y1 [ ] , int x2 [ ] , int y2 [ ] ) { Set < Double > s = new HashSet < Double > ( ) ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = Integer . MAX_VALUE ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . add ( slope ) ; } return s . size ( ) ; } public static void main ( String args [ ] ) { int n = 2 , x1 [ ] = { 1 , 2 } , y1 [ ] = { 1 , 2 } , x2 [ ] = { 2 , 4 } , y2 [ ] = { 2 , 10 } ; System . out . print ( maxLines ( n , x1 , y1 , x2 , y2 ) ) ; } }
public class GFG { static float area ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float area = ( float ) Math . sqrt ( Math . pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; return area ; } public static void main ( String args [ ] ) { float x1 = 3 ; float y1 = 1 ; float z1 = - 2 ; float x2 = 1 ; float y2 = - 3 ; float z2 = 4 ; float a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) ; System . out . println ( " Area ▁ = ▁ " + a ) ; } }
import java . util . * ; class GFG { static int max_intersection ( int center [ ] , int length , int k ) { Arrays . sort ( center ) ; if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) { return 0 ; } else if ( center [ 2 ] - center [ 0 ] >= 2 * k ) { return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; } else return length ; } public static void main ( String args [ ] ) { int center [ ] = { 1 , 2 , 3 } ; int L = 1 ; int K = 1 ; System . out . println ( max_intersection ( center , L , K ) ) ; } }
public class Haversine { static double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = Math . toRadians ( lat2 - lat1 ) ; double dLon = Math . toRadians ( lon2 - lon1 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; double rad = 6371 ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; } public static void main ( String [ ] args ) { double lat1 = 51.5007 ; double lon1 = 0.1246 ; double lat2 = 40.6892 ; double lon2 = 74.0445 ; System . out . println ( haversine ( lat1 , lon1 , lat2 , lon2 ) + " ▁ K . M . " ) ; } }
import java . io . * ; class GFG { static int pentatopeNum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) ) / 24 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( pentatopeNum ( n ) ) ; n = 11 ; System . out . println ( pentatopeNum ( n ) ) ; } }
import java . io . * ; class GFG { static int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( heptagonalNumber ( n ) ) ; n = 15 ; System . out . println ( heptagonalNumber ( n ) ) ; } }
import java . io . * ; class GFG { static int icosidigonal_num ( int n ) { return ( 20 * n * n - 18 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( n + " th ▁ Icosidigonal ▁ number ▁ : " ) ; System . out . println ( icosidigonal_num ( n ) ) ; n = 8 ; System . out . print ( n + " th ▁ Icosidigonal ▁ number ▁ : " ) ; System . out . println ( icosidigonal_num ( n ) ) ; } }
class GfG { static int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( power ( n ) ) ; } }
class GFG { static void findPoint ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( " ( " + ( int ) ( 2 * x2 - x1 ) + " , " + ( int ) ( 2 * y2 - y1 ) + " ▁ ) " ) ; } public static void main ( String args [ ] ) { int x1 = 0 , y1 = 0 , x2 = 1 , y2 = 1 ; findPoint ( x1 , y1 , x2 , y2 ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void parallel ( int a [ ] [ ] ) { boolean x = true , y = true ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; } if ( x ) System . out . println ( " Parallel ▁ to ▁ Y ▁ Axis " ) ; else if ( y ) System . out . println ( " Parallel ▁ to ▁ X ▁ Axis " ) ; else System . out . println ( " Not ▁ parallel ▁ to ▁ X " + " ▁ and ▁ Y ▁ axis " ) ; } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 2 } , { 1 , 4 } , { 1 , 6 } , { 1 , 0 } } ; parallel ( a ) ; } }
public class TriangularPyramidNumber { public static int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; } public static void main ( String [ ] args ) { System . out . println ( numberOfSticks ( 7 ) ) ; } }
class GFG { static int find_Area ( int r ) { return ( 2 * r * r ) ; } public static void main ( String [ ] args ) { int r = 3 ; System . out . print ( " ▁ Area ▁ of ▁ square ▁ = ▁ " + find_Area ( r ) ) ; } }
public class GFG { public static int checkValidity ( int a , int b , int c ) { if ( a + b <= c a + c <= b b + c <= a ) return 0 ; else return 1 ; } public static void main ( String args [ ] ) { int a = 7 , b = 10 , c = 5 ; if ( ( checkValidity ( a , b , c ) ) == 1 ) System . out . print ( " Valid " ) ; else System . out . print ( " Invalid " ) ; } }
class GFG { static final int M = 3 ; static final int N = 3 ; static int contribution_height ( int current , int previous ) { return Math . abs ( current - previous ) ; } static int surfaceArea ( int A [ ] [ ] ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int up = 0 ; int left = 0 ; if ( i > 0 ) up = A [ i - 1 ] [ j ] ; if ( j > 0 ) left = A [ i ] [ j - 1 ] ; ans += contribution_height ( A [ i ] [ j ] , up ) + contribution_height ( A [ i ] [ j ] , left ) ; if ( i == N - 1 ) ans += A [ i ] [ j ] ; if ( j == M - 1 ) ans += A [ i ] [ j ] ; } } ans += N * M * 2 ; return ans ; } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 3 , 4 } , { 2 , 2 , 3 } , { 1 , 2 , 4 } } ; System . out . println ( surfaceArea ( A ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static double area_of_tetrahedron ( int side ) { return ( Math . sqrt ( 3 ) * ( side * side ) ) ; } public static void main ( String [ ] args ) { int side = 3 ; System . out . println ( " Area ▁ of ▁ Tetrahedron ▁ = " + area_of_tetrahedron ( side ) ) ; } }
import java . io . * ; class Tetrahedron { static double vol_tetra ( int side ) { double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; } public static void main ( String [ ] args ) { int side = 3 ; double vol = vol_tetra ( side ) ; vol = ( double ) Math . round ( vol * 100 ) / 100 ; System . out . println ( vol ) ; } }
import java . io . * ; class GFG { static int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; } public static void main ( String [ ] args ) { int x = 3 ; System . out . println ( numberOfWays ( x ) ) ; } }
import java . io . * ; class GFG { static float area_equi_triangle ( float side ) { return ( float ) ( ( ( Math . sqrt ( 3 ) ) / 4 ) * side * side ) ; } static float peri_equi_triangle ( float side ) { return 3 * side ; } public static void main ( String arg [ ] ) { float side = 4 ; System . out . print ( " Area ▁ of ▁ Equilateral ▁ Triangle : " ) ; System . out . println ( area_equi_triangle ( side ) ) ; System . out . print ( " Perimeter ▁ of ▁ Equilateral ▁ Triangle : " ) ; System . out . println ( peri_equi_triangle ( side ) ) ; } }
class GFG { static double areaCuboid ( double l , double h , double w ) { return ( l * h * w ) ; } static double surfaceAreaCuboid ( double l , double h , double w ) { return ( 2 * l * w + 2 * w * h + 2 * l * h ) ; } public static void main ( String [ ] args ) { double l = 1 ; double h = 5 ; double w = 7 ; System . out . println ( " Area ▁ = ▁ " + areaCuboid ( l , h , w ) ) ; System . out . println ( " Total ▁ Surface ▁ Area ▁ = ▁ " + surfaceAreaCuboid ( l , h , w ) ) ; } }
import java . io . * ; class Geometry { static double circumference ( double r ) { double PI = 3.1415 ; double cir = 2 * PI * r ; return cir ; } public static void main ( String [ ] args ) { double r = 5 ; double result = Math . round ( circumference ( r ) * 1000 ) / 1000.0 ; System . out . println ( " Circumference ▁ = ▁ " + result ) ; } }
import java . io . * ; class GFG { static void cool_line ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { if ( ( y3 - y2 ) * ( x2 - x1 ) == ( y2 - y1 ) * ( x3 - x2 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int a1 = 1 , a2 = 1 , a3 = 0 , b1 = 1 , b2 = 6 , b3 = 9 ; cool_line ( a1 , b1 , a2 , b2 , a3 , b3 ) ; } }
import java . util . * ; class GFG { public static long rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; } public static void main ( String [ ] args ) { int n = 5 , m = 4 ; System . out . println ( rectCount ( n , m ) ) ; } }
class GFG { static int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( countRect ( n ) ) ; } }
import java . io . * ; class GFG { public static void main ( String [ ] args ) { int ax = 5 , ay = 0 ; int bx = 1 , by = 1 ; int cx = 2 , cy = 5 ; System . out . println ( ax + ( cx - bx ) + " , ▁ " + ay + ( cy - by ) ) ; } }
import java . io . * ; import static java . lang . Math . pow ; public class A { static void bestApproximate ( int x [ ] , int y [ ] ) { int n = x . length ; double m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; System . out . println ( " m ▁ = ▁ " + m ) ; System . out . println ( " c ▁ = ▁ " + c ) ; } public static void main ( String args [ ] ) { int x [ ] = { 1 , 2 , 3 , 4 , 5 } ; int y [ ] = { 14 , 27 , 40 , 55 , 68 } ; bestApproximate ( x , y ) ; } }
import java . io . * ; class GFG { static int size = 4 ; static boolean checkStar ( int mat [ ] [ ] ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] == 1 ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } } ; if ( checkStar ( mat ) ) System . out . print ( " Star ▁ Graph " ) ; else System . out . print ( " Not ▁ a ▁ Star ▁ Graph " ) ; } }
import java . io . * ; class GFG { static int getMinSteps ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int min = dp [ i - 1 ] ; if ( i % 2 == 0 ) { min = Math . min ( min , dp [ i / 2 ] ) ; } if ( i % 3 == 0 ) { min = Math . min ( min , dp [ i / 3 ] ) ; } dp [ i ] = min + 1 ; } return dp [ n ] ; } public static void main ( String [ ] args ) { int n = 14 ; System . out . print ( getMinSteps ( n ) ) ; } }
public class Improve { static boolean isVowel ( char c ) { String vowel = " aeiou " ; for ( int i = 0 ; i < vowel . length ( ) ; ++ i ) if ( vowel . charAt ( i ) == c ) return true ; return false ; } static boolean printRLE ( String str , String typed ) { int n = str . length ( ) , m = typed . length ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != typed . charAt ( j ) ) return false ; if ( isVowel ( str . charAt ( i ) ) == false ) { j ++ ; continue ; } int count1 = 1 ; while ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) { count1 ++ ; i ++ ; } int count2 = 1 ; while ( j < m - 1 && typed . charAt ( j ) == str . charAt ( i ) ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) return false ; } return true ; } public static void main ( String args [ ] ) { String name = " alex " , typed = " aaalaeex " ; if ( printRLE ( name , typed ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static boolean check ( int degree [ ] , int n ) { int deg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { deg_sum += degree [ i ] ; } return ( 2 * ( n - 1 ) == deg_sum ) ; } public static void main ( String [ ] args ) { int n = 5 ; int degree [ ] = { 2 , 3 , 1 , 1 , 1 } ; if ( check ( degree , n ) ) { System . out . println ( " Tree " ) ; } else { System . out . println ( " Graph " ) ; } } }
class GFG { static boolean isInorder ( int [ ] arr , int n ) { if ( n == 0 n == 1 ) { return true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 19 , 23 , 25 , 30 , 45 } ; int n = arr . length ; if ( isInorder ( arr , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " Non " ) ; } } }
class GFG { private static void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + " ▁ " ) ; printSorted ( arr , start * 2 + 2 , end ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 } ; printSorted ( arr , 0 , arr . length - 1 ) ; } }
class GFG { static int i = 0 ; static boolean isLeaf ( int pre [ ] , int n , int min , int max ) { if ( i >= n ) { return false ; } if ( pre [ i ] > min && pre [ i ] < max ) { i ++ ; boolean left = isLeaf ( pre , n , min , pre [ i - 1 ] ) ; boolean right = isLeaf ( pre , n , pre [ i - 1 ] , max ) ; if ( ! left && ! right ) { System . out . print ( pre [ i - 1 ] + " ▁ " ) ; } return true ; } return false ; } static void printLeaves ( int preorder [ ] , int n ) { isLeaf ( preorder , n , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; } public static void main ( String [ ] args ) { int preorder [ ] = { 890 , 325 , 290 , 530 , 965 } ; int n = preorder . length ; printLeaves ( preorder , n ) ; } }
import java . util . * ; class GFG { static void pairs ( int arr [ ] , int n , int k ) { int smallest = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } System . out . println ( " Minimal ▁ Value ▁ = ▁ " + smallest ) ; System . out . println ( " Total ▁ Pairs ▁ = ▁ " + count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 7 , 5 , 1 , 9 , 9 } ; int k = 12 ; int n = arr . length ; pairs ( arr , n , k ) ; } }
class GFG { public static void main ( String [ ] args ) { int a [ ] = { 5 , 1 , 14 , 4 , 15 , 9 , 7 , 20 , 11 } ; int key = 20 ; int arraySize = a . length ; int count = 0 ; for ( int i = 0 ; i < arraySize ; i ++ ) { if ( a [ i ] <= key ) { count += 1 ; } } System . out . println ( " Rank ▁ of ▁ " + key + " ▁ in ▁ stream ▁ is : ▁ " + ( count - 1 ) ) ; } }
import java . io . * ; class GFG { static int MAX = 100 ; static void middlesum ( int mat [ ] [ ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; System . out . println ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " + row_sum ) ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; System . out . println ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " + col_sum ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 2 , 5 , 7 } , { 3 , 7 , 2 } , { 5 , 6 , 9 } } ; middlesum ( mat , 3 ) ; } }
class GFG { static final int M = 3 ; static final int N = 3 ; static void rotateMatrix ( int matrix [ ] [ ] , int k ) { int temp [ ] = new int [ M ] ; k = k % M ; for ( int i = 0 ; i < N ; i ++ ) { for ( int t = 0 ; t < M - k ; t ++ ) temp [ t ] = matrix [ i ] [ t ] ; for ( int j = M - k ; j < M ; j ++ ) matrix [ i ] [ j - M + k ] = matrix [ i ] [ j ] ; for ( int j = k ; j < M ; j ++ ) matrix [ i ] [ j ] = temp [ j - k ] ; } } static void displayMatrix ( int matrix [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) System . out . print ( matrix [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int matrix [ ] [ ] = { { 12 , 23 , 34 } , { 45 , 56 , 67 } , { 78 , 89 , 91 } } ; int k = 2 ; rotateMatrix ( matrix , k ) ; displayMatrix ( matrix ) ; } }
import java . io . * ; class GFG { static int N = 3 ; static void multiply ( int mat [ ] [ ] , int res [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { res [ i ] [ j ] = 0 ; for ( int k = 0 ; k < N ; k ++ ) res [ i ] [ j ] += mat [ i ] [ k ] * mat [ k ] [ j ] ; } } } static boolean InvolutoryMatrix ( int mat [ ] [ ] ) { int res [ ] [ ] = new int [ N ] [ N ] ; multiply ( mat , res ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j && res [ i ] [ j ] != 1 ) return false ; if ( i != j && res [ i ] [ j ] != 0 ) return false ; } } return true ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 0 , 0 } , { 0 , - 1 , 0 } , { 0 , 0 , - 1 } } ; if ( InvolutoryMatrix ( mat ) ) System . out . println ( " Involutory ▁ Matrix " ) ; else System . out . println ( " Not ▁ Involutory ▁ Matrix " ) ; } }
import java . io . * ; public class Interchange { static void interchangeFirstLast ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } } public static void main ( String args [ ] ) throws IOException { int m [ ] [ ] = { { 8 , 9 , 7 , 6 } , { 4 , 7 , 6 , 5 } , { 3 , 2 , 1 , 8 } , { 9 , 9 , 7 , 7 } } ; interchangeFirstLast ( m ) ; for ( int i = 0 ; i < m . length ; i ++ ) { for ( int j = 0 ; j < m [ 0 ] . length ; j ++ ) System . out . print ( m [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } }
import java . io . * ; public class markov { static boolean checkMarkov ( double m [ ] [ ] ) { for ( int i = 0 ; i < m . length ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < m [ i ] . length ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; } public static void main ( String args [ ] ) { double m [ ] [ ] = { { 0 , 0 , 1 } , { 0.5 , 0 , 0.5 } , { 1 , 0 , 0 } } ; if ( checkMarkov ( m ) ) System . out . println ( " ▁ yes ▁ " ) ; else System . out . println ( " ▁ no ▁ " ) ; } }
import java . io . * ; class GFG { static int N = 4 ; static boolean isDiagonalMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 4 , 0 , 0 , 0 } , { 0 , 7 , 0 , 0 } , { 0 , 0 , 5 , 0 } , { 0 , 0 , 0 , 1 } } ; if ( isDiagonalMatrix ( mat ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int N = 4 ; static boolean isScalarMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 2 , 0 , 0 , 0 } , { 0 , 2 , 0 , 0 } , { 0 , 0 , 2 , 0 } , { 0 , 0 , 0 , 2 } } ; if ( isScalarMatrix ( mat ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int N = 3 ; static boolean isMagicSquare ( int mat [ ] [ ] ) { int sum = 0 , sum2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum = sum + mat [ i ] [ i ] ; for ( int i = 0 ; i < N ; i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ; if ( sum != sum2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) rowSum += mat [ i ] [ j ] ; if ( rowSum != sum ) return false ; } for ( int i = 0 ; i < N ; i ++ ) { int colSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) colSum += mat [ j ] [ i ] ; if ( sum != colSum ) return false ; } return true ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 2 , 7 , 6 } , { 9 , 5 , 1 } , { 4 , 3 , 8 } } ; if ( isMagicSquare ( mat ) ) System . out . println ( " Magic ▁ Square " ) ; else System . out . println ( " Not ▁ a ▁ magic " + " ▁ Square " ) ; } }
import java . util . * ; class GFG { static final int SIZE = 10 ; static int subCount ( int arr [ ] , int n , int k ) { int mod [ ] = new int [ k ] ; Arrays . fill ( mod , 0 ) ; int cumSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumSum += arr [ i ] ; mod [ ( ( cumSum % k ) + k ) % k ] ++ ; } int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( mod [ i ] > 1 ) result += ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 ; result += mod [ 0 ] ; return result ; } static int countSubmatrix ( int mat [ ] [ ] , int n , int k ) { int tot_count = 0 ; int left , right , i ; int temp [ ] = new int [ n ] ; for ( left = 0 ; left < n ; left ++ ) { Arrays . fill ( temp , 0 ) ; for ( right = left ; right < n ; right ++ ) { for ( i = 0 ; i < n ; ++ i ) temp [ i ] += mat [ i ] [ right ] ; tot_count += subCount ( temp , n , k ) ; } } return tot_count ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 5 , - 1 , 6 } , { - 2 , 3 , 8 } , { 7 , 4 , - 9 } } ; int n = 3 , k = 4 ; System . out . print ( " Count ▁ = ▁ " + countSubmatrix ( mat , n , k ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; } public static void main ( String argc [ ] ) { int n = 4 , k = 7 ; int freq = find ( n , k ) ; if ( freq < 0 ) System . out . print ( " ▁ element " + " not exist NEW_LINE "); else System . out . print ( " ▁ Frequency " + " ▁ of ▁ " + k + " ▁ is ▁ " + freq + "NEW_LINE"); } }
import java . util . * ; import java . lang . * ; public class GfG { public static void ZigZag ( int rows , int columns , int numbers [ ] ) { int k = 0 ; int [ ] [ ] arr = new int [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < columns && numbers [ k ] > 0 ; j ++ ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } else { for ( int j = columns - 1 ; j >= 0 && numbers [ k ] > 0 ; j -- ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String argc [ ] ) { int rows = 4 ; int columns = 5 ; int [ ] Numbers = new int [ ] { 3 , 4 , 2 , 2 , 3 , 1 , 5 } ; ZigZag ( rows , columns , Numbers ) ; } }
import java . io . * ; class GFG { static int numberofPosition ( int n , int k , int x , int y , int obstPosx [ ] , int obstPosy [ ] ) { int d11 , d12 , d21 , d22 , r1 , r2 , c1 , c2 ; d11 = Math . min ( x - 1 , y - 1 ) ; d12 = Math . min ( n - x , n - y ) ; d21 = Math . min ( n - x , y - 1 ) ; d22 = Math . min ( x - 1 , n - y ) ; r1 = y - 1 ; r2 = n - y ; c1 = x - 1 ; c2 = n - x ; for ( int i = 0 ; i < k ; i ++ ) { if ( x > obstPosx [ i ] && y > obstPosy [ i ] && x - obstPosx [ i ] == y - obstPosy [ i ] ) d11 = Math . min ( d11 , x - obstPosx [ i ] - 1 ) ; if ( obstPosx [ i ] > x && obstPosy [ i ] > y && obstPosx [ i ] - x == obstPosy [ i ] - y ) d12 = Math . min ( d12 , obstPosx [ i ] - x - 1 ) ; if ( obstPosx [ i ] > x && y > obstPosy [ i ] && obstPosx [ i ] - x == y - obstPosy [ i ] ) d21 = Math . min ( d21 , obstPosx [ i ] - x - 1 ) ; if ( x > obstPosx [ i ] && obstPosy [ i ] > y && x - obstPosx [ i ] == obstPosy [ i ] - y ) d22 = Math . min ( d22 , x - obstPosx [ i ] - 1 ) ; if ( x == obstPosx [ i ] && obstPosy [ i ] < y ) r1 = Math . min ( r1 , y - obstPosy [ i ] - 1 ) ; if ( x == obstPosx [ i ] && obstPosy [ i ] > y ) r2 = Math . min ( r2 , obstPosy [ i ] - y - 1 ) ; if ( y == obstPosy [ i ] && obstPosx [ i ] < x ) c1 = Math . min ( c1 , x - obstPosx [ i ] - 1 ) ; if ( y == obstPosy [ i ] && obstPosx [ i ] > x ) c2 = Math . min ( c2 , obstPosx [ i ] - x - 1 ) ; } return d11 + d12 + d21 + d22 + r1 + r2 + c1 + c2 ; } public static void main ( String [ ] args ) { int n = 8 ; int k = 1 ; int Qposx = 4 ; int Qposy = 4 ; int obstPosx [ ] = { 3 } ; int obstPosy [ ] = { 5 } ; System . out . println ( numberofPosition ( n , k , Qposx , Qposy , obstPosx , obstPosy ) ) ; } }
class GFG { static final int n = 5 ; static int FindMaxProduct ( int arr [ ] [ ] , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 1 ) <= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ; if ( max < result ) max = result ; } } } return max ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 1 } , { 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 1 , 0 } , { 9 , 6 , 4 , 2 , 3 } } ; System . out . print ( FindMaxProduct ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int minimumflip ( int mat [ ] [ ] , int n ) { int transpose [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; int mat [ ] [ ] = { { 0 , 0 , 1 } , { 1 , 1 , 1 } , { 1 , 0 , 0 } } ; System . out . println ( minimumflip ( mat , n ) ) ; } }
import java . util . * ; class GFG { static int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; } public static void main ( String [ ] args ) { int n = 3 ; int mat [ ] [ ] = { { 0 , 0 , 1 } , { 1 , 1 , 1 } , { 1 , 0 , 0 } } ; System . out . println ( minimumflip ( mat , n ) ) ; } }
class GFG { static final int MAX = 100 ; static void freq ( int ar [ ] [ ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } System . out . print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " + odd + " NEW_LINE"); System . out . print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ " + even + " NEW_LINE"); } public static void main ( String [ ] args ) { int m = 3 , n = 3 ; int array [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; freq ( array , m , n ) ; } }
import java . util . Arrays ; public class GFG { static int MAX = 100 ; static boolean HalfDiagonalSums ( int mat [ ] [ ] , int n ) { int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; } public static void main ( String args [ ] ) { int a [ ] [ ] = { { 2 , 9 , 1 , 4 , - 2 } , { 6 , 7 , 2 , 11 , 4 } , { 4 , 2 , 9 , 2 , 4 } , { 1 , 9 , 2 , 4 , 4 } , { 0 , 2 , 4 , 2 , 5 } } ; System . out . print ( HalfDiagonalSums ( a , 5 ) ? " Yes " : " No " ) ; } }
class GFG { static int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) System . out . print ( 1 + " ▁ " ) ; else System . out . print ( 0 + " ▁ " ) ; } System . out . println ( ) ; } return 0 ; } public static void main ( String args [ ] ) { int size = 5 ; identity ( size ) ; } }
class GFG { int MAX = 100 ; static boolean isIdentity ( int mat [ ] [ ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; } public static void main ( String args [ ] ) { int N = 4 ; int mat [ ] [ ] = { { 1 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 1 } } ; if ( isIdentity ( mat , N ) ) System . out . println ( " Yes ▁ " ) ; else System . out . println ( " No ▁ " ) ; } }
import java . io . * ; class Example { final static long mod = 100000007 ; static long modPower ( long a , long t , long mod ) { long now = a , ret = 1 ; while ( t > 0 ) { if ( t % 2 == 1 ) ret = now * ( ret % mod ) ; now = now * ( now % mod ) ; t >>= 1 ; } return ret ; } static long countWays ( int n , int m , int k ) { if ( n == 1 m == 1 ) return 1 ; else if ( ( n + m ) % 2 == 1 && k == - 1 ) return 0 ; return ( modPower ( modPower ( ( long ) 2 , n - 1 , mod ) , m - 1 , mod ) % mod ) ; } public static void main ( String args [ ] ) throws IOException { int n = 2 , m = 7 , k = 1 ; System . out . println ( countWays ( n , m , k ) ) ; } }
import java . io . * ; class GFG { static int MAX = 100 ; static void imageSwap ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j <= i ; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] + mat [ j ] [ i ] - ( mat [ j ] [ i ] = mat [ i ] [ j ] ) ; } static void printMatrix ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int n = 4 ; imageSwap ( mat , n ) ; printMatrix ( mat , n ) ; } }
class GFG { private static void search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( " n ▁ Found ▁ at ▁ " + i + " ▁ " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } System . out . print ( " n ▁ Element ▁ not ▁ found " ) ; return ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; search ( mat , 4 , 29 ) ; } }
import java . io . * ; class GFG { static void fill0X ( int m , int n ) { int i , k = 0 , l = 0 ; int r = m , c = n ; char a [ ] [ ] = new char [ m ] [ n ] ; char x = ' X ' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ; for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; } x = ( x == '0' ) ? ' X ' : '0' ; } for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) System . out . print ( a [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { System . out . println ( " Output ▁ for ▁ m ▁ = ▁ 5 , ▁ n ▁ = ▁ 6" ) ; fill0X ( 5 , 6 ) ; System . out . println ( " Output ▁ for ▁ m ▁ = ▁ 4 , ▁ n ▁ = ▁ 4" ) ; fill0X ( 4 , 4 ) ; System . out . println ( " Output ▁ for ▁ m ▁ = ▁ 3 , ▁ n ▁ = ▁ 4" ) ; fill0X ( 3 , 4 ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { private final static int SIZE = 100 ; public static int calculateEnergy ( int mat [ ] [ ] , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i ] [ j ] / n ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ; } } return tot_energy ; } public static void main ( String argc [ ] ) { int [ ] [ ] mat = new int [ ] [ ] { { 4 , 7 , 0 , 3 } , { 8 , 5 , 6 , 1 } , { 9 , 11 , 10 , 2 } , { 15 , 13 , 14 , 12 } } ; int n = 4 ; System . out . println ( " Total ▁ energy ▁ required ▁ = ▁ " + calculateEnergy ( mat , n ) + " ▁ units " ) ; } }
class GFG { static final int MAX = 100 ; static boolean isUnique ( int mat [ ] [ ] , int i , int j , int n , int m ) { int sumrow = 0 ; for ( int k = 0 ; k < m ; k ++ ) { sumrow += mat [ i ] [ k ] ; if ( sumrow > 1 ) return false ; } int sumcol = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sumcol += mat [ k ] [ j ] ; if ( sumcol > 1 ) return false ; } return true ; } static int countUnique ( int mat [ ] [ ] , int n , int m ) { int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && isUnique ( mat , i , j , n , m ) ) uniquecount ++ ; return uniquecount ; } static public void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 1 , 0 , 0 } , { 0 , 0 , 1 , 0 } , { 1 , 0 , 0 , 1 } } ; System . out . print ( countUnique ( mat , 3 , 4 ) ) ; } }
import java . io . * ; class GFG { static int MAX = 100 ; static boolean isSparse ( int array [ ] [ ] , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ; return ( counter > ( ( m * n ) / 2 ) ) ; } public static void main ( String args [ ] ) { int array [ ] [ ] = { { 1 , 0 , 3 } , { 0 , 0 , 4 } , { 6 , 0 , 0 } } ; int m = 3 , n = 3 ; if ( isSparse ( array , m , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { int MAX = 100 ; static int countCommon ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; } public static void main ( String args [ ] ) throws IOException { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; System . out . println ( countCommon ( mat , 3 ) ) ; } }
public class GFG { static boolean areSumSame ( int a [ ] [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; } public static void main ( String args [ ] ) { int n = 4 ; int m = 4 ; int M [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 9 , 5 , 3 , 1 } , { 0 , 3 , 5 , 6 } , { 0 , 4 , 5 , 6 } } ; if ( areSumSame ( M , n , m ) == true ) System . out . print ( "1NEW_LINE"); else System . out . print ( "0NEW_LINE"); } }
class GFG { static final int N = 4 ; static void findMax ( int arr [ ] [ ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( j >= 0 && arr [ i ] [ j ] == 1 ) { row = i ; j -- ; } } System . out . print ( " Row ▁ number ▁ = ▁ " + ( row + 1 ) ) ; System . out . print ( " , ▁ MaxCount ▁ = ▁ " + ( N - 1 - j ) ) ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 0 } , { 0 , 1 , 1 , 1 } } ; findMax ( arr ) ; } }
public class Main { public static final int n = 4 ; public static final int m = 4 ; static int findPossibleMoves ( int mat [ ] [ ] , int p , int q ) { int X [ ] = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 } ; int Y [ ] = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 } ; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 0 , 1 , 0 } , { 0 , 1 , 1 , 1 } , { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 1 } } ; int p = 2 , q = 2 ; System . out . println ( findPossibleMoves ( mat , p , q ) ) ; } }
import java . io . * ; public class GFG { static void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) principal += mat [ i ] [ j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ; } } System . out . println ( " Principal ▁ Diagonal : " + principal ) ; System . out . println ( " Secondary ▁ Diagonal : " + secondary ) ; } static public void main ( String [ ] args ) { int [ ] [ ] a = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printDiagonalSums ( a , 4 ) ; } }
import java . io . * ; public class GFG { static void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } System . out . println ( " Principal ▁ Diagonal : " + principal ) ; System . out . println ( " Secondary ▁ Diagonal : " + secondary ) ; } static public void main ( String [ ] args ) { int [ ] [ ] a = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printDiagonalSums ( a , 4 ) ; } }
class GFG { public static void printBoundary ( int a [ ] [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) System . out . print ( a [ i ] [ j ] + " ▁ " ) ; else if ( i == m - 1 ) System . out . print ( a [ i ] [ j ] + " ▁ " ) ; else if ( j == 0 ) System . out . print ( a [ i ] [ j ] + " ▁ " ) ; else if ( j == n - 1 ) System . out . print ( a [ i ] [ j ] + " ▁ " ) ; else System . out . print ( " ▁ " ) ; } System . out . println ( " " ) ; } } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printBoundary ( a , 4 , 4 ) ; } }
class GFG { public static long getBoundarySum ( int a [ ] [ ] , int m , int n ) { long sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; long sum = getBoundarySum ( a , 4 , 4 ) ; System . out . println ( " Sum ▁ of ▁ boundary ▁ elements " + " ▁ is ▁ " + sum ) ; } }
import java . io . * ; class GFG { static void printSpiral ( int [ ] [ ] mat , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) System . out . print ( mat [ low_row ] [ i ] + " ▁ " ) ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) System . out . print ( mat [ i ] [ high_column ] + " ▁ " ) ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) System . out . print ( mat [ high_row ] [ i ] + " ▁ " ) ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) System . out . print ( mat [ i ] [ low_column ] + " ▁ " ) ; low_column -= 1 ; } System . out . println ( ) ; } static public void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int r = 3 , c = 3 ; printSpiral ( mat , r , c ) ; } }
class GFG { public static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; } public static void main ( String [ ] args ) { int n = 3 ; int arr [ ] [ ] = { { 11 , 2 , 4 } , { 4 , 5 , 6 } , { 10 , 8 , - 12 } } ; System . out . print ( difference ( arr , n ) ) ; } }
class GFG { public static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; } public static void main ( String [ ] args ) { int n = 3 ; int arr [ ] [ ] = { { 11 , 2 , 4 } , { 4 , 5 , 6 } , { 10 , 8 , - 12 } } ; System . out . print ( difference ( arr , n ) ) ; } }
class GFG { static int MAX = 100 ; static void spiralFill ( int m , int n , int a [ ] [ ] ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) { a [ k ] [ i ] = val ++ ; } k ++ ; for ( int i = k ; i < m ; ++ i ) { a [ i ] [ n - 1 ] = val ++ ; } n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) { a [ m - 1 ] [ i ] = val ++ ; } m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) { a [ i ] [ l ] = val ++ ; } l ++ ; } } } public static void main ( String [ ] args ) { int m = 4 , n = 4 ; int a [ ] [ ] = new int [ MAX ] [ MAX ] ; spiralFill ( m , n , a ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( a [ i ] [ j ] + " ▁ " ) ; } System . out . println ( " " ) ; } } }
class GFG { static final int MAX = 100 ; static void maxMin ( int arr [ ] [ ] , int n ) { int min = + 2147483647 ; int max = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } System . out . print ( " Maximum ▁ = ▁ " + max + " , ▁ Minimum ▁ = ▁ " + min ) ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 5 , 9 , 11 } , { 25 , 0 , 14 } , { 21 , 6 , 4 } } ; maxMin ( arr , 3 ) ; } }
class GFG { static final int N = 5 ; static final int M = 5 ; static int minOperation ( boolean arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; } public static void main ( String [ ] args ) { boolean mat [ ] [ ] = { { false , false , true , true , true } , { false , false , false , true , true } , { false , false , false , true , true } , { true , true , true , true , true } , { true , true , true , true , true } } ; System . out . println ( minOperation ( mat ) ) ; } }
import java . io . * ; class GFG { static int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; } public static void main ( String [ ] args ) { int N = 2 ; System . out . println ( findSum ( N ) ) ; } }
import java . io . * ; class GFG { static int countOps ( int A [ ] [ ] , int B [ ] [ ] , int m , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j < m ; j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += Math . abs ( A [ i ] [ 0 ] ) ; for ( int j = 0 ; j < m ; j ++ ) result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ; return ( result ) ; } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int B [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; System . out . println ( countOps ( A , B , 3 , 3 ) ) ; } }
class GFG { static void printCoils ( int n ) { int m = 8 * n * n ; int coil1 [ ] = new int [ m ] ; coil1 [ 0 ] = 8 * n * n + 2 * n ; int curr = coil1 [ 0 ] ; int nflg = 1 , step = 2 ; int index = 1 ; while ( index < m ) { for ( int i = 0 ; i < step ; i ++ ) { curr = coil1 [ index ++ ] = ( curr - 4 * n * nflg ) ; if ( index >= m ) break ; } if ( index >= m ) break ; for ( int i = 0 ; i < step ; i ++ ) { curr = coil1 [ index ++ ] = curr + nflg ; if ( index >= m ) break ; } nflg = nflg * ( - 1 ) ; step += 2 ; } int coil2 [ ] = new int [ m ] ; for ( int i = 0 ; i < 8 * n * n ; i ++ ) coil2 [ i ] = 16 * n * n + 1 - coil1 [ i ] ; System . out . print ( " Coil ▁ 1 ▁ : ▁ " ) ; for ( int i = 0 ; i < 8 * n * n ; i ++ ) System . out . print ( coil1 [ i ] + " ▁ " ) ; System . out . print ( " Coil 2 : "); for ( int i = 0 ; i < 8 * n * n ; i ++ ) System . out . print ( coil2 [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 1 ; printCoils ( n ) ; } }
import java . io . * ; public class GFG { static int findSum ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; } static public void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; } static public void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; } static public void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
class GFG { static int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( spiralDiaSum ( n ) ) ; } }
class GFG { static final int R = 3 ; static final int C = 5 ; static int numofneighbour ( int mat [ ] [ ] , int i , int j ) { int count = 0 ; if ( i > 0 && mat [ i - 1 ] [ j ] == 1 ) count ++ ; if ( j > 0 && mat [ i ] [ j - 1 ] == 1 ) count ++ ; if ( i < R - 1 && mat [ i + 1 ] [ j ] == 1 ) count ++ ; if ( j < C - 1 && mat [ i ] [ j + 1 ] == 1 ) count ++ ; return count ; } static int findperimeter ( int mat [ ] [ ] ) { int perimeter = 0 ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) if ( mat [ i ] [ j ] == 1 ) perimeter += ( 4 - numofneighbour ( mat , i , j ) ) ; return perimeter ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 1 , 0 , 0 , 0 } , { 1 , 1 , 1 , 0 , 0 } , { 1 , 0 , 0 , 0 , 0 } } ; System . out . println ( findperimeter ( mat ) ) ; } }
class GFG { static final int MAX = 100 ; static void printMatrixDiagonal ( int mat [ ] [ ] , int n ) { int i = 0 , j = 0 ; boolean isUp = true ; for ( int k = 0 ; k < n * n ; ) { if ( isUp ) { for ( ; i >= 0 && j < n ; j ++ , i -- ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; k ++ ; } if ( i < 0 && j <= n - 1 ) i = 0 ; if ( j == n ) { i = i + 2 ; j -- ; } } else { for ( ; j >= 0 && i < n ; i ++ , j -- ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; k ++ ; } if ( j < 0 && i <= n - 1 ) j = 0 ; if ( i == n ) { j = j + 2 ; i -- ; } } isUp = ! isUp ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int n = 3 ; printMatrixDiagonal ( mat , n ) ; } }
class GFG { static final int MAX = 100 ; static int maxRowDiff ( int mat [ ] [ ] , int m , int n ) { int rowSum [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; } public static void main ( String [ ] args ) { int m = 5 , n = 4 ; int mat [ ] [ ] = { { - 1 , 2 , 3 , 4 } , { 5 , 3 , - 2 , 1 } , { 6 , 7 , 2 , - 3 } , { 2 , 9 , 1 , 4 } , { 2 , 1 , - 2 , 0 } } ; System . out . print ( maxRowDiff ( mat , m , n ) ) ; } }
class GFG { static int MAX = 100 ; static int sortedCount ( int mat [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; } public static void main ( String arg [ ] ) { int m = 4 , n = 5 ; int mat [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 } , { 4 , 3 , 1 , 2 , 6 } , { 8 , 7 , 6 , 5 , 4 } , { 5 , 7 , 8 , 9 , 10 } } ; System . out . print ( sortedCount ( mat , m , n ) ) ; } }
class GFG { static final int MAX = 1000 ; static int maxXOR ( int mat [ ] [ ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 ; c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; } public static void main ( String [ ] args ) { int N = 3 ; int mat [ ] [ ] = { { 1 , 5 , 4 } , { 3 , 7 , 2 } , { 5 , 9 , 10 } } ; System . out . print ( " maximum ▁ XOR ▁ value ▁ : ▁ " + maxXOR ( mat , N ) ) ; } }
import java . io . * ; class GFG { static void direction ( int R , int C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { System . out . println ( " Left " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { System . out . println ( " Up " ) ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { System . out . println ( " Right " ) ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { System . out . println ( " Left " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { System . out . println ( " Right " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { System . out . println ( " Down " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { System . out . println ( " Left " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { System . out . println ( " Up " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { System . out . println ( " Down " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { System . out . println ( " Right " ) ; return ; } } public static void main ( String [ ] args ) { int R = 3 , C = 1 ; direction ( R , C ) ; } }
import java . io . * ; class GFG { public static int N = 5 ; public static int M = 4 ; static boolean checkDiagonal ( int mat [ ] [ ] , int i , int j ) { int res = mat [ i ] [ j ] ; while ( ++ i < N && ++ j < M ) { if ( mat [ i ] [ j ] != res ) return false ; } return true ; } static boolean isToepliz ( int mat [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { if ( ! checkDiagonal ( mat , 0 , i ) ) return false ; } for ( int i = 1 ; i < N ; i ++ ) { if ( ! checkDiagonal ( mat , i , 0 ) ) return false ; } return true ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 6 , 7 , 8 , 9 } , { 4 , 6 , 7 , 8 } , { 1 , 4 , 6 , 7 } , { 0 , 1 , 4 , 6 } , { 2 , 0 , 1 , 4 } } ; if ( isToepliz ( mat ) ) System . out . println ( " Matrix ▁ is ▁ a ▁ Toepliz ▁ " ) ; else System . out . println ( " Matrix ▁ is ▁ not ▁ a ▁ Toepliz ▁ " ) ; } }
import java . io . * ; class GFG { public static int N = 5 ; static int countZeroes ( int mat [ ] [ ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 1 , 1 } , { 0 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } } ; System . out . println ( countZeroes ( mat ) ) ; } }
import java . io . * ; class GFG { static int N = 10 ; static int findLargestPlus ( int mat [ ] [ ] ) { int left [ ] [ ] = new int [ N ] [ N ] ; int right [ ] [ ] = new int [ N ] [ N ] ; int top [ ] [ ] = new int [ N ] [ N ] ; int bottom [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = Math . min ( Math . min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , Math . min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 } , { 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 } , { 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 } , { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 } } ; System . out . println ( findLargestPlus ( mat ) ) ; } }
import java . io . * ; class GFG { static StringBuilder findLeft ( StringBuilder str ) { int n = str . length ( ) ; while ( n > 0 ) { n -- ; if ( str . charAt ( n ) == ' d ' ) { str . setCharAt ( n , ' c ' ) ; break ; } if ( str . charAt ( n ) == ' b ' ) { str . setCharAt ( n , ' a ' ) ; break ; } if ( str . charAt ( n ) == ' a ' ) str . setCharAt ( n , ' b ' ) ; else if ( str . charAt ( n ) == ' c ' ) str . setCharAt ( n , ' d ' ) ; } return str ; } public static void main ( String [ ] args ) { StringBuilder str = new StringBuilder ( " aacbddc " ) ; System . out . print ( " Left ▁ of ▁ " + str + " ▁ is ▁ " + findLeft ( str ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + " TABSYMBOL " ) ; else System . out . print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + " TABSYMBOL " ) ; } System . out . println ( ) ; } } public static void main ( String args [ ] ) { int n = 5 ; printSpiral ( n ) ; } }
class GFG { public static void modifyMatrix ( int mat [ ] [ ] , int R , int C ) { int row [ ] = new int [ R ] ; int col [ ] = new int [ C ] ; int i , j ; for ( i = 0 ; i < R ; i ++ ) { row [ i ] = 0 ; } for ( i = 0 ; i < C ; i ++ ) { col [ i ] = 0 ; } for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { row [ i ] = 1 ; col [ j ] = 1 ; } } } for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( row [ i ] == 1 col [ j ] == 1 ) { mat [ i ] [ j ] = 1 ; } } } } public static void printMatrix ( int mat [ ] [ ] , int R , int C ) { int i , j ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 0 , 0 , 1 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } , } ; System . out . println ( " Matrix ▁ Intially " ) ; printMatrix ( mat , 3 , 4 ) ; modifyMatrix ( mat , 3 , 4 ) ; System . out . println ( " Matrix ▁ after ▁ modification ▁ n " ) ; printMatrix ( mat , 3 , 4 ) ; } }
class GFG { public static void modifyMatrix ( int mat [ ] [ ] ) { boolean row_flag = false ; boolean col_flag = false ; for ( int i = 0 ; i < mat . length ; i ++ ) { for ( int j = 0 ; j < mat [ 0 ] . length ; j ++ ) { if ( i == 0 && mat [ i ] [ j ] == 1 ) row_flag = true ; if ( j == 0 && mat [ i ] [ j ] == 1 ) col_flag = true ; if ( mat [ i ] [ j ] == 1 ) { mat [ 0 ] [ j ] = 1 ; mat [ i ] [ 0 ] = 1 ; } } } for ( int i = 1 ; i < mat . length ; i ++ ) { for ( int j = 1 ; j < mat [ 0 ] . length ; j ++ ) { if ( mat [ 0 ] [ j ] == 1 mat [ i ] [ 0 ] == 1 ) { mat [ i ] [ j ] = 1 ; } } } if ( row_flag == true ) { for ( int i = 0 ; i < mat [ 0 ] . length ; i ++ ) { mat [ 0 ] [ i ] = 1 ; } } if ( col_flag == true ) { for ( int i = 0 ; i < mat . length ; i ++ ) { mat [ i ] [ 0 ] = 1 ; } } } public static void printMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < mat . length ; i ++ ) { for ( int j = 0 ; j < mat [ 0 ] . length ; j ++ ) { System . out . print ( mat [ i ] [ j ] ) ; } System . out . println ( " " ) ; } } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 1 , 0 , 0 , 1 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } } ; System . out . println ( " Input ▁ Matrix ▁ : " ) ; printMatrix ( mat ) ; modifyMatrix ( mat ) ; System . out . println ( " Matrix ▁ After ▁ Modification ▁ : " ) ; printMatrix ( mat ) ; } }
class GFG { static int n = 5 ; static int find ( boolean arr [ ] [ ] ) { int i = 0 , j = n - 1 ; int res = - 1 ; while ( i < n && j >= 0 ) { if ( arr [ i ] [ j ] == false ) { while ( j >= 0 && ( arr [ i ] [ j ] == false i == j ) ) { j -- ; } if ( j == - 1 ) { res = i ; break ; } else { i ++ ; } } else { while ( i < n && ( arr [ i ] [ j ] == true i == j ) ) { i ++ ; } if ( i == n ) { res = j ; break ; } else { j -- ; } } } if ( res == - 1 ) { return res ; } for ( int k = 0 ; k < n ; k ++ ) { if ( res != k && arr [ k ] [ res ] != true ) { return - 1 ; } } for ( int l = 0 ; l < n ; l ++ ) { if ( res != l && arr [ res ] [ l ] != false ) { return - 1 ; } } return res ; } public static void main ( String [ ] args ) { boolean mat [ ] [ ] = { { false , false , true , true , false } , { false , false , false , true , false } , { true , true , true , true , false } , { false , false , false , false , false } , { true , true , true , true , true } } ; System . out . println ( find ( mat ) ) ; } }
class GFG { static final int M = 4 ; static final int N = 5 ; static int preProcess ( int mat [ ] [ ] , int aux [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; return 0 ; } static int sumQuery ( int aux [ ] [ ] , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi ] [ rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 , 6 } , { 5 , 3 , 8 , 1 , 2 } , { 4 , 6 , 7 , 5 , 5 } , { 2 , 4 , 8 , 9 , 4 } } ; int aux [ ] [ ] = new int [ M ] [ N ] ; preProcess ( mat , aux ) ; int tli = 2 , tlj = 2 , rbi = 3 , rbj = 4 ; System . out . print ( " Query1 : " + sumQuery ( aux , tli , tlj , rbi , rbj ) ) ; tli = 0 ; tlj = 0 ; rbi = 1 ; rbj = 1 ; System . out . print ( " Query2 : " + sumQuery ( aux , tli , tlj , rbi , rbj ) ) ; tli = 1 ; tlj = 2 ; rbi = 3 ; rbj = 3 ; System . out . print ( " Query3 : "  + sumQuery ( aux , tli , tlj , rbi , rbj ) ) ; } }
class GFG { static final int R = 3 ; static final int C = 3 ; static void swap ( int mat [ ] [ ] , int row1 , int row2 , int col ) { for ( int i = 0 ; i < col ; i ++ ) { int temp = mat [ row1 ] [ i ] ; mat [ row1 ] [ i ] = mat [ row2 ] [ i ] ; mat [ row2 ] [ i ] = temp ; } } static int rankOfMatrix ( int mat [ ] [ ] ) { int rank = C ; for ( int row = 0 ; row < rank ; row ++ ) { if ( mat [ row ] [ row ] != 0 ) { for ( int col = 0 ; col < R ; col ++ ) { if ( col != row ) { double mult = ( double ) mat [ col ] [ row ] / mat [ row ] [ row ] ; for ( int i = 0 ; i < rank ; i ++ ) mat [ col ] [ i ] -= mult * mat [ row ] [ i ] ; } } } else { boolean reduce = true ; for ( int i = row + 1 ; i < R ; i ++ ) { if ( mat [ i ] [ row ] != 0 ) { swap ( mat , row , i , rank ) ; reduce = false ; break ; } } if ( reduce ) { rank -- ; for ( int i = 0 ; i < R ; i ++ ) mat [ i ] [ row ] = mat [ i ] [ rank ] ; } row -- ; } } return rank ; } static void display ( int mat [ ] [ ] , int row , int col ) { for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) System . out . print ( " ▁ " + mat [ i ] [ j ] ) ; System . out . print ( "NEW_LINE"); } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 10 , 20 , 10 } , { - 20 , - 30 , 10 } , { 30 , 50 , 0 } } ; System . out . print ( " Rank ▁ of ▁ the ▁ matrix ▁ is ▁ : ▁ " + rankOfMatrix ( mat ) ) ; } }
import java . io . * ; class islands { static int countIslands ( int mat [ ] [ ] , int m , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == ' X ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' O ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int m = 6 ; int n = 3 ; int mat [ ] [ ] = { { ' O ' , ' O ' , ' O ' } , { ' X ' , ' X ' , ' O ' } , { ' X ' , ' X ' , ' O ' } , { ' O ' , ' O ' , ' X ' } , { ' O ' , ' O ' , ' X ' } , { ' X ' , ' X ' , ' O ' } } ; System . out . println ( " Number ▁ of ▁ rectangular ▁ islands ▁ is : ▁ " + countIslands ( mat , m , n ) ) ; } }
import java . io . * ; class GFG { static int M = 6 ; static int N = 6 ; static void floodFillUtil ( char mat [ ] [ ] , int x , int y , char prevV , char newV ) { if ( x < 0 x >= M y < 0 y >= N ) return ; if ( mat [ x ] [ y ] != prevV ) return ; mat [ x ] [ y ] = newV ; floodFillUtil ( mat , x + 1 , y , prevV , newV ) ; floodFillUtil ( mat , x - 1 , y , prevV , newV ) ; floodFillUtil ( mat , x , y + 1 , prevV , newV ) ; floodFillUtil ( mat , x , y - 1 , prevV , newV ) ; } static void replaceSurrounded ( char mat [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == ' O ' ) mat [ i ] [ j ] = ' - ' ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ 0 ] == ' - ' ) floodFillUtil ( mat , i , 0 , ' - ' , ' O ' ) ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ N - 1 ] == ' - ' ) floodFillUtil ( mat , i , N - 1 , ' - ' , ' O ' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ 0 ] [ i ] == ' - ' ) floodFillUtil ( mat , 0 , i , ' - ' , ' O ' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ M - 1 ] [ i ] == ' - ' ) floodFillUtil ( mat , M - 1 , i , ' - ' , ' O ' ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == ' - ' ) mat [ i ] [ j ] = ' X ' ; } public static void main ( String [ ] args ) { char [ ] [ ] mat = { { ' X ' , ' O ' , ' X ' , ' O ' , ' X ' , ' X ' } , { ' X ' , ' O ' , ' X ' , ' X ' , ' O ' , ' X ' } , { ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' X ' } , { ' O ' , ' X ' , ' X ' , ' X ' , ' X ' , ' X ' } , { ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' O ' } , { ' O ' , ' O ' , ' X ' , ' O ' , ' O ' , ' O ' } } ; replaceSurrounded ( mat ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; System . out . println ( " " ) ; } } }
class path { static int x [ ] = { 0 , 1 , 1 , - 1 , 1 , 0 , - 1 , - 1 } ; static int y [ ] = { 1 , 0 , 1 , 1 , - 1 , - 1 , 0 , - 1 } ; static int R = 3 ; static int C = 3 ; static int dp [ ] [ ] = new int [ R ] [ C ] ; static boolean isvalid ( int i , int j ) { if ( i < 0 j < 0 i >= R j >= C ) return false ; return true ; } static boolean isadjacent ( char prev , char curr ) { return ( ( curr - prev ) == 1 ) ; } static int getLenUtil ( char mat [ ] [ ] , int i , int j , char prev ) { if ( ! isvalid ( i , j ) || ! isadjacent ( prev , mat [ i ] [ j ] ) ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; int ans = 0 ; for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) ; return dp [ i ] [ j ] = ans ; } static int getLen ( char mat [ ] [ ] , char s ) { for ( int i = 0 ; i < R ; ++ i ) for ( int j = 0 ; j < C ; ++ j ) dp [ i ] [ j ] = - 1 ; int ans = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == s ) { for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; } public static void main ( String args [ ] ) { char mat [ ] [ ] = { { ' a ' , ' c ' , ' d ' } , { ' h ' , ' b ' , ' a ' } , { ' i ' , ' g ' , ' f ' } } ; System . out . println ( getLen ( mat , ' a ' ) ) ; System . out . println ( getLen ( mat , ' e ' ) ) ; System . out . println ( getLen ( mat , ' b ' ) ) ; System . out . println ( getLen ( mat , ' f ' ) ) ; } }
class min_steps { static int minInitialPoints ( int points [ ] [ ] , int R , int C ) { int dp [ ] [ ] = new int [ R ] [ C ] ; int m = R , n = C ; dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : Math . abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ; for ( int i = m - 2 ; i >= 0 ; i -- ) dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) dp [ m - 1 ] [ j ] = Math . max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 ) ; for ( int i = m - 2 ; i >= 0 ; i -- ) { for ( int j = n - 2 ; j >= 0 ; j -- ) { int min_points_on_exit = Math . min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ; dp [ i ] [ j ] = Math . max ( min_points_on_exit - points [ i ] [ j ] , 1 ) ; } } return dp [ 0 ] [ 0 ] ; } public static void main ( String args [ ] ) { int points [ ] [ ] = { { - 2 , - 3 , 3 } , { - 5 , - 10 , 1 } , { 10 , 30 , - 5 } } ; int R = 3 , C = 3 ; System . out . println ( " Minimum ▁ Initial ▁ Points ▁ Required : ▁ " + minInitialPoints ( points , R , C ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class PeakElement { static int findPeakUtil ( int arr [ ] , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; } static int findPeak ( int arr [ ] , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = arr . length ; System . out . println ( " Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ " + findPeak ( arr , n ) ) ; } }
class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int i , j ; System . out . println ( " Repeated ▁ Elements ▁ are ▁ : " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } } } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }
class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int count [ ] = new int [ size ] ; int i ; System . out . println ( " Repeated ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; else count [ arr [ i ] ] ++ ; } } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }
class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = ( int ) Math . sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; System . out . println ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : " ) ; System . out . print ( x + " ▁ " + y ) ; } int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }
class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_bit_no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_bit_no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } System . out . println ( " The ▁ two ▁ reppeated ▁ elements ▁ are ▁ : " ) ; System . out . println ( x + " ▁ " + y ) ; } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }
class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int i ; System . out . println ( " The ▁ repeating ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else System . out . print ( Math . abs ( arr [ i ] ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }
class SubarraySum { int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { int p = j - 1 ; System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + i + " ▁ and ▁ " + p ) ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } System . out . println ( " No ▁ subarray ▁ found " ) ; return 0 ; } public static void main ( String [ ] args ) { SubarraySum arraysum = new SubarraySum ( ) ; int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = arr . length ; int sum = 23 ; arraysum . subArraySum ( arr , n , sum ) ; } }
class SubarraySum { int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { int p = i - 1 ; System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + start + " ▁ and ▁ " + p ) ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } System . out . println ( " No ▁ subarray ▁ found " ) ; return 0 ; } public static void main ( String [ ] args ) { SubarraySum arraysum = new SubarraySum ( ) ; int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = arr . length ; int sum = 23 ; arraysum . subArraySum ( arr , n , sum ) ; } }
import java . util . Arrays ; class GFG { static int maximum ( int a , int b , int c ) { return Math . max ( Math . max ( a , b ) , c ) ; } static int minimum ( int a , int b , int c ) { return Math . min ( Math . min ( a , b ) , c ) ; } static void smallestDifferenceTriplet ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int n ) { Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; Arrays . sort ( arr3 ) ; int res_min = 0 , res_max = 0 , res_mid = 0 ; int i = 0 , j = 0 , k = 0 ; int diff = 2147483647 ; while ( i < n && j < n && k < n ) { int sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; int max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; int min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; if ( min == arr1 [ i ] ) i ++ ; else if ( min == arr2 [ j ] ) j ++ ; else k ++ ; if ( diff > ( max - min ) ) { diff = max - min ; res_max = max ; res_mid = sum - ( max + min ) ; res_min = min ; } } System . out . print ( res_max + " , ▁ " + res_mid + " , ▁ " + res_min ) ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 5 , 2 , 8 } ; int arr2 [ ] = { 10 , 7 , 12 } ; int arr3 [ ] = { 9 , 14 , 6 } ; int n = arr1 . length ; smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) ; } }
class FindTriplet { boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( " Triplet ▁ is ▁ " + A [ i ] + " , ▁ " + A [ j ] + " , ▁ " + A [ k ] ) ; return true ; } } } } return false ; } public static void main ( String [ ] args ) { FindTriplet triplet = new FindTriplet ( ) ; int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = A . length ; triplet . find3Numbers ( A , arr_size , sum ) ; } }
class FindTriplet { boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; quickSort ( A , 0 , arr_size - 1 ) ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { System . out . print ( " Triplet ▁ is ▁ " + A [ i ] + " , ▁ " + A [ l ] + " , ▁ " + A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; } int partition ( int A [ ] , int si , int ei ) { int x = A [ ei ] ; int i = ( si - 1 ) ; int j ; for ( j = si ; j <= ei - 1 ; j ++ ) { if ( A [ j ] <= x ) { i ++ ; int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } } int temp = A [ i + 1 ] ; A [ i + 1 ] = A [ ei ] ; A [ ei ] = temp ; return ( i + 1 ) ; } void quickSort ( int A [ ] , int si , int ei ) { int pi ; if ( si < ei ) { pi = partition ( A , si , ei ) ; quickSort ( A , si , pi - 1 ) ; quickSort ( A , pi + 1 , ei ) ; } } public static void main ( String [ ] args ) { FindTriplet triplet = new FindTriplet ( ) ; int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = A . length ; triplet . find3Numbers ( A , arr_size , sum ) ; } }
class Test { static int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; static void subArray ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; } } } public static void main ( String [ ] args ) { System . out . println ( " All ▁ Non - empty ▁ Subarrays " ) ; subArray ( arr . length ) ; } }
import java . math . BigInteger ; class Test { static int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; static void printSubsequences ( int n ) { int opsize = ( int ) Math . pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( BigInteger . valueOf ( counter ) . testBit ( j ) ) System . out . print ( arr [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { System . out . println ( " All ▁ Non - empty ▁ Subsequences " ) ; printSubsequences ( arr . length ) ; } }
class ProductArray { void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . print ( "0" ) ; return ; } int i , temp = 1 ; int prod [ ] = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) prod [ j ] = 1 ; for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; } temp = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + " ▁ " ) ; return ; } public static void main ( String [ ] args ) { ProductArray pa = new ProductArray ( ) ; int arr [ ] = { 10 , 3 , 5 , 6 , 2 } ; int n = arr . length ; System . out . println ( " The ▁ product ▁ array ▁ is ▁ : ▁ " ) ; pa . productArray ( arr , n ) ; } }
class AreConsecutive { boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { boolean visited [ ] = new boolean [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; } int getMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } return min ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } public static void main ( String [ ] args ) { AreConsecutive consecutive = new AreConsecutive ( ) ; int arr [ ] = { 5 , 4 , 2 , 3 , 1 , 6 } ; int n = arr . length ; if ( consecutive . areConsecutive ( arr , n ) == true ) System . out . println ( " Array ▁ elements ▁ are ▁ consecutive " ) ; else System . out . println ( " Array ▁ elements ▁ are ▁ not ▁ consecutive " ) ; } }
class AreConsecutive { boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { int j ; if ( arr [ i ] < 0 ) j = - arr [ i ] - min ; else j = arr [ i ] - min ; if ( arr [ j ] > 0 ) arr [ j ] = - arr [ j ] ; else return false ; } return true ; } return false ; } int getMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } return min ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } public static void main ( String [ ] args ) { AreConsecutive consecutive = new AreConsecutive ( ) ; int arr [ ] = { 5 , 4 , 2 , 3 , 1 , 6 } ; int n = arr . length ; if ( consecutive . areConsecutive ( arr , n ) == true ) System . out . println ( " Array ▁ elements ▁ are ▁ consecutive " ) ; else System . out . println ( " Array ▁ elements ▁ are ▁ not ▁ consecutive " ) ; } }
class GFG { static void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { System . out . print ( arr1 [ i ] + " ▁ " ) ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) System . out . print ( arr1 [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 3 , 6 , 10 , 12 , 15 } ; int arr2 [ ] = { 1 , 3 , 5 , 10 , 16 } ; int n = arr1 . length ; int m = arr2 . length ; relativeComplement ( arr1 , arr2 , n , m ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int minOps ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int max = arr [ arr . length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 21 , 33 , 9 , 45 , 63 } ; int n = arr . length ; int k = 6 ; System . out . println ( minOps ( arr , n , k ) ) ; } }
import java . util . * ; class GFG { static int solve ( int [ ] A , int [ ] B , int [ ] C ) { int i , j , k ; i = A . length - 1 ; j = B . length - 1 ; k = C . length - 1 ; int min_diff , current_diff , max_term ; min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; } public static void main ( String [ ] args ) { int [ ] D = { 5 , 8 , 10 , 15 } ; int [ ] E = { 6 , 9 , 15 , 78 , 89 } ; int [ ] F = { 2 , 3 , 6 , 6 , 8 , 8 , 10 } ; System . out . println ( solve ( D , E , F ) ) ; } }
public class GFG { static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { return i ; } } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 10 , 30 , 15 } ; int x = 30 ; int n = arr . length ; System . out . printf ( " % d ▁ is ▁ present ▁ at ▁ index ▁ % d " , x , search ( arr , n , x ) ) ; } }
class BinarySearch { int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } public static void main ( String args [ ] ) { BinarySearch ob = new BinarySearch ( ) ; int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = arr . length ; int x = 10 ; int result = ob . binarySearch ( arr , 0 , n - 1 , x ) ; if ( result == - 1 ) System . out . println ( " Element ▁ not ▁ present " ) ; else System . out . println ( " Element ▁ found ▁ at ▁ index ▁ " + result ) ; } }
class BinarySearch { int binarySearch ( int arr [ ] , int x ) { int l = 0 , r = arr . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; } public static void main ( String args [ ] ) { BinarySearch ob = new BinarySearch ( ) ; int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = arr . length ; int x = 10 ; int result = ob . binarySearch ( arr , x ) ; if ( result == - 1 ) System . out . println ( " Element ▁ not ▁ present " ) ; else System . out . println ( " Element ▁ found ▁ at ▁ " + " index ▁ " + result ) ; } }
public class JumpSearch { public static int jumpSearch ( int [ ] arr , int x ) { int n = arr . length ; int step = ( int ) Math . floor ( Math . sqrt ( n ) ) ; int prev = 0 ; while ( arr [ Math . min ( step , n ) - 1 ] < x ) { prev = step ; step += ( int ) Math . floor ( Math . sqrt ( n ) ) ; if ( prev >= n ) return - 1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == Math . min ( step , n ) ) return - 1 ; } if ( arr [ prev ] == x ) return prev ; return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 } ; int x = 55 ; int index = jumpSearch ( arr , x ) ; System . out . println ( " Number " ▁ + ▁ x ▁ + ▁ " is at index " + index); } }
import java . util . Arrays ; class GFG { static int exponentialSearch ( int arr [ ] , int n , int x ) { if ( arr [ 0 ] == x ) return 0 ; int i = 1 ; while ( i < n && arr [ i ] <= x ) i = i * 2 ; return Arrays . binarySearch ( arr , i / 2 , Math . min ( i , n - 1 ) , x ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int result = exponentialSearch ( arr , arr . length , x ) ; System . out . println ( ( result < 0 ) ? " Element ▁ is ▁ not ▁ present ▁ in ▁ array " : " Element ▁ is ▁ present ▁ at ▁ index ▁ " + result ) ; } }
import java . io . * ; import java . util . * ; class Radix { static int getMax ( int arr [ ] , int n ) { int mx = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > mx ) mx = arr [ i ] ; return mx ; } static void countSort ( int arr [ ] , int n , int exp ) { int output [ ] = new int [ n ] ; int i ; int count [ ] = new int [ 10 ] ; Arrays . fill ( count , 0 ) ; for ( i = 0 ; i < n ; i ++ ) count [ ( arr [ i ] / exp ) % 10 ] ++ ; for ( i = 1 ; i < 10 ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( i = n - 1 ; i >= 0 ; i -- ) { output [ count [ ( arr [ i ] / exp ) % 10 ] - 1 ] = arr [ i ] ; count [ ( arr [ i ] / exp ) % 10 ] -- ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = output [ i ] ; } static void radixsort ( int arr [ ] , int n ) { int m = getMax ( arr , n ) ; for ( int exp = 1 ; m / exp > 0 ; exp *= 10 ) countSort ( arr , n , exp ) ; } static void print ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 170 , 45 , 75 , 90 , 802 , 24 , 2 , 66 } ; int n = arr . length ; radixsort ( arr , n ) ; print ( arr , n ) ; } }
import java . util . * ; class QuickSort { static int partition ( int arr [ ] , int low , int high ) { int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j <= high - 1 ; j ++ ) { if ( arr [ j ] <= pivot ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } int temp = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ high ] ; arr [ high ] = temp ; return i + 1 ; } static void qSort ( int arr [ ] , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; qSort ( arr , low , pi - 1 ) ; qSort ( arr , pi + 1 , high ) ; } } public static void main ( String args [ ] ) { int n = 5 ; int arr [ ] = { 4 , 2 , 6 , 9 , 2 } ; qSort ( arr , 0 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
import java . util . * ; class QuickSort { static int partition ( int arr [ ] , int low , int high ) { int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j <= high - 1 ; j ++ ) { if ( arr [ j ] <= pivot ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } int temp = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ high ] ; arr [ high ] = temp ; return i + 1 ; } static void quickSortIterative ( int arr [ ] , int l , int h ) { int [ ] stack = new int [ h - l + 1 ] ; int top = - 1 ; stack [ ++ top ] = l ; stack [ ++ top ] = h ; while ( top >= 0 ) { h = stack [ top -- ] ; l = stack [ top -- ] ; int p = partition ( arr , l , h ) ; if ( p - 1 > l ) { stack [ ++ top ] = l ; stack [ ++ top ] = p - 1 ; } if ( p + 1 < h ) { stack [ ++ top ] = p + 1 ; stack [ ++ top ] = h ; } } } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 3 , 5 , 2 , 1 , 3 , 2 , 3 } ; int n = 8 ; quickSortIterative ( arr , 0 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
class GFG { int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ; return binarySearch ( arr , mid + 2 , r , x ) ; } return - 1 ; } public static void main ( String args [ ] ) { GFG ob = new GFG ( ) ; int arr [ ] = { 3 , 2 , 10 , 4 , 40 } ; int n = arr . length ; int x = 4 ; int result = ob . binarySearch ( arr , 0 , n - 1 , x ) ; if ( result == - 1 ) System . out . println ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) ; else System . out . println ( " Element ▁ is ▁ present ▁ at ▁ index ▁ " + result ) ; } }
class ClosestPair { void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } System . out . print ( " The ▁ closest ▁ pair ▁ is ▁ [ " + ar1 [ res_l ] + " , ▁ " + ar2 [ res_r ] + " ] " ) ; } public static void main ( String args [ ] ) { ClosestPair ob = new ClosestPair ( ) ; int ar1 [ ] = { 1 , 4 , 5 , 7 } ; int ar2 [ ] = { 10 , 20 , 30 , 40 } ; int m = ar1 . length ; int n = ar2 . length ; int x = 38 ; ob . printClosest ( ar1 , ar2 , m , n , x ) ; } }
import java . io . * ; import java . util . * ; import java . lang . Math ; class CloseSum { static void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_l ] + " ▁ and ▁ " + arr [ res_r ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 22 , 28 , 29 , 30 , 40 } , x = 54 ; int n = arr . length ; printClosest ( arr , n , x ) ; } }
class CountOnes { int countOnes ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; } public static void main ( String args [ ] ) { CountOnes ob = new CountOnes ( ) ; int arr [ ] = { 1 , 1 , 1 , 1 , 0 , 0 , 0 } ; int n = arr . length ; System . out . println ( " Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ array ▁ is ▁ " + ob . countOnes ( arr , 0 , n - 1 ) ) ; } }
import java . io . * ; class GFG { public static void minimumSwaps ( int a [ ] , int n ) { int maxx = - 1 , minn = a [ 0 ] , l = 0 , r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxx ) { maxx = a [ i ] ; l = i ; } if ( a [ i ] <= minn ) { minn = a [ i ] ; r = i ; } } if ( r < l ) System . out . println ( l + ( n - r - 2 ) ) ; else System . out . println ( l + ( n - r - 1 ) ) ; } public static void main ( String args [ ] ) throws IOException { int a [ ] = { 5 , 6 , 1 , 3 } ; int n = a . length ; minimumSwaps ( a , n ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class ActivitySelection { public static void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; System . out . print ( " Following ▁ activities ▁ are ▁ selected ▁ : ▁ n " ) ; i = 0 ; System . out . print ( i + " ▁ " ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { System . out . print ( j + " ▁ " ) ; i = j ; } } } public static void main ( String [ ] args ) { int s [ ] = { 1 , 3 , 0 , 5 , 8 , 5 } ; int f [ ] = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = s . length ; printMaxActivities ( s , f , n ) ; } }
public class LongestCommonSubsequence { int lcs ( char [ ] X , char [ ] Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } public static void main ( String [ ] args ) { LongestCommonSubsequence lcs = new LongestCommonSubsequence ( ) ; String s1 = " AGGTAB " ; String s2 = " GXTXAYB " ; char [ ] X = s1 . toCharArray ( ) ; char [ ] Y = s2 . toCharArray ( ) ; int m = X . length ; int n = Y . length ; System . out . println ( " Length ▁ of ▁ LCS ▁ is " + " ▁ " + lcs . lcs ( X , Y , m , n ) ) ; } }
public class LongestCommonSubsequence { int lcs ( char [ ] X , char [ ] Y , int m , int n ) { int L [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } public static void main ( String [ ] args ) { LongestCommonSubsequence lcs = new LongestCommonSubsequence ( ) ; String s1 = " AGGTAB " ; String s2 = " GXTXAYB " ; char [ ] X = s1 . toCharArray ( ) ; char [ ] Y = s2 . toCharArray ( ) ; int m = X . length ; int n = Y . length ; System . out . println ( " Length ▁ of ▁ LCS ▁ is " + " ▁ " + lcs . lcs ( X , Y , m , n ) ) ; } }
public class GFG { static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } static int minCost ( int cost [ ] [ ] , int m , int n ) { if ( n < 0 m < 0 ) return Integer . MAX_VALUE ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . print ( minCost ( cost , 2 , 2 ) ) ; } }
import java . util . * ; class MinimumCostPath { private static int minCost ( int cost [ ] [ ] , int m , int n ) { int i , j ; int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; } private static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . println ( minCost ( cost , 2 , 2 ) ) ; } }
class Knapsack { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } public static void main ( String args [ ] ) { int val [ ] = new int [ ] { 60 , 100 , 120 } ; int wt [ ] = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; System . out . println ( knapSack ( W , wt , val , n ) ) ; } }
class Knapsack { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; } public static void main ( String args [ ] ) { int val [ ] = new int [ ] { 60 , 100 , 120 } ; int wt [ ] = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; System . out . println ( knapSack ( W , wt , val , n ) ) ; } }
class EggDrop { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int eggDrop ( int n , int k ) { int eggFloor [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = Integer . MAX_VALUE ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; } public static void main ( String args [ ] ) { int n = 2 , k = 10 ; System . out . println ( " Minimum ▁ number ▁ of ▁ trials ▁ in ▁ worst " + " ▁ case ▁ with ▁ " + n + " ▁ eggs ▁ and ▁ " + k + " ▁ floors ▁ is ▁ " + eggDrop ( n , k ) ) ; } }
class GFG { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int lps ( char seq [ ] , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } public static void main ( String [ ] args ) { String seq = " GEEKSFORGEEKS " ; int n = seq . length ( ) ; System . out . printf ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d " , lps ( seq . toCharArray ( ) , 0 , n - 1 ) ) ; } }
class LPS { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int lps ( String seq ) { int n = seq . length ( ) ; int i , j , cl ; int L [ ] [ ] = new int [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( seq . charAt ( i ) == seq . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( seq . charAt ( i ) == seq . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { String seq = " GEEKSFORGEEKS " ; int n = seq . length ( ) ; System . out . println ( " The ▁ length ▁ of ▁ the ▁ lps ▁ is ▁ " + lps ( seq ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class LBS { static int lbs ( int arr [ ] , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 } ; int n = arr . length ; System . out . println ( " Length ▁ of ▁ LBS ▁ is ▁ " + lbs ( arr , n ) ) ; } }
class GFG { static int maxDivide ( int a , int b ) { while ( a % b == 0 ) a = a / b ; return a ; } static int isUgly ( int no ) { no = maxDivide ( no , 2 ) ; no = maxDivide ( no , 3 ) ; no = maxDivide ( no , 5 ) ; return ( no == 1 ) ? 1 : 0 ; } static int getNthUglyNo ( int n ) { int i = 1 ; int count = 1 ; while ( n > count ) { i ++ ; if ( isUgly ( i ) == 1 ) count ++ ; } return i ; } public static void main ( String args [ ] ) { int no = getNthUglyNo ( 150 ) ; System . out . println ( "150th ▁ ugly ▁ " + " no . ▁ is ▁ " + no ) ; } }
class sum_dig { static int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( sum == 0 ) return 1 ; int ans = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } static int finalCount ( int n , int sum ) { int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } public static void main ( String args [ ] ) { int n = 2 , sum = 5 ; System . out . println ( finalCount ( n , sum ) ) ; } }
class sum_dig { static int lookup [ ] [ ] = new int [ 101 ] [ 501 ] ; static int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( lookup [ n ] [ sum ] != - 1 ) return lookup [ n ] [ sum ] ; int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return lookup [ n ] [ sum ] = ans ; } static int finalCount ( int n , int sum ) { for ( int i = 0 ; i <= 100 ; ++ i ) { for ( int j = 0 ; j <= 500 ; ++ j ) { lookup [ i ] [ j ] = - 1 ; } } int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } public static void main ( String args [ ] ) { int n = 3 , sum = 5 ; System . out . println ( finalCount ( n , sum ) ) ; } }
public class GFG { private static void findCount ( int n , int sum ) { int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i < end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int n = 3 ; int sum = 5 ; findCount ( n , sum ) ; } }
class NDN { static int countNonDecreasing ( int n ) { int dp [ ] [ ] = new int [ 10 ] [ n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . println ( countNonDecreasing ( n ) ) ; } }
public class GFG { static long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . print ( countNonDecreasing ( n ) ) ; } }
class squares { static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; } public static void main ( String args [ ] ) { System . out . println ( getMinSquares ( 6 ) ) ; } }
class squares { static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; } public static void main ( String args [ ] ) { System . out . println ( getMinSquares ( 6 ) ) ; } }
class coin { static int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; } public static void main ( String args [ ] ) { int coins [ ] = { 9 , 6 , 5 , 1 } ; int m = coins . length ; int V = 11 ; System . out . println ( " Minimum ▁ coins ▁ required ▁ is ▁ " + minCoins ( coins , m , V ) ) ; } }
import java . io . * ; class GFG { static int minCoins ( int coins [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } if ( table [ V ] == Integer . MAX_VALUE ) return - 1 ; return table [ V ] ; } public static void main ( String [ ] args ) { int coins [ ] = { 9 , 6 , 5 , 1 } ; int m = coins . length ; int V = 11 ; System . out . println ( " Minimum ▁ coins ▁ required ▁ is ▁ " + minCoins ( coins , m , V ) ) ; } }
class GFG { static int superSeq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; } public static void main ( String args [ ] ) { String X = " AGGTAB " ; String Y = " GXTXAYB " ; System . out . println ( " Length ▁ of ▁ the ▁ shortest " + " supersequence ▁ is : ▁ " + superSeq ( X , Y , X . length ( ) , Y . length ( ) ) ) ; } }
class GFG { static int superSeq ( String X , String Y , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; } public static void main ( String args [ ] ) { String X = " AGGTAB " ; String Y = " GXTXAYB " ; System . out . println ( " Length ▁ of ▁ the ▁ shortest ▁ supersequence ▁ is ▁ " + superSeq ( X , Y , X . length ( ) , Y . length ( ) ) ) ; } }
import java . io . * ; class GFG { static int sumOfDigitsFrom1ToN ( int n ) { int result = 0 ; for ( int x = 1 ; x <= n ; x ++ ) result += sumOfDigits ( x ) ; return result ; } static int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; } public static void main ( String args [ ] ) { int n = 328 ; System . out . println ( " Sum ▁ of ▁ digits ▁ in ▁ numbers " + " ▁ from ▁ 1 ▁ to ▁ " + n + " ▁ is ▁ " + sumOfDigitsFrom1ToN ( n ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; } public static void main ( String args [ ] ) { int n = 328 ; System . out . println ( " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ " + " from ▁ 1 ▁ to ▁ " + n + " ▁ is ▁ " + sumOfDigitsFrom1ToN ( n ) ) ; } }
class Building { static int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; } public static void main ( String args [ ] ) { int N = 3 ; System . out . println ( " Count ▁ of ▁ ways ▁ for ▁ " + N + " ▁ sections ▁ is ▁ " + countWays ( N ) ) ; } }
import java . util . Arrays ; class GFG { static int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( " Count ▁ for ▁ " + n + " ▁ is ▁ " + count ( n ) ) ; n = 13 ; System . out . println ( " Count ▁ for ▁ " + n + " ▁ is ▁ " + count ( n ) ) ; } }
public class NaiveSearch { public static void search ( String txt , String pat ) { int M = pat . length ( ) ; int N = txt . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } } public static void main ( String [ ] args ) { String txt = " AABAACAADAABAAABAA " ; String pat = " AABA " ; search ( txt , pat ) ; } }
public class Main { public final static int d = 256 ; static void search ( String pat , String txt , int q ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i , j ; int p = 0 ; int t = 0 ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat . charAt ( i ) ) % q ; t = ( d * t + txt . charAt ( i ) ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; } if ( j == M ) System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } if ( i < N - M ) { t = ( d * ( t - txt . charAt ( i ) * h ) + txt . charAt ( i + M ) ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } public static void main ( String [ ] args ) { String txt = " GEEKS ▁ FOR ▁ GEEKS " ; String pat = " GEEK " ; int q = 101 ; search ( pat , txt , q ) ; } }
class GFG { static void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) { System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } public static void main ( String [ ] args ) { String txt = " ABCEABCDABCEABCD " ; String pat = " ABCD " ; search ( pat , txt ) ; } }
import java . io . * ; class Permutation { static void printPatternUtil ( String str , char buf [ ] , int i , int j , int n ) { if ( i == n ) { buf [ j ] = ' \0' ; System . out . println ( buf ) ; return ; } buf [ j ] = str . charAt ( i ) ; printPatternUtil ( str , buf , i + 1 , j + 1 , n ) ; buf [ j ] = ' ▁ ' ; buf [ j + 1 ] = str . charAt ( i ) ; printPatternUtil ( str , buf , i + 1 , j + 2 , n ) ; } static void printPattern ( String str ) { int len = str . length ( ) ; char [ ] buf = new char [ 2 * len ] ; buf [ 0 ] = str . charAt ( 0 ) ; printPatternUtil ( str , buf , 1 , 1 , len ) ; } public static void main ( String [ ] args ) { String str = " ABCD " ; printPattern ( str ) ; } }
class Main { static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; } public static void main ( String [ ] args ) { int ar1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = ar1 . length ; int n2 = ar2 . length ; if ( n1 == n2 ) System . out . println ( " Median ▁ is ▁ " + getMedian ( ar1 , ar2 , n1 ) ) ; else System . out . println ( " arrays ▁ are ▁ of ▁ unequal ▁ size " ) ; } }
import java . util . * ; class GFG { static double area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; } static boolean isInside ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x , int y ) { double A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ; double A1 = area ( x , y , x2 , y2 , x3 , y3 ) ; double A2 = area ( x1 , y1 , x , y , x3 , y3 ) ; double A3 = area ( x1 , y1 , x2 , y2 , x , y ) ; return ( A == A1 + A2 + A3 ) ; } public static void main ( String [ ] args ) { if ( isInside ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) System . out . println ( " Inside " ) ; else System . out . println ( " Not ▁ Inside " ) ; } }
import java . io . * ; class GFG { public static int counter = 2 ; static boolean isLucky ( int n ) { int next_position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; } public static void main ( String [ ] args ) { int x = 5 ; if ( isLucky ( x ) ) System . out . println ( x + " ▁ is ▁ a ▁ lucky ▁ no . " ) ; else System . out . println ( x + " ▁ is ▁ not ▁ a ▁ lucky ▁ no . " ) ; } }
import java . io . * ; class GFG { static int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; } public static void main ( String [ ] args ) { System . out . println ( pow ( 5 , 3 ) ) ; } }
import java . io . * ; class GFG { static int multiply ( int x , int y ) { if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; } static int pow ( int a , int b ) { if ( b > 0 ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; } public static void main ( String [ ] args ) { System . out . println ( pow ( 5 , 3 ) ) ; } }
import java . io . * ; class GFG { static int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; } public static void main ( String [ ] args ) { int n = 578 ; System . out . println ( count ( n ) ) ; } }
import java . io . * ; class GFG { static int maximumNumberDistinctPrimeRange ( int m , int n ) { long factorCount [ ] = new long [ n + 1 ] ; boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = ( int ) factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = ( int ) factorCount [ i ] ; num = i ; } } return num ; } public static void main ( String [ ] args ) { int m = 4 , n = 6 ; System . out . println ( maximumNumberDistinctPrimeRange ( m , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } static int findSmallerInRight ( String str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str . charAt ( i ) < str . charAt ( low ) ) ++ countRight ; return countRight ; } static int findRank ( String str ) { int len = str . length ( ) ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; for ( int i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; } public static void main ( String [ ] args ) { String str = " string " ; System . out . println ( findRank ( str ) ) ; } }
class GFG { static int MAX_CHAR = 256 ; int count [ ] = new int [ MAX_CHAR ] ; static int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } static void populateAndIncreaseCount ( int [ ] count , char [ ] str ) { int i ; for ( i = 0 ; i < str . length ; ++ i ) ++ count [ str [ i ] ] ; for ( i = 1 ; i < MAX_CHAR ; ++ i ) count [ i ] += count [ i - 1 ] ; } static void updatecount ( int [ ] count , char ch ) { int i ; for ( i = ch ; i < MAX_CHAR ; ++ i ) -- count [ i ] ; } static int findRank ( char [ ] str ) { int len = str . length ; int mul = fact ( len ) ; int rank = 1 , i ; populateAndIncreaseCount ( count , str ) ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; rank += count [ str [ i ] - 1 ] * mul ; updatecount ( count , str [ i ] ) ; } return rank ; } public static void main ( String args [ ] ) { char str [ ] = " string " . toCharArray ( ) ; System . out . println ( findRank ( str ) ) ; } }
import java . io . * ; class GFG { static float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; } public static void main ( String [ ] args ) { int n = 10 ; float x = 1 ; System . out . println ( " e ^ x ▁ = ▁ " + exponential ( n , x ) ) ; } }
class GFG { static boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; } static boolean isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; } public static void main ( String [ ] args ) { for ( int i = 1 ; i <= 10 ; i ++ ) System . out . println ( isFibonacci ( i ) ? i + " ▁ is ▁ a ▁ Fibonacci ▁ Number " : i + " ▁ is ▁ a ▁ not ▁ Fibonacci ▁ Number " ) ; } }
import java . io . * ; class GFG { static int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; } public static void main ( String [ ] args ) { int n = 100 ; System . out . println ( " Count ▁ of ▁ trailing ▁ 0s ▁ in ▁ " + n + " ! ▁ is ▁ " + findTrailingZeros ( n ) ) ; } }
class CatalnNumber { int catalan ( int n ) { if ( n <= 1 ) { return 1 ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += catalan ( i ) * catalan ( n - i - 1 ) ; } return res ; } public static void main ( String [ ] args ) { CatalnNumber cn = new CatalnNumber ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( cn . catalan ( i ) + " ▁ " ) ; } } }
class GFG { static int catalanDP ( int n ) { int catalan [ ] = new int [ n + 2 ] ; catalan [ 0 ] = 1 ; catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } return catalan [ n ] ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( catalanDP ( i ) + " ▁ " ) ; } } }
class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) { k = n - k ; } for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( catalan ( i ) + " ▁ " ) ; } } }
import java . io . * ; class GFG { static int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) System . out . println ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; } public static void main ( String [ ] args ) { System . out . println ( calcAngle ( 9 , 60 ) + " ▁ degree " ) ; System . out . println ( calcAngle ( 3 , 30 ) + " ▁ degree " ) ; } }
class GFG { static int getInvCount ( int [ ] [ ] arr ) { int inv_count = 0 ; for ( int i = 0 ; i < 3 - 1 ; i ++ ) for ( int j = i + 1 ; j < 3 ; j ++ ) if ( arr [ j ] [ i ] > 0 && arr [ j ] [ i ] > arr [ i ] [ j ] ) inv_count ++ ; return inv_count ; } static boolean isSolvable ( int [ ] [ ] puzzle ) { int invCount = getInvCount ( puzzle ) ; return ( invCount % 2 == 0 ) ; } public static void main ( String [ ] args ) { int [ ] [ ] puzzle = { { 1 , 8 , 2 } , { 0 , 4 , 3 } , { 7 , 6 , 5 } } ; if ( isSolvable ( puzzle ) ) System . out . println ( " Solvable " ) ; else System . out . println ( " Not ▁ Solvable " ) ; } }
class GFG { static double find ( double p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; } public static void main ( String [ ] args ) { System . out . println ( find ( 0.70 ) ) ; } }
import java . io . * ; class GFG { static int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; } public static void main ( String args [ ] ) { System . out . println ( " Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ " + countSolutions ( 6 ) ) ; } }
import java . io . * ; class GFG { static int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; } public static void main ( String args [ ] ) { System . out . println ( " Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ " + countSolutions ( 6 ) ) ; } }
class GFG { static final double EPSILON = 0.001 ; static double func ( double x ) { return x * x * x - x * x + 2 ; } static double derivFunc ( double x ) { return 3 * x * x - 2 * x ; } static void newtonRaphson ( double x ) { double h = func ( x ) / derivFunc ( x ) ; while ( Math . abs ( h ) >= EPSILON ) { h = func ( x ) / derivFunc ( x ) ; x = x - h ; } System . out . print ( " The ▁ value ▁ of ▁ the " + " ▁ root ▁ is ▁ : ▁ " + Math . round ( x * 100.0 ) / 100.0 ) ; } public static void main ( String [ ] args ) { double x0 = - 20 ; newtonRaphson ( x0 ) ; } }
class GFG { static int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = arr . length ; System . out . println ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " + getSingle ( arr , n ) ) ; } }
class GFG { static final int INT_SIZE = 32 ; static int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = arr . length ; System . out . println ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " + getSingle ( arr , n ) ) ; } }
class GFG { static boolean oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; } public static void main ( String [ ] args ) { int x = 100 , y = - 100 ; if ( oppositeSigns ( x , y ) == true ) System . out . println ( " Signs ▁ are ▁ opposite " ) ; else System . out . println ( " Signs ▁ are ▁ not ▁ opposite " ) ; } }
class GFG { static int countSetBits ( int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) bitCount += countSetBitsUtil ( i ) ; return bitCount ; } static int countSetBitsUtil ( int x ) { if ( x <= 0 ) return 0 ; return ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ " ) ; System . out . print ( countSetBits ( n ) ) ; } }
public class GFG { static int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { boolean k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; } public static void main ( String [ ] args ) { int n = 17 ; System . out . println ( countSetBits ( n ) ) ; } }
class GFG { static int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; } public static void main ( String [ ] args ) { int res = swapBits ( 28 , 0 , 3 , 2 ) ; System . out . println ( " Result ▁ = ▁ " + res ) ; } }
class GFG { static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; } public static void main ( String [ ] args ) { int x = 12 , y = 15 , z = 5 ; System . out . printf ( " Minimum ▁ of ▁ 3" + " ▁ numbers ▁ is ▁ % d " , smallest ( x , y , z ) ) ; } }
class GFG { static int snoob ( int x ) { int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; } public static void main ( String [ ] args ) { int x = 156 ; System . out . println ( " Next ▁ higher ▁ number ▁ with ▁ same " + " number ▁ of ▁ set ▁ bits ▁ is ▁ " + snoob ( x ) ) ; } }
class GFG { static int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } public static void main ( String [ ] args ) { System . out . println ( addOne ( 13 ) ) ; } }
class GFG { static int addOne ( int x ) { return ( - ( ~ x ) ) ; } public static void main ( String [ ] args ) { System . out . printf ( " % d " , addOne ( 13 ) ) ; } }
class GFG { static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; } public static void main ( String [ ] args ) { int x = 2 ; System . out . println ( multiplyWith3Point5 ( x ) ) ; } }
class GFG { static int fun ( int n ) { return n & ( n - 1 ) ; } public static void main ( String arg [ ] ) { int n = 7 ; System . out . print ( " The ▁ number ▁ after ▁ unsetting ▁ " + " the ▁ rightmost ▁ set ▁ bit ▁ " + fun ( n ) ) ; } }
class GFG { static int isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; } public static void main ( String [ ] args ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) == 1 ) System . out . println ( test_no + " ▁ is ▁ a ▁ power ▁ of ▁ 4" ) ; else System . out . println ( test_no + " is ▁ not ▁ a ▁ power ▁ of ▁ 4" ) ; } }
import java . io . * ; class GFG { static int isPowerOfFour ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; } public static void main ( String [ ] args ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) > 0 ) System . out . println ( test_no + " ▁ is ▁ a ▁ power ▁ of ▁ 4" ) ; else System . out . println ( test_no + " ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4" ) ; } }
public class AWS { static int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x << y ) ) ; } static int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x << y ) ) ; } public static void main ( String [ ] args ) { int x = 15 ; int y = 6 ; System . out . print ( " Minimum ▁ of ▁ " + x + " ▁ and ▁ " + y + " ▁ is ▁ " ) ; System . out . println ( min ( x , y ) ) ; System . out . print ( " Maximum ▁ of ▁ " + x + " ▁ and ▁ " + y + " ▁ is ▁ " ) ; System . out . println ( max ( x , y ) ) ; } }
class OddOccurrence { static int getOddOccurrence ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 } ; int n = arr . length ; System . out . println ( getOddOccurrence ( arr , n ) ) ; } }
import java . util . * ; class Count { public static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; } public static int FlippedCount ( int a , int b ) { return countSetBits ( a ^ b ) ; } public static void main ( String [ ] args ) { int a = 10 ; int b = 20 ; System . out . print ( FlippedCount ( a , b ) ) ; } }
class GFG { public static int getFirstSetBitPos ( int n ) { return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( getFirstSetBitPos ( n ) ) ; } }
class GFG { static int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . println ( PositionRightmostSetbit ( n ) ) ; } }
public class GFG { static int INT_SIZE = 32 ; static int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ; else break ; } return pos ; } public static void main ( String [ ] args ) { int num = 18 ; int pos = Right_most_setbit ( num ) ; System . out . println ( pos ) ; } }
class GFG { static void bin ( Integer n ) { if ( n > 1 ) bin ( n >> 1 ) ; System . out . printf ( " % d " , n & 1 ) ; } public static void main ( String [ ] args ) { bin ( 131 ) ; System . out . printf ( "NEW_LINE"); bin ( 3 ) ; } }
class GFG { static int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; } public static void main ( String [ ] args ) { int x = 23 ; System . out . println ( swapBits ( x ) ) ; } }
class GFG { static boolean isPowerOfTwo ( int n ) { return ( n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ) ? true : false ; } static int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int i = 1 , pos = 1 ; while ( ( i & n ) == 0 ) { i = i << 1 ; ++ pos ; } return pos ; } public static void main ( String [ ] args ) { int n = 16 ; int pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 12 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 128 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; } }
class GFG { static boolean isPowerOfTwo ( int n ) { return n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int count = 0 ; while ( n > 0 ) { n = n >> 1 ; ++ count ; } return count ; } public static void main ( String [ ] args ) { int n = 0 ; int pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 12 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 128 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; } }
import java . io . * ; class GFG { public static void main ( String [ ] args ) { int x = 10 ; int y = 5 ; x = x * y ; y = x / y ; x = x / y ; System . out . println ( " After ▁ swaping : " + " ▁ x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; } }
import java . io . * ; public class GFG { public static void main ( String a [ ] ) { int x = 10 ; int y = 5 ; x = x ^ y ; y = x ^ y ; x = x ^ y ; System . out . println ( " After ▁ swap : ▁ x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; } }
class GFG { static void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; } public static void main ( String [ ] args ) { int [ ] x = { 10 } ; swap ( x , x ) ; System . out . println ( " After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ " + x [ 0 ] ) ; } }
import java . io . * ; class Binary { static int maxOnesIndex ( int arr [ ] , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( " Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is ▁ " + maxOnesIndex ( arr , n ) ) ; } }
class LargestSubArray2 { int min ( int x , int y ) { return ( x < y ) ? x : y ; } int max ( int x , int y ) { return ( x > y ) ? x : y ; } int findLength ( int arr [ ] , int n ) { int max_len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int mn = arr [ i ] , mx = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { mn = min ( mn , arr [ j ] ) ; mx = max ( mx , arr [ j ] ) ; if ( ( mx - mn ) == j - i ) max_len = max ( max_len , mx - mn + 1 ) ; } } return max_len ; } public static void main ( String [ ] args ) { LargestSubArray2 large = new LargestSubArray2 ( ) ; int arr [ ] = { 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 } ; int n = arr . length ; System . out . println ( " Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is ▁ " + large . findLength ( arr , n ) ) ; } }
class GFG { static void printArr ( int [ ] arr , int k ) { for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . print ( "NEW_LINE"); } static void printSeqUtil ( int n , int k , int len , int [ ] arr ) { if ( len == k ) { printArr ( arr , k ) ; return ; } int i = ( len == 0 ) ? 1 : arr [ len - 1 ] + 1 ; len ++ ; while ( i < = n ) { arr [ len - 1 ] = i ; printSeqUtil ( n , k , len , arr ) ; i ++ ; } len -- ; } static void printSeq ( int n , int k ) { int [ ] arr = new int [ k ] ; int len = 0 ; printSeqUtil ( n , k , len , arr ) ; } static public void main ( String [ ] args ) { int k = 3 , n = 7 ; printSeq ( n , k ) ; } }
import java . io . * ; class SubSequence { static boolean isSubSequence ( String str1 , String str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; } public static void main ( String [ ] args ) { String str1 = " gksrek " ; String str2 = " geeksforgeeks " ; int m = str1 . length ( ) ; int n = str2 . length ( ) ; boolean res = isSubSequence ( str1 , str2 , m , n ) ; if ( res ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class NextGreatest { static void nextGreatest ( int arr [ ] ) { int size = arr . length ; int max_from_right = arr [ size - 1 ] ; arr [ size - 1 ] = - 1 ; for ( int i = size - 2 ; i >= 0 ; i -- ) { int temp = arr [ i ] ; arr [ i ] = max_from_right ; if ( max_from_right < temp ) max_from_right = temp ; } } static void printArray ( int arr [ ] ) { for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; nextGreatest ( arr ) ; System . out . println ( " The ▁ modified ▁ array : " ) ; printArray ( arr ) ; } }
import java . util . Arrays ; class GFG { static int GetCeilIndex ( int arr [ ] , int T [ ] , int l , int r , int key ) { while ( r - l > 1 ) { int m = l + ( r - l ) / 2 ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; } static int LongestIncreasingSubsequence ( int arr [ ] , int n ) { int tailIndices [ ] = new int [ n ] ; Arrays . fill ( tailIndices , 0 ) ; int prevIndices [ ] = new int [ n ] ; Arrays . fill ( prevIndices , - 1 ) ; int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ tailIndices [ 0 ] ] ) tailIndices [ 0 ] = i ; else if ( arr [ i ] > arr [ tailIndices [ len - 1 ] ] ) { prevIndices [ i ] = tailIndices [ len - 1 ] ; tailIndices [ len ++ ] = i ; } else { int pos = GetCeilIndex ( arr , tailIndices , - 1 , len - 1 , arr [ i ] ) ; prevIndices [ i ] = tailIndices [ pos - 1 ] ; tailIndices [ pos ] = i ; } } System . out . println ( " LIS ▁ of ▁ given ▁ input " ) ; for ( int i = tailIndices [ len - 1 ] ; i >= 0 ; i = prevIndices [ i ] ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; return len ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 } ; int n = arr . length ; System . out . print ( "LIS sizeNEW_LINE" + LongestIncreasingSubsequence(arr, n)); } }
class GenerateArrays { void generateUtil ( int A [ ] , int B [ ] , int C [ ] , int i , int j , int m , int n , int len , boolean flag ) { if ( flag ) { if ( len != 0 ) printArr ( C , len + 1 ) ; for ( int k = i ; k < m ; k ++ ) { if ( len == 0 ) { C [ len ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len , ! flag ) ; } else if ( A [ k ] > C [ len ] ) { C [ len + 1 ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , ! flag ) ; } } } else { for ( int l = j ; l < n ; l ++ ) { if ( B [ l ] > C [ len ] ) { C [ len + 1 ] = B [ l ] ; generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , ! flag ) ; } } } } void generate ( int A [ ] , int B [ ] , int m , int n ) { int C [ ] = new int [ m + n ] ; generateUtil ( A , B , C , 0 , 0 , m , n , 0 , true ) ; } void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { GenerateArrays generate = new GenerateArrays ( ) ; int A [ ] = { 10 , 15 , 25 } ; int B [ ] = { 5 , 20 , 30 } ; int n = A . length ; int m = B . length ; generate . generate ( A , B , n , m ) ; } }
public class GFG { static void replace_elements ( int arr [ ] , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 6 , 4 , 3 , 4 , 3 , 3 , 5 } ; int n = arr . length ; replace_elements ( arr , n ) ; } }
import java . io . * ; class GFG { static void arrangeString ( String str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { System . out . print ( "0" ) ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { System . out . print ( "1" ) ; count_1 -- ; } } } } public static void main ( String [ ] args ) { String str = "01101101101101101000000" ; int x = 1 ; int y = 2 ; arrangeString ( str , x , y ) ; } }
import java . io . * ; class GFG { public static void rearrange ( int [ ] arr ) { if ( arr == null arr . length % 2 == 1 ) return ; int currIdx = ( arr . length - 1 ) / 2 ; while ( currIdx > 0 ) { int count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 2 , 4 , 6 } ; rearrange ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( " ▁ " + arr [ i ] ) ; } }
class MaximumDiffrence { int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; } public static void main ( String [ ] args ) { MaximumDifference maxdif = new MaximumDifference ( ) ; int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; System . out . println ( " Maximum ▁ difference ▁ is ▁ " + maxdif . maxDiff ( arr , 5 ) ) ; } }
import java . io . * ; class GFG { static int maxDiff ( int arr [ ] , int n ) { int maxDiff = - 1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; int n = arr . length ; System . out . println ( " Maximum ▁ difference ▁ is ▁ " + maxDiff ( arr , n ) ) ; } }
class GFG { static int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 80 , 2 , 6 , 3 , 100 } ; int n = arr . length ; System . out . print ( " Maximum ▁ difference ▁ is ▁ " + maxDiff ( arr , n ) ) ; } }
class Main { static int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 } ; int n = arr . length ; System . out . println ( " The ▁ maximum ▁ element ▁ is ▁ " + findMaximum ( arr , 0 , n - 1 ) ) ; } }
class Main { static int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = arr . length ; System . out . println ( " The ▁ maximum ▁ element ▁ is ▁ " + findMaximum ( arr , 0 , n - 1 ) ) ; } }
class MaximumSumPath { int max ( int x , int y ) { return ( x > y ) ? x : y ; } int maxPathSum ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { int i = 0 , j = 0 ; int result = 0 , sum1 = 0 , sum2 = 0 ; while ( i < m && j < n ) { if ( ar1 [ i ] < ar2 [ j ] ) sum1 += ar1 [ i ++ ] ; else if ( ar1 [ i ] > ar2 [ j ] ) sum2 += ar2 [ j ++ ] ; else { result += max ( sum1 , sum2 ) + ar1 [ i ] ; sum1 = 0 ; sum2 = 0 ; i ++ ; j ++ ; } } while ( i < m ) sum1 += ar1 [ i ++ ] ; while ( j < n ) sum2 += ar2 [ j ++ ] ; result += max ( sum1 , sum2 ) ; return result ; } public static void main ( String [ ] args ) { MaximumSumPath sumpath = new MaximumSumPath ( ) ; int ar1 [ ] = { 2 , 3 , 7 , 10 , 12 , 15 , 30 , 34 } ; int ar2 [ ] = { 1 , 5 , 7 , 8 , 10 , 15 , 16 , 19 } ; int m = ar1 . length ; int n = ar2 . length ; System . out . println ( " Maximum ▁ sum ▁ path ▁ is ▁ : " + sumpath . maxPathSum ( ar1 , ar2 , m , n ) ) ; } }
import java . io . * ; class GFG { static void smallestGreater ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int diff = Integer . MAX_VALUE ; int closest = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } if ( closest == - 1 ) System . out . print ( " _ ▁ " ) ; else System . out . print ( arr [ closest ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int ar [ ] = { 6 , 3 , 9 , 8 , 10 , 2 , 1 , 15 , 7 } ; int n = ar . length ; smallestGreater ( ar , n ) ; } }
class Test { static int arr [ ] = new int [ ] { 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 } ; static void findZeroes ( int m ) { int wL = 0 , wR = 0 ; int bestL = 0 , bestWindow = 0 ; int zeroCount = 0 ; while ( wR < arr . length ) { if ( zeroCount <= m ) { if ( arr [ wR ] == 0 ) zeroCount ++ ; wR ++ ; } if ( zeroCount > m ) { if ( arr [ wL ] == 0 ) zeroCount -- ; wL ++ ; } if ( ( wR - wL > bestWindow ) && ( zeroCount <= m ) ) { bestWindow = wR - wL ; bestL = wL ; } } for ( int i = 0 ; i < bestWindow ; i ++ ) { if ( arr [ bestL + i ] == 0 ) System . out . print ( bestL + i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int m = 2 ; System . out . println ( " Indexes ▁ of ▁ zeroes ▁ to ▁ be ▁ flipped ▁ are ▁ " ) ; findZeroes ( m ) ; } }
class Test { static int arr [ ] = new int [ ] { 1 , 2 , 2 , 4 } ; static int countIncreasing ( int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; } public static void main ( String [ ] args ) { System . out . println ( " Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is ▁ " + countIncreasing ( arr . length ) ) ; } }
class Test { static int arr [ ] = new int [ ] { 1 , 2 , 2 , 4 } ; static int countIncreasing ( int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } public static void main ( String [ ] args ) { System . out . println ( " Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is ▁ " + countIncreasing ( arr . length ) ) ; } }
import java . util . Arrays ; public class GFG { static long arraySum ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum ; } static long maxDiff ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; long arraysum = arraySum ( arr , n ) ; long diff1 = Math . abs ( arraysum - 2 * arraySum ( arr , k ) ) ; int end = arr . length - 1 ; int start = 0 ; while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } long diff2 = Math . abs ( arraysum - 2 * arraySum ( arr , k ) ) ; return ( Math . max ( diff1 , diff2 ) ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 7 , 4 , 8 , - 1 , 5 , 2 , 1 } ; int n = arr . length ; int k = 3 ; System . out . println ( " Maximum ▁ Difference ▁ = ▁ " + maxDiff ( arr , n , k ) ) ; } }
import java . util . Arrays ; class GFG { static int minNumber ( int a [ ] , int n , int x ) { Arrays . sort ( a ) ; int k ; for ( k = 0 ; a [ ( n ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; Arrays . sort ( a ) ; } return k ; } public static void main ( String [ ] args ) { int x = 10 ; int a [ ] = { 10 , 20 , 30 } ; int n = 3 ; System . out . println ( minNumber ( a , n - 1 , x ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static int minNumber ( int a [ ] , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; } public static void main ( String [ ] args ) { int x = 10 ; int a [ ] = { 10 , 20 , 30 } ; int n = a . length ; System . out . println ( minNumber ( a , n , x ) ) ; } }
import java . io . * ; class GFG { static void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( arr [ r ] == 1 ) System . out . println ( " odd " ) ; else System . out . println ( " even " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 0 , 1 } ; int n = arr . length ; checkEVENodd ( arr , n , 1 , 3 ) ; } }
public class Main { static int findMean ( int arr [ ] , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = ( int ) Math . floor ( sum / count ) ; return mean ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; System . out . println ( findMean ( arr , 0 , 2 ) ) ; System . out . println ( findMean ( arr , 1 , 3 ) ) ; System . out . println ( findMean ( arr , 0 , 4 ) ) ; } }
import java . io . * ; class GFG { static int calculateProduct ( int [ ] A , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans = 1 ; for ( int i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; } static public void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 , 4 , 5 , 6 } ; int P = 229 ; int L = 2 , R = 5 ; System . out . println ( calculateProduct ( A , L , R , P ) ) ; L = 1 ; R = 3 ; System . out . println ( calculateProduct ( A , L , R , P ) ) ; } }
import java . util . * ; class GFG { static final int MAX = 10000 ; static int prefix [ ] = new int [ MAX + 1 ] ; static void buildPrefix ( ) { boolean prime [ ] = new boolean [ MAX + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] ) prefix [ p ] ++ ; } } static int query ( int L , int R ) { return prefix [ R ] - prefix [ L - 1 ] ; } public static void main ( String [ ] args ) { buildPrefix ( ) ; int L = 5 , R = 10 ; System . out . println ( query ( L , R ) ) ; L = 1 ; R = 10 ; System . out . println ( query ( L , R ) ) ; } }
class GFG { static void command ( boolean arr [ ] , int a , int b ) { arr [ a ] ^= true ; arr [ b + 1 ] ^= true ; } static void process ( boolean arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { arr [ k ] ^= arr [ k - 1 ] ; } } static void result ( boolean arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { if ( arr [ k ] == true ) System . out . print ( "1" + " ▁ " ) ; else System . out . print ( "0" + " ▁ " ) ; } } public static void main ( String args [ ] ) { int n = 5 , m = 3 ; boolean arr [ ] = new boolean [ n + 2 ] ; command ( arr , 1 , 5 ) ; command ( arr , 2 , 5 ) ; command ( arr , 3 , 5 ) ; process ( arr , n ) ; result ( arr , n ) ; } }
import java . io . * ; class GFG { static double probability ( int a [ ] , int b [ ] , int size1 , int size2 ) { int max1 = Integer . MIN_VALUE , count1 = 0 ; for ( int i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max1 ) { max1 = a [ i ] ; count1 = 1 ; } else if ( a [ i ] == max1 ) { count1 ++ ; } } int max2 = Integer . MIN_VALUE , count2 = 0 ; for ( int i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max2 ) { max2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max2 ) { count2 ++ ; } } return ( double ) ( count1 * count2 ) / ( size1 * size2 ) ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 3 } ; int b [ ] = { 1 , 3 , 3 } ; int size1 = a . length ; int size2 = b . length ; System . out . println ( probability ( a , b , size1 , size2 ) ) ; } }
import java . util . * ; import java . lang . * ; import java . util . Arrays ; public class GeeksforGeeks { public static int countDe ( int arr [ ] , int n ) { int v [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = arr [ i ] ; Arrays . sort ( arr ) ; int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; Collections . reverse ( Arrays . asList ( arr ) ) ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . min ( count1 , count2 ) ) ; } public static void main ( String argc [ ] ) { int arr [ ] = { 5 , 9 , 21 , 17 , 13 } ; int n = 5 ; System . out . println ( " Minimum ▁ Dearrangement ▁ = ▁ " + countDe ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int maxOfSegmentMins ( int [ ] a , int n , int k ) { if ( k == 1 ) { Arrays . sort ( a ) ; return a [ 0 ] ; } if ( k == 2 ) return Math . max ( a [ 0 ] , a [ n - 1 ] ) ; return a [ n - 1 ] ; } static public void main ( String [ ] args ) { int [ ] a = { - 10 , - 9 , - 8 , 2 , 7 , - 6 , - 5 } ; int n = a . length ; int k = 2 ; System . out . println ( maxOfSegmentMins ( a , n , k ) ) ; } }
import java . util . * ; class GFG { static int printMinimumProduct ( int arr [ ] , int n ) { int first_min = Math . min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = Math . max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; } public static void main ( String [ ] args ) { int a [ ] = { 11 , 8 , 5 , 7 , 5 , 100 } ; int n = a . length ; System . out . print ( printMinimumProduct ( a , n ) ) ; } }
import java . util . Arrays ; class GFG { static long noOfTriples ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; long count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; } public static void main ( String arg [ ] ) { long arr [ ] = { 1 , 3 , 3 , 4 } ; int n = arr . length ; System . out . print ( noOfTriples ( arr , n ) ) ; } }
import java . util . Arrays ; class GFG { static boolean checkReverse ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } Arrays . sort ( temp ) ; int front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } int back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } while ( front != back ) ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 5 , 4 , 3 } ; int n = arr . length ; if ( checkReverse ( arr , n ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
class GFG { static boolean checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) { return true ; } int i ; for ( i = 1 ; arr [ i - 1 ] < arr [ i ] && i < n ; i ++ ) ; if ( i == n ) { return true ; } int j = i ; while ( j < n && arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) { return false ; } j ++ ; } if ( j == n ) { return true ; } int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) { return false ; } while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 10 , 9 , 8 } ; int n = arr . length ; if ( checkReverse ( arr , n ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
import java . util . Arrays ; import java . io . * ; class GFG { static int MinOperation ( int a [ ] , int b [ ] , int n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 1 , 1 } ; int b [ ] = { 1 , 2 , 2 } ; int n = a . length ; System . out . println ( MinOperation ( a , b , n ) ) ; } }
import java . util . Arrays ; import java . io . * ; public class GFG { public static void sortExceptUandL ( int a [ ] , int l , int u , int n ) { int b [ ] = new int [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; Arrays . sort ( b ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; } public static void main ( String args [ ] ) { int a [ ] = { 5 , 4 , 3 , 12 , 14 , 9 } ; int n = a . length ; int l = 2 , u = 4 ; sortExceptUandL ( a , l , u , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } }
import java . util . Arrays ; class GFG { static int sortExceptK ( int arr [ ] , int k , int n ) { int temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; Arrays . sort ( arr , 0 , n - 1 ) ; int last = arr [ n - 1 ] ; for ( int i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; return 0 ; } public static void main ( String [ ] args ) { int a [ ] = { 10 , 4 , 11 , 7 , 6 , 20 } ; int k = 2 ; int n = a . length ; sortExceptK ( a , k , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } }
import java . io . * ; class GFG { static int maxPartitions ( int arr [ ] , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 2 , 3 , 4 } ; int n = arr . length ; System . out . println ( maxPartitions ( arr , n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { public static void cuttringRopes ( int Ropes [ ] , int n ) { Arrays . sort ( Ropes ) ; int singleOperation = 0 ; int cuttingLenght = Ropes [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( Ropes [ i ] - cuttingLenght > 0 ) { System . out . print ( n - i + " ▁ " ) ; cuttingLenght = Ropes [ i ] ; singleOperation ++ ; } } if ( singleOperation == 0 ) System . out . print ( "0" ) ; } public static void main ( String [ ] arg ) { int [ ] Ropes = { 5 , 1 , 1 , 2 , 3 , 5 } ; int n = Ropes . length ; cuttringRopes ( Ropes , n ) ; } }
public class GfG { public static void rankify ( int A [ ] , int n ) { float R [ ] = new float [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int r = 1 , s = 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i && A [ j ] < A [ i ] ) r += 1 ; if ( j != i && A [ j ] == A [ i ] ) s += 1 ; } R [ i ] = r + ( float ) ( s - 1 ) / ( float ) 2 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( R [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int A [ ] = { 1 , 2 , 5 , 2 , 1 , 25 , 2 } ; int n = A . length ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; System . out . println ( ) ; rankify ( A , n ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; } public static void main ( String argc [ ] ) { int arr = { 1 , 1 , 2 , 3 } ; int N = 4 ; int k = 5 ; System . out . println ( min_noOf_operation ( arr , N , k ) ) ; } }
import java . util . * ; class GFG { static int maxSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 6 , 1 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int countPairs ( int a [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 10 , 4 , 2 } ; int k = 3 ; int n = a . length ; System . out . println ( countPairs ( a , n , k ) ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int countPairs ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 10 , 4 , 2 } ; int k = 3 ; int n = a . length ; System . out . println ( countPairs ( a , n , k ) ) ; } }
import java . * ; import java . util . Arrays ; public class GFG { static int sumOfMinAbsDifferences ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; sum += Math . abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += Math . min ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 10 , 1 , 4 , 8 , 7 } ; int n = arr . length ; System . out . println ( " Sum ▁ = ▁ " + sumOfMinAbsDifferences ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int a = 0 , b = 0 ; int result = Integer . MAX_VALUE ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 11 , 5 } ; int B [ ] = { 4 , 12 , 19 , 23 , 127 , 235 } ; int m = A . length ; int n = B . length ; System . out . println ( findSmallestDifference ( A , B , m , n ) ) ; } }
import java . util . * ; class Gfg { static void findLarger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 6 , 1 , 0 , 9 } ; int n = arr . length ; findLarger ( arr , n ) ; } }
import java . util . * ; import java . util . Arrays ; class GFG { public static List < Integer > findDisappearedNumbers ( int [ ] nums ) { for ( int i = 0 ; i < nums . length ; i ++ ) { int index = Math . abs ( nums [ i ] ) ; if ( nums [ index - 1 ] > 0 ) { nums [ index - 1 ] *= - 1 ; } } List < Integer > res = new ArrayList < > ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] > 0 ) { res . add ( i + 1 ) ; } } return res ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 2 , 4 , 5 , 6 } ; System . out . println ( findDisappearedNumbers ( a ) ) ; } }
class Main { static int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 } ; int n = arr . length ; int x = 2 ; System . out . println ( countOccurrences ( arr , n , x ) ) ; } }
class GFG { static int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return - 1 ; int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } static int countOccurrences ( int arr [ ] , int n , int x ) { int ind = binarySearch ( arr , 0 , n - 1 , x ) ; if ( ind == - 1 ) return 0 ; int count = 1 ; int left = ind - 1 ; while ( left >= 0 && arr [ left ] == x ) { count ++ ; left -- ; } int right = ind + 1 ; while ( right < n && arr [ right ] == x ) { count ++ ; right ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 } ; int n = arr . length ; int x = 2 ; System . out . print ( countOccurrences ( arr , n , x ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . Math ; class CloseSum { static void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_l ] + " ▁ and ▁ " + arr [ res_r ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 22 , 28 , 29 , 30 , 40 } , x = 54 ; int n = arr . length ; printClosest ( arr , n , x ) ; } }
class CountOnes { int countOnes ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; } public static void main ( String args [ ] ) { CountOnes ob = new CountOnes ( ) ; int arr [ ] = { 1 , 1 , 1 , 1 , 0 , 0 , 0 } ; int n = arr . length ; System . out . println ( " Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ array ▁ is ▁ " + ob . countOnes ( arr , 0 , n - 1 ) ) ; } }
import java . io . * ; class MissingNumber { int findMissingUtil ( int arr1 [ ] , int arr2 [ ] , int N ) { if ( N == 1 ) return arr1 [ 0 ] ; if ( arr1 [ 0 ] != arr2 [ 0 ] ) return arr1 [ 0 ] ; int lo = 0 , hi = N - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( arr1 [ mid ] == arr2 [ mid ] ) lo = mid ; else hi = mid ; if ( lo == hi - 1 ) break ; } return arr1 [ hi ] ; } void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( N == M - 1 ) System . out . println ( " Missing ▁ Element ▁ is ▁ " + findMissingUtil ( arr1 , arr2 , M ) + "NEW_LINE"); else if ( M == N - 1 ) System . out . println ( " Missing ▁ Element ▁ is ▁ " + findMissingUtil ( arr2 , arr1 , N ) + "NEW_LINE"); else System . out . println ( " Invalid ▁ Input " ) ; } public static void main ( String args [ ] ) { MissingNumber obj = new MissingNumber ( ) ; int arr1 [ ] = { 1 , 4 , 5 , 7 , 9 } ; int arr2 [ ] = { 4 , 5 , 7 , 9 } ; int M = arr1 . length ; int N = arr2 . length ; obj . findMissing ( arr1 , arr2 , M , N ) ; } }
import java . io . * ; class Missing { void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { System . out . println ( " Invalid ▁ Input " ) ; return ; } int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; System . out . println ( " Missing ▁ element ▁ is ▁ " + res ) ; } public static void main ( String args [ ] ) { Missing obj = new Missing ( ) ; int arr1 [ ] = { 4 , 1 , 5 , 9 , 7 } ; int arr2 [ ] = { 7 , 5 , 9 , 4 } ; int M = arr1 . length ; int N = arr2 . length ; obj . findMissing ( arr1 , arr2 , M , N ) ; } }
import java . io . * ; class GFG { static void printTwoElements ( int arr [ ] , int size ) { int i ; System . out . print ( " The ▁ repeating ▁ element ▁ is ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { int abs_val = Math . abs ( arr [ i ] ) ; if ( arr [ abs_val - 1 ] > 0 ) arr [ abs_val - 1 ] = - arr [ abs_val - 1 ] ; else System . out . println ( abs_val ) ; } System . out . print ( " And ▁ the ▁ missing ▁ element ▁ is ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) System . out . println ( i + 1 ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = arr . length ; printTwoElements ( arr , n ) ; } }
import java . io . * ; class GFG { static int x , y ; static void getTwoElements ( int arr [ ] , int n ) { int xor1 ; int set_bit_no ; int i ; x = 0 ; y = 0 ; xor1 = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) xor1 = xor1 ^ arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor1 = xor1 ^ i ; set_bit_no = xor1 & ~ ( xor1 - 1 ) ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( ( i & set_bit_no ) != 0 ) x = x ^ i ; else y = y ^ i ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 5 , 1 , 6 , 2 } ; int n = arr . length ; getTwoElements ( arr , n ) ; System . out . println ( " ▁ The ▁ missing ▁ element ▁ is ▁ " + x + " and ▁ the ▁ " + " repeating ▁ number ▁ is ▁ " + y ) ; } }
class FindFourElements { void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) { if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) System . out . print ( A [ i ] + " ▁ " + A [ j ] + " ▁ " + A [ k ] + " ▁ " + A [ l ] ) ; } } } } } public static void main ( String [ ] args ) { FindFourElements findfour = new FindFourElements ( ) ; int A [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = A . length ; int X = 91 ; findfour . findFourElements ( A , n , X ) ; } }
import java . io . * ; class GFG { static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } System . out . println ( " number ▁ is ▁ not " + " ▁ present ! " ) ; return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 } ; int n = arr . length ; int x = 3 ; System . out . println ( " Element ▁ " + x + " ▁ is ▁ present ▁ at ▁ index ▁ " + search ( arr , n , 3 ) ) ; } }
class GFG { static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; System . out . printf ( " The ▁ third ▁ Largest ▁ " + "element is %dNEW_LINE", third); } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 16 } ; int n = arr . length ; thirdLargest ( arr , n ) ; } }
class GFG { static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] , second = Integer . MIN_VALUE , third = Integer . MIN_VALUE ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) { third = arr [ i ] ; } } System . out . printf ( "The third Largest element is %dNEW_LINE", third); } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 16 } ; int n = arr . length ; thirdLargest ( arr , n ) ; } }
import java . util . * ; class GFG { static boolean checkPair ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % 2 != 0 ) { return false ; } sum = sum / 2 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ; if ( s . contains ( val ) && val == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { System . out . printf ( "Pair elements are %d and %dNEW_LINE", arr[i], val); return true ; } s . add ( arr [ i ] ) ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 11 , 5 , 1 , 4 , 7 } ; int n = arr . length ; if ( checkPair ( arr , n ) == false ) { System . out . printf ( " No ▁ pair ▁ found " ) ; } } }
import java . io . * ; class GFG { static String search ( int arr [ ] , int n , int x ) { if ( arr [ n - 1 ] == x ) return " Found " ; int backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( int i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " Found " ; return " Not ▁ Found " ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 6 , 1 , 5 , 8 } ; int n = arr . length ; int x = 1 ; System . out . println ( search ( arr , n , x ) ) ; } }
public class Test { public static int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ; System . out . println ( findMajority ( arr , n ) ) ; } }
class GFG { static void minAdjDifference ( int arr [ ] , int n ) { if ( n < 2 ) return ; int res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; System . out . print ( " Min ▁ Difference ▁ = ▁ " + res ) ; } public static void main ( String arg [ ] ) { int a [ ] = { 10 , 12 , 13 , 15 , 10 } ; int n = a . length ; minAdjDifference ( a , n ) ; } }
import java . util . * ; public class GFG { static void Print3Smallest ( int array [ ] , int n ) { int firstmin = Integer . MAX_VALUE ; int secmin = Integer . MAX_VALUE ; int thirdmin = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] < firstmin ) { thirdmin = secmin ; secmin = firstmin ; firstmin = array [ i ] ; } else if ( array [ i ] < secmin ) { thirdmin = secmin ; secmin = array [ i ] ; } else if ( array [ i ] < thirdmin ) thirdmin = array [ i ] ; } System . out . println ( " First ▁ min ▁ = ▁ " + firstmin ) ; System . out . println ( " Second ▁ min ▁ = ▁ " + secmin ) ; System . out . println ( " Third ▁ min ▁ = ▁ " + thirdmin ) ; } public static void main ( String [ ] args ) { int array [ ] = { 4 , 9 , 1 , 32 , 12 } ; int n = array . length ; Print3Smallest ( array , n ) ; } }
import java . util . Arrays ; import java . util . Arrays ; class GFG { static int getMin ( int arr [ ] , int n ) { return Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; } static int getMax ( int arr [ ] , int n ) { return Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 1234 , 45 , 67 , 1 } ; int n = arr . length ; System . out . println ( " Minimum ▁ element ▁ of ▁ array : ▁ " + getMin ( arr , n ) ) ; System . out . println ( " Maximum ▁ element ▁ of ▁ array : ▁ " + getMax ( arr , n ) ) ; } }
class CountFrequency { void printfrequency ( int arr [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) arr [ j ] = arr [ j ] - 1 ; for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % n ] = arr [ arr [ i ] % n ] + n ; for ( int i = 0 ; i < n ; i ++ ) System . out . println ( i + 1 + " - > " + arr [ i ] / n ) ; } public static void main ( String [ ] args ) { CountFrequency count = new CountFrequency ( ) ; int arr [ ] = { 2 , 3 , 3 , 2 , 5 } ; int n = arr . length ; count . printfrequency ( arr , n ) ; } }
class Inversion { int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; } public static void main ( String args [ ] ) { Inversion inversion = new Inversion ( ) ; int arr [ ] = new int [ ] { 8 , 4 , 2 , 1 } ; int n = arr . length ; System . out . print ( " Inversion ▁ count ▁ : ▁ " + inversion . getInvCount ( arr , n ) ) ; } }
class Test { static int arr [ ] = new int [ ] { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; static int findWater ( int n ) { int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; int water = 0 ; left [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) left [ i ] = Math . max ( left [ i - 1 ] , arr [ i ] ) ; right [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) right [ i ] = Math . max ( right [ i + 1 ] , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) water += Math . min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; } public static void main ( String [ ] args ) { System . out . println ( " Maximum ▁ water ▁ that ▁ can ▁ be ▁ accumulated ▁ is ▁ " + findWater ( arr . length ) ) ; } }
import java . util . * ; class GFG { static int findWater ( int arr [ ] , int n ) { int result = 0 ; int left_max = 0 , right_max = 0 ; int lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; int n = arr . length ; System . out . println ( " Maximum ▁ water ▁ that ▁ " + " can ▁ be ▁ accumulated ▁ is ▁ " + findWater ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int [ ] a = new int [ ] { 900 } ; static int [ ] b = new int [ ] { 10 , 13 , 14 } ; static int maximum ( int a , int b ) { return a > b ? a : b ; } static int minimum ( int a , int b ) { return a < b ? a : b ; } static double findMedianSortedArrays ( int n , int m ) { int min_index = 0 , max_index = n , i = 0 , j = 0 , median = 0 ; while ( min_index <= max_index ) { i = ( min_index + max_index ) / 2 ; j = ( ( n + m + 1 ) / 2 ) - i ; if ( i < n && j > 0 && b [ j - 1 ] > a [ i ] ) min_index = i + 1 ; else if ( i > 0 && j < m && b [ j ] < a [ i - 1 ] ) max_index = i - 1 ; else { if ( i == 0 ) median = b [ j - 1 ] ; else if ( j == 0 ) median = a [ i - 1 ] ; else median = maximum ( a [ i - 1 ] , b [ j - 1 ] ) ; break ; } } if ( ( n + m ) % 2 == 1 ) return ( double ) median ; if ( i == n ) return ( median + b [ j ] ) / 2.0 ; if ( j == m ) return ( median + a [ i ] ) / 2.0 ; return ( median + minimum ( a [ i ] , b [ j ] ) ) / 2.0 ; } public static void main ( String args [ ] ) { int n = a . length ; int m = b . length ; if ( n < m ) System . out . print ( " The ▁ median ▁ is ▁ : ▁ " + findMedianSortedArrays ( n , m ) ) ; else System . out . print ( " The ▁ median ▁ is ▁ : ▁ " + findMedianSortedArrays ( m , n ) ) ; } }
import java . io . * ; class GFG { static void printUncommon ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) { if ( arr1 [ i ] < arr2 [ j ] ) { System . out . print ( arr1 [ i ] + " ▁ " ) ; i ++ ; k ++ ; } else if ( arr2 [ j ] < arr1 [ i ] ) { System . out . print ( arr2 [ j ] + " ▁ " ) ; k ++ ; j ++ ; } else { i ++ ; j ++ ; } } while ( i < n1 ) { System . out . print ( arr1 [ i ] + " ▁ " ) ; i ++ ; k ++ ; } while ( j < n2 ) { System . out . print ( arr2 [ j ] + " ▁ " ) ; j ++ ; k ++ ; } } public static void main ( String [ ] args ) { int arr1 [ ] = { 10 , 20 , 30 } ; int arr2 [ ] = { 20 , 25 , 30 , 40 , 50 } ; int n1 = arr1 . length ; int n2 = arr2 . length ; printUncommon ( arr1 , arr2 , n1 , n2 ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int leastFrequent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int min_count = n + 1 , res = - 1 ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ n - 1 ] ; } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 } ; int n = arr . length ; System . out . print ( leastFrequent ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int M = 4 ; static int arr [ ] [ ] = { { 1 , 7 , 3 , 4 } , { 4 , 2 , 5 , 1 } , { 9 , 5 , 1 , 8 } } ; static void sort ( int a [ ] [ ] , int row , int n ) { for ( int i = 0 ; i < M - 1 ; i ++ ) { if ( a [ row ] [ i ] > a [ row ] [ i + 1 ] ) { int temp = a [ row ] [ i ] ; a [ row ] [ i ] = a [ row ] [ i + 1 ] ; a [ row ] [ i + 1 ] = temp ; } } } static int maximumSum ( int a [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( a , i , n ) ; int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; int i , j ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == - 1 ) return 0 ; } return sum ; } public static void main ( String args [ ] ) { int n = arr . length ; System . out . print ( maximumSum ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int countPairs ( int A [ ] , int n , int k ) { int ans = 0 ; Arrays . sort ( A ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = 0 ; while ( ( A [ i ] * Math . pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 8 , 9 , 12 , 18 , 4 , 24 , 2 , 6 } ; int n = A . length ; int k = 3 ; System . out . println ( countPairs ( A , n , k ) ) ; } }
class GFG { static int minDistance ( int arr [ ] , int n ) { int maximum_element = arr [ 0 ] ; int min_dis = n ; int index = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( maximum_element == arr [ i ] ) { min_dis = Math . min ( min_dis , ( i - index ) ) ; index = i ; } else if ( maximum_element < arr [ i ] ) { maximum_element = arr [ i ] ; min_dis = n ; index = i ; } else continue ; } return min_dis ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 3 , 1 , 3 , 6 , 4 , 6 } ; int n = arr . length ; System . out . print ( " Minimum ▁ distance ▁ = ▁ " + minDistance ( arr , n ) ) ; } }
class GFG { static int findValue ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 10 , 8 , 1 } , k = 2 ; int n = arr . length ; System . out . print ( findValue ( arr , n , k ) ) ; } }
import java . io . * ; class GFG { static void dupLastIndex ( int arr [ ] , int n ) { if ( arr == null n <= 0 ) return ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { System . out . println ( " Last ▁ index : " + i ) ; System . out . println ( " Last ▁ duplicate ▁ item : ▁ " + arr [ i ] ) ; return ; } } System . out . print ( " no ▁ duplicate ▁ found " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 5 , 6 , 6 , 7 , 9 } ; int n = arr . length ; dupLastIndex ( arr , n ) ; } }
import java . io . * ; class GFG { static int findSmallest ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; } public static void main ( String args [ ] ) { int a [ ] = { 25 , 20 , 5 , 10 , 100 } ; int n = a . length ; System . out . println ( findSmallest ( a , n ) ) ; } }
import java . io . * ; class GFG { static int min_element ( int a [ ] ) { int min = Integer . MAX_VALUE , i ; for ( i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return min ; } static int findSmallest ( int a [ ] , int n ) { int smallest = min_element ( a ) ; for ( int i = 1 ; i < n ; i ++ ) if ( a [ i ] % smallest >= 1 ) return - 1 ; return smallest ; } public static void main ( String args [ ] ) { int a [ ] = { 25 , 20 , 5 , 10 , 100 } ; int n = a . length ; System . out . println ( findSmallest ( a , n ) ) ; } }
import java . util . * ; import java . lang . * ; class GfG { public static int findIndex ( int [ ] arr ) { int maxIndex = 0 ; for ( int i = 0 ; i < arr . length ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( int i = 0 ; i < arr . length ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return - 1 ; return maxIndex ; } public static void main ( String argc [ ] ) { int [ ] arr = new int [ ] { 3 , 6 , 1 , 0 } ; System . out . println ( findIndex ( arr ) ) ; } }
import java . io . * ; class GFG { static int find_consecutive_steps ( int arr [ ] , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . max ( maximum , count ) ; count = 0 ; } } return Math . max ( maximum , count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int len = arr . length ; System . out . println ( find_consecutive_steps ( arr , len ) ) ; } }
import java . util . Arrays ; import java . io . * ; class GFG { static int CalculateMax ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . abs ( max_sum - min_sum ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 7 , 1 , 11 } ; int n = arr . length ; System . out . println ( CalculateMax ( arr , n ) ) ; } }
import java . util . Arrays ; import java . util . Collections ; import java . util . Vector ; class GFG { static long calculate ( long a [ ] , int n ) { Arrays . sort ( a ) ; int i , j ; Vector < Long > s = new Vector < > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . add ( ( a [ i ] + a [ j ] ) ) ; long mini = Collections . min ( s ) ; long maxi = Collections . max ( s ) ; return Math . abs ( maxi - mini ) ; } public static void main ( String [ ] args ) { long a [ ] = { 2 , 6 , 4 , 3 } ; int n = a . length ; System . out . println ( calculate ( a , n ) ) ; } }
import java . util . * ; class GFG { static void printMinDiffPairs ( int arr [ ] , int n ) { if ( n <= 1 ) return ; Arrays . sort ( arr ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = Math . min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { System . out . print ( " ( " + arr [ i - 1 ] + " , ▁ " + arr [ i ] + " ) , " ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 2 , 4 , 1 } ; int n = arr . length ; printMinDiffPairs ( arr , n ) ; } }
public class MaximumAbsoluteDifference { private static int calculateDiff ( int i , int j , int [ ] array ) { return Math . abs ( array [ i ] - array [ j ] ) + Math . abs ( i - j ) ; } private static int maxDistance ( int [ ] array ) { int result = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { for ( int j = i ; j < array . length ; j ++ ) { result = Math . max ( result , calculateDiff ( i , j , array ) ) ; } } return result ; } public static void main ( String [ ] args ) { int [ ] array = { - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 } ; System . out . println ( maxDistance ( array ) ) ; } }
public class MaximumAbsoluteDifference { private static int maxDistance ( int [ ] array ) { int max1 = Integer . MIN_VALUE ; int min1 = Integer . MAX_VALUE ; int max2 = Integer . MIN_VALUE ; int min2 = Integer . MAX_VALUE ; for ( int i = 0 ; i < array . length ; i ++ ) { max1 = Math . max ( max1 , array [ i ] + i ) ; min1 = Math . min ( min1 , array [ i ] + i ) ; max2 = Math . max ( max2 , array [ i ] - i ) ; min2 = Math . min ( min2 , array [ i ] - i ) ; } return Math . max ( max1 - min1 , max2 - min2 ) ; } public static void main ( String [ ] args ) { int [ ] array = { - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 } ; System . out . println ( maxDistance ( array ) ) ; } }
import java . io . * ; class GFG { static int extrema ( int a [ ] , int n ) { int count = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; } public static void main ( String args [ ] ) throws IOException { int a [ ] = { 1 , 0 , 2 , 1 } ; int n = a . length ; System . out . println ( extrema ( a , n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class FindClosestNumber { public static int findClosest ( int arr [ ] , int target ) { int n = arr . length ; if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } public static int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 } ; int target = 11 ; System . out . println ( findClosest ( arr , target ) ) ; } }
class GFG { static int sum ( int a [ ] , int n ) { int maxSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) maxSum = Math . max ( maxSum , a [ i ] + a [ j ] ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; } public static void main ( String [ ] args ) { int array [ ] = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = array . length ; System . out . println ( sum ( array , n ) ) ; } }
import java . io . * ; class GFG { static int sum ( int a [ ] , int n ) { int maxVal = a [ 0 ] , maxCount = 1 ; int secondMax = Integer . MIN_VALUE , secondMaxCount = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == maxVal ) maxCount ++ ; else if ( a [ i ] > maxVal ) { secondMax = maxVal ; secondMaxCount = maxCount ; maxVal = a [ i ] ; maxCount = 1 ; } else if ( a [ i ] == secondMax ) { secondMax = a [ i ] ; secondMaxCount ++ ; } else if ( a [ i ] > secondMax ) { secondMax = a [ i ] ; secondMaxCount = 1 ; } } if ( maxCount > 1 ) return maxCount * ( maxCount - 1 ) / 2 ; return secondMaxCount ; } public static void main ( String [ ] args ) { int array [ ] = { 1 , 1 , 1 , 2 , 2 , 2 , 3 } ; int n = array . length ; System . out . println ( sum ( array , n ) ) ; } }
import java . util . Arrays ; class GFG { static void printKMissing ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ; int count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { System . out . print ( curr + " ▁ " ) ; count ++ ; } else i ++ ; curr ++ ; } while ( count < k ) { System . out . print ( curr + " ▁ " ) ; curr ++ ; count ++ ; } } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 } ; int n = arr . length ; int k = 3 ; printKMissing ( arr , n , k ) ; } }
import java . util . ArrayList ; class GFG { public static int nobleInteger ( int arr [ ] ) { int size = arr . length ; for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; } public static void main ( String args [ ] ) { int [ ] arr = { 10 , 3 , 20 , 40 , 2 } ; int res = nobleInteger ( arr ) ; if ( res != - 1 ) System . out . println ( " The ▁ noble ▁ " + " integer ▁ is ▁ " + res ) ; else System . out . println ( " No ▁ Noble ▁ " + " Integer ▁ Found " ) ; } }
import java . util . Arrays ; public class Main { public static int nobleInteger ( int arr [ ] ) { Arrays . sort ( arr ) ; int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; } public static void main ( String args [ ] ) { int [ ] arr = { 10 , 3 , 20 , 40 , 2 } ; int res = nobleInteger ( arr ) ; if ( res != - 1 ) System . out . println ( " The ▁ noble ▁ integer ▁ is ▁ " + res ) ; else System . out . println ( " No ▁ Noble ▁ Integer ▁ Found " ) ; } }
import java . util . Arrays ; class MinSum { static long findMinSum ( long a [ ] , long b [ ] , long n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; } public static void main ( String [ ] args ) { long a [ ] = { 4 , 1 , 8 , 7 } ; long b [ ] = { 2 , 3 , 6 , 5 } ; int n = a . length ; System . out . println ( findMinSum ( a , b , n ) ) ; } }
class GFG { static int minProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int negmax = Integer . MIN_VALUE ; int posmin = Integer . MAX_VALUE ; int count_neg = 0 , count_zero = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; negmax = Math . max ( negmax , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < posmin ) posmin = a [ i ] ; product *= a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return posmin ; if ( count_neg % 2 == 0 && count_neg != 0 ) { product = product / negmax ; } return product ; } public static void main ( String [ ] args ) { int a [ ] = { - 1 , - 1 , - 2 , 4 , 3 } ; int n = 5 ; System . out . println ( minProductSubset ( a , n ) ) ; } }
import java . util . Arrays ; public class Test4 { static int findElement ( int a [ ] , int n , int b ) { Arrays . sort ( a ) ; int max = a [ n - 1 ] ; while ( b < max ) { if ( Arrays . binarySearch ( a , b ) > - 1 ) b *= 2 ; else return b ; } return b ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; int b = 1 ; System . out . println ( findElement ( a , n , b ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int Mod = 1000000007 ; static long findSum ( int arr [ ] , int n ) { long sum = 0 ; Arrays . sort ( arr ) ; int i = 0 ; while ( i < n && arr [ i ] < 0 ) { if ( i != n - 1 && arr [ i + 1 ] <= 0 ) { sum = ( sum + ( arr [ i ] * arr [ i + 1 ] ) % Mod ) % Mod ; i += 2 ; } else break ; } int j = n - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { if ( j != 0 && arr [ j - 1 ] > 0 ) { sum = ( sum + ( arr [ j ] * arr [ j - 1 ] ) % Mod ) % Mod ; j -= 2 ; } else break ; } if ( j > i ) sum = ( sum + ( arr [ i ] * arr [ j ] ) % Mod ) % Mod ; else if ( i == j ) sum = ( sum + arr [ i ] ) % Mod ; return sum ; } public static void main ( String args [ ] ) { int arr [ ] = { - 1 , 9 , 4 , 5 , - 4 , 7 } ; int n = arr . length ; System . out . println ( findSum ( arr , n ) ) ; } }
class Solution { static void countOddRotations ( int n ) { int odd_count = 0 , even_count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = n / 10 ; } while ( n != 0 ) ; System . out . println ( " Odd ▁ = ▁ " + odd_count ) ; System . out . println ( " Even ▁ = ▁ " + even_count ) ; } public static void main ( String [ ] args ) { int n = 1234 ; countOddRotations ( n ) ; } }
class GFG { static int numberOfDigits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; } static void cal ( int num ) { int digits = numberOfDigits ( num ) ; int powTen = ( int ) Math . pow ( 10 , digits - 1 ) ; for ( int i = 0 ; i < digits - 1 ; i ++ ) { int firstDigit = num / powTen ; int left = ( ( num * 10 ) + firstDigit ) - ( firstDigit * powTen * 10 ) ; System . out . print ( left + " ▁ " ) ; num = left ; } } public static void main ( String [ ] args ) { int num = 1445 ; cal ( num ) ; } }
class GFG { static void CheckKCycles ( int n , String s ) { boolean ff = true ; int x = 0 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( s . substring ( i ) + s . substring ( 0 , i ) ) . length ( ) ; if ( x >= s . length ( ) ) { continue ; } ff = false ; break ; } if ( ff ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { int n = 3 ; String s = "123" ; CheckKCycles ( n , s ) ; } }
public class GFG { static boolean rightRotationDivisor ( int N ) { int lastDigit = N % 10 ; int rightRotation = ( int ) ( lastDigit * Math . pow ( 10 , ( int ) ( Math . log10 ( N ) ) ) + Math . floor ( N / 10 ) ) ; return ( rightRotation % N == 0 ) ; } static void generateNumbers ( int m ) { for ( int i = ( int ) Math . pow ( 10 , ( m - 1 ) ) ; i < Math . pow ( 10 , m ) ; i ++ ) if ( rightRotationDivisor ( i ) ) System . out . println ( i ) ; } public static void main ( String args [ ] ) { int m = 3 ; generateNumbers ( m ) ; } }
import java . io . * ; class GFG { static void checkIfSortRotated ( int arr [ ] , int n ) { int minEle = Integer . MAX_VALUE ; int maxEle = Integer . MIN_VALUE ; int minIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } boolean flag1 = true ; for ( int i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = false ; break ; } } boolean flag2 = true ; for ( int i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag2 = false ; break ; } } if ( minIndex == 0 ) { System . out . print ( " NO " ) ; return ; } if ( flag1 && flag2 && ( arr [ n - 1 ] < arr [ 0 ] ) ) System . out . println ( " YES " ) ; else System . out . print ( " NO " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = arr . length ; checkIfSortRotated ( arr , n ) ; } }
import java . util . * ; class GFG { static void occurredOnce ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; if ( arr [ 0 ] != arr [ 1 ] ) System . out . println ( arr [ 0 ] + " ▁ " ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) System . out . print ( arr [ i ] + " ▁ " ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) System . out . print ( arr [ n - 1 ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 } ; int n = arr . length ; occurredOnce ( arr , n ) ; } }
class GFG { static void occurredOnce ( int arr [ ] , int n ) { int i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else System . out . print ( arr [ i - 1 ] + " ▁ " ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) System . out . print ( arr [ n - 1 ] ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 } ; int n = arr . length ; occurredOnce ( arr , n ) ; } }
class Geeks { static void rvereseArray ( int arr [ ] , int start , int end ) { while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } } static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void splitArr ( int arr [ ] , int k , int n ) { rvereseArray ( arr , 0 , n - 1 ) ; rvereseArray ( arr , 0 , n - k - 1 ) ; rvereseArray ( arr , n - k , n - 1 ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = arr . length ; int k = 2 ; splitArr ( arr , k , n ) ; printArray ( arr , n ) ; } }
import java . io . * ; class GFG { static int countRotationsDivBy8 ( String n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . charAt ( i + 1 ) - '0' ) * 10 + ( n . charAt ( i + 2 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; } public static void main ( String [ ] args ) { String n = "43262488612" ; System . out . println ( " Rotations : ▁ " + countRotationsDivBy8 ( n ) ) ; } }
class GFG { static boolean isRotation ( long x , long y ) { long x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; } public static void main ( String [ ] args ) { long x = 122 ; long y = 2147483678L ; if ( isRotation ( x , y ) == false ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . io . * ; class GFG { static int countRotations ( String n ) { int len = n . length ( ) ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n . charAt ( i ) - '0' ) * 10 + ( n . charAt ( i + 1 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; } public static void main ( String args [ ] ) { String n = "4834" ; System . out . println ( " Rotations : ▁ " + countRotations ( n ) ) ; } }
class GFG { static int maxLength ( int a [ ] , int n ) { int sum = 0 , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } { return n ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { len = Math . max ( len , Math . max ( n - i - 1 , i ) ) ; } } return len ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 2 } ; int n = a . length ; System . out . println ( maxLength ( a , n ) ) ; } }
class GFG { static void solve ( long n ) { long initial_array [ ] [ ] = new long [ ( int ) n - 1 ] [ ( int ) n - 1 ] , final_array [ ] [ ] = new long [ ( int ) n ] [ ( int ) n ] ; for ( long i = 0 ; i < n - 1 ; ++ i ) initial_array [ 0 ] [ ( int ) i ] = i + 1 ; for ( long i = 1 ; i < n - 1 ; ++ i ) for ( long j = 0 ; j < n - 1 ; ++ j ) initial_array [ ( int ) i ] [ ( int ) j ] = initial_array [ ( int ) i - 1 ] [ ( int ) ( ( int ) j + 1 ) % ( ( int ) n - 1 ) ] ; for ( long i = 0 ; i < n - 1 ; ++ i ) for ( long j = 0 ; j < n - 1 ; ++ j ) final_array [ ( int ) i ] [ ( int ) j ] = initial_array [ ( int ) i ] [ ( int ) j ] ; for ( long i = 0 ; i < n ; ++ i ) final_array [ ( int ) i ] [ ( int ) n - 1 ] = final_array [ ( int ) n - 1 ] [ ( int ) i ] = 0 ; for ( long i = 0 ; i < n ; ++ i ) { long t0 = final_array [ ( int ) i ] [ ( int ) i ] ; long t1 = final_array [ ( int ) i ] [ ( int ) n - 1 ] ; long s = final_array [ ( int ) i ] [ ( int ) i ] ; final_array [ ( int ) i ] [ ( int ) i ] = final_array [ ( int ) i ] [ ( int ) n - 1 ] ; final_array [ ( int ) i ] [ ( int ) n - 1 ] = s ; final_array [ ( int ) n - 1 ] [ ( int ) i ] = t0 ; } for ( long i = 0 ; i < n ; ++ i ) { for ( long j = 0 ; j < n ; ++ j ) System . out . print ( final_array [ ( int ) i ] [ ( int ) j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String args [ ] ) { long n = 5 ; solve ( n ) ; } }
import java . io . * ; class GFG { static int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return - 1 ; } public static void main ( String [ ] args ) { int p = 24 , q = 48 ; System . out . println ( getMinVal ( p , q ) ) ; } }
import java . util . Arrays ; class GfG { static boolean isPalindrome ( String str , int i , int j ) { while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; } static int countPrimePalindrome ( String str , int len ) { boolean [ ] prime = new boolean [ len + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= len ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i <= len ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int j = 2 ; j <= len ; j ++ ) { if ( prime [ j ] ) { for ( int i = 0 ; i + j - 1 < len ; i ++ ) { if ( isPalindrome ( str , i , i + j - 1 ) ) count ++ ; } } } return count ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; int len = s . length ( ) ; System . out . println ( countPrimePalindrome ( s , len ) ) ; } }
class GFG { static int minOperations ( int N ) { double x = Math . log ( N ) / Math . log ( 2 ) ; int ans = ( int ) ( Math . ceil ( x ) ) ; return ans ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( minOperations ( N ) ) ; } }
class GFG { static int find_greatest_divisor ( int l , int r ) { if ( l == r ) { return l ; } return 1 ; } public static void main ( String [ ] args ) { int l = 2 , r = 12 ; System . out . println ( find_greatest_divisor ( l , r ) ) ; } }
import java . io . * ; class GFG { static double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; } public static void main ( String [ ] args ) { double p , q ; p = 80 ; q = 40 ; System . out . println ( getProbability ( p , q ) ) ; } }
class GFG { static boolean check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { return true ; } } return false ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 9 , 12 , 13 , 15 } ; int n = arr . length ; if ( check ( arr , n ) ) { System . out . println ( " Odd ▁ Bit - wise ▁ OR " ) ; } else { System . out . println ( " Even ▁ Bit - wise ▁ OR " ) ; } } }
import java . io . * ; class GFG { static int _log ( double x , double base ) { return ( int ) ( Math . log ( x ) / Math . log ( base ) ) ; } static double recursiveLogStar ( double n , double b ) { if ( n > 1.0 ) return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) ; else return 0 ; } public static void main ( String [ ] args ) { int n = 100 , base = 5 ; System . out . println ( " Log * ( " + n + " ) ▁ = ▁ " + recursiveLogStar ( n , base ) ) ; } }
import java . util . Arrays ; class GFG { static boolean isPossible ( int box [ ] , int truck [ ] , int n , int m , int min_time ) { int temp = 0 ; int count = 0 ; while ( count < m ) { for ( int j = 0 ; j < min_time && temp < n && truck [ count ] >= box [ temp ] ; j += 2 ) temp ++ ; count ++ ; } if ( temp == n ) return true ; return false ; } static int minTime ( int box [ ] , int truck [ ] , int n , int m ) { Arrays . sort ( box ) ; Arrays . sort ( truck ) ; int l = 0 ; int h = 2 * n ; int min_time = 0 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( isPossible ( box , truck , n , m , mid ) ) { min_time = mid ; h = mid - 1 ; } else l = mid + 1 ; } return min_time ; } public static void main ( String [ ] args ) { int box [ ] = { 10 , 2 , 16 , 19 } ; int truck [ ] = { 29 , 25 } ; int n = box . length ; int m = truck . length ; System . out . printf ( " % d " , minTime ( box , truck , n , m ) ) ; } }
class GFG { static boolean isPossible ( int arr [ ] , int n , int dist , int k ) { int req = 0 ; int curr = 0 ; int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) { curr ++ ; } req ++ ; if ( curr == n ) { break ; } prev = curr - 1 ; } if ( curr != n ) { return false ; } if ( req <= k ) { return true ; } return false ; } static int minDistance ( int arr [ ] , int n , int k ) { int l = 0 ; int h = arr [ n - 1 ] ; int ans = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( isPossible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else { l = m + 1 ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 15 , 36 , 43 } ; int n = arr . length ; int k = 2 ; System . out . println ( minDistance ( arr , n , k ) ) ; } }
class GFG { static int getKthElement ( int n , int k , int L [ ] , int R [ ] ) { int l = 1 ; int h = n ; int total [ ] = new int [ n + 1 ] ; total [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total [ i + 1 ] = total [ i ] + ( R [ i ] - L [ i ] ) + 1 ; } int index = - 1 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( total [ m ] > k ) { index = m ; h = m - 1 ; } else if ( total [ m ] < k ) l = m + 1 ; else { index = m ; break ; } } l = L [ index - 1 ] ; h = R [ index - 1 ] ; int x = k - total [ index - 1 ] ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( m - L [ index - 1 ] ) + 1 == x ) { return m ; } else if ( ( m - L [ index - 1 ] ) + 1 > x ) h = m - 1 ; else l = m + 1 ; } return k ; } public static void main ( String [ ] args ) { int L [ ] = { 1 , 8 , 21 } ; int R [ ] = { 4 , 10 , 23 } ; int n = L . length ; int k = 6 ; System . out . println ( getKthElement ( n , k , L , R ) ) ; } }
class GFG { static int MinimumX ( int a , int b , int c , int k ) { int x = Integer . MAX_VALUE ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; } public static void main ( String [ ] args ) { int a = 3 , b = 2 , c = 4 , k = 15 ; System . out . println ( MinimumX ( a , b , c , k ) ) ; } }
import java . util . * ; class GFG { static void IfExists ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; Arrays . sort ( arr ) ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ; int max = arr [ n - 1 ] ; boolean flag = false ; for ( int i = 1 ; i <= max ; i ++ ) { int findex = 0 ; int lindex = 0 ; int l = 0 ; int r = n - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < i ) { findex = m ; l = m + 1 ; } else r = m - 1 ; } l = 1 ; r = n ; flag = false ; while ( l <= r ) { int m = ( r + l ) / 2 ; if ( arr [ m ] > i ) { lindex = m ; r = m - 1 ; } else l = m + 1 ; } if ( sum [ findex ] == sum [ n - 1 ] - sum [ lindex - 1 ] ) { flag = true ; break ; } } if ( flag ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 2 , 5 } ; int n = arr . length ; IfExists ( arr , n ) ; } }
class GFG { public static int findMissing ( int arr [ ] , int n ) { int l = 0 , h = n - 1 ; int mid ; while ( h > l ) { mid = l + ( h - l ) / 2 ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { - 9 , - 8 , - 7 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 } ; int n = arr . length ; System . out . print ( findMissing ( arr , n ) ) ; } }
class GFG { static int maxSum ( int arr [ ] , int n , int K ) { int maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int sumk = 0 ; for ( int j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . max ( maximum , sumk ) ; } return maximum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 6 , 4 , 7 , 2 } ; int n = arr . length ; int K = 2 ; System . out . println ( maxSum ( arr , n , K ) ) ; } }
class GFG { static int countGreater ( int arr [ ] , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 } ; int n = arr . length ; int k = 7 ; System . out . println ( countGreater ( arr , n , k ) ) ; } }
class GFG { static int operations ( int op [ ] , int n , int k ) { int i , count = 0 ; int nVal = 0 ; int min = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; min = Math . min ( min , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return - 1 ; int times = ( k - Math . abs ( min ) ) / Math . abs ( nVal ) ; k = ( k - ( times * Math . abs ( nVal ) ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; } public static void main ( String [ ] args ) { int op [ ] = { - 60 , 65 , - 1 , 14 , - 25 } ; int n = op . length ; int k = 100000 ; System . out . print ( operations ( op , n , k ) ) ; } }
class GFG { static int countFactor ( int P , int X ) { if ( X < P ) return 0 ; return ( X / P + countFactor ( P , X / P ) ) ; } static int findSmallestX ( int Y ) { int low = 0 , high = 5 * Y ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( countFactor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; } public static void main ( String args [ ] ) { int Y = 10 ; System . out . println ( findSmallestX ( Y ) ) ; } }
class GFG { static long squareSum ( long N ) { long sum = ( long ) ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ; return sum ; } static long findMaxN ( long X ) { long low = 1 , high = 100000 ; int N = 0 ; while ( low <= high ) { long mid = ( high + low ) / 2 ; if ( squareSum ( mid ) <= X ) { N = ( int ) mid ; low = mid + 1 ; } else high = mid - 1 ; } return N ; } public static void main ( String [ ] args ) { long X = 25 ; System . out . println ( findMaxN ( X ) ) ; } }
class GFG { final static int n = 4 ; static int findRing ( int arr [ ] [ ] , int x ) { if ( arr [ 0 ] [ 0 ] > x ) return - 1 ; int l = 0 , r = ( n + 1 ) / 2 - 1 ; if ( n % 2 == 1 && arr [ r ] [ r ] < x ) return - 1 ; if ( n % 2 == 0 && arr [ r + 1 ] [ r ] < x ) return - 1 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] [ mid ] <= x ) if ( mid == ( n + 1 ) / 2 - 1 arr [ mid + 1 ] [ mid + 1 ] > x ) return mid ; else l = mid + 1 ; else r = mid - 1 ; } return r ; } static int binarySearchRowInc ( int arr [ ] [ ] , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) l = mid + 1 ; else r = mid - 1 ; } return - 1 ; } static int binarySearchColumnInc ( int arr [ ] [ ] , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) t = mid + 1 ; else b = mid - 1 ; } return - 1 ; } static int binarySearchRowDec ( int arr [ ] [ ] , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; } static int binarySearchColumnDec ( int arr [ ] [ ] , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) b = mid - 1 ; else t = mid + 1 ; } return - 1 ; } static void spiralBinary ( int arr [ ] [ ] , int x ) { int f1 = findRing ( arr , x ) ; int r , c ; if ( f1 == - 1 ) { System . out . print ( " - 1" ) ; return ; } if ( n % 2 == 1 && f1 == ( n + 1 ) / 2 - 1 ) { System . out . println ( f1 + " ▁ " + f1 ) ; return ; } if ( x < arr [ f1 ] [ n - f1 - 1 ] ) { c = binarySearchRowInc ( arr , f1 , f1 , n - f1 - 2 , x ) ; r = f1 ; } else if ( x < arr [ n - f1 - 1 ] [ n - f1 - 1 ] ) { c = n - f1 - 1 ; r = binarySearchColumnInc ( arr , n - f1 - 1 , f1 , n - f1 - 2 , x ) ; } else if ( x < arr [ n - f1 - 1 ] [ f1 ] ) { c = binarySearchRowDec ( arr , n - f1 - 1 , f1 + 1 , n - f1 - 1 , x ) ; r = n - f1 - 1 ; } else { r = binarySearchColumnDec ( arr , f1 , f1 + 1 , n - f1 - 1 , x ) ; c = f1 ; } if ( c == - 1 r == - 1 ) System . out . print ( " - 1" ) ; else System . out . print ( r + " ▁ " + c ) ; return ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 12 , 13 , 14 , 5 } , { 11 , 16 , 15 , 6 } , { 10 , 9 , 8 , 7 } } ; spiralBinary ( arr , 7 ) ; } }
import java . util . * ; class solution { static int countSubArrays ( int arr [ ] , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 4 , 5 } ; int n = arr . length ; int k = 6 ; System . out . println ( countSubArrays ( arr , n , k ) ) ; } }
import java . util . * ; class solution { static int countPattern ( int n , String pat ) { int pattern_int = 0 ; int power_two = 1 ; int all_ones = 0 ; for ( int i = pat . length ( ) - 1 ; i >= 0 ; i -- ) { int current_bit = pat . charAt ( i ) - '0' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } int count = 0 ; while ( n != 0 && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) { count ++ ; } n = n >> 1 ; } return count ; } public static void main ( String args [ ] ) { int n = 500 ; String pat = "10" ; System . out . println ( countPattern ( n , pat ) ) ; } }
import java . util . * ; class GFG { static int max_min ( int a [ ] , int n ) { Arrays . sort ( a ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 3 , 7 } ; int n = a . length ; System . out . println ( max_min ( a , n ) ) ; } }
public class GFG { static final int MAX = 1000001 ; static int primeUpto [ ] = new int [ MAX ] ; static void SieveOfEratosthenes ( ) { int isPrime [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) isPrime [ i ] = 1 ; isPrime [ 0 ] = isPrime [ 1 ] = 0 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] == 1 ) { for ( int j = i * 2 ; j < MAX ; j += i ) isPrime [ j ] = 0 ; } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] == 1 ) primeUpto [ i ] ++ ; } } static int countOfNumbers ( int N , int K ) { SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } ans = ans != 0 ? N - ans + 1 : 0 ; return ans ; } public static void main ( String [ ] args ) { int N = 10 , K = 3 ; System . out . println ( countOfNumbers ( N , K ) ) ; } }
import java . io . * ; class GFG { static int minIndex ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , - 5 , 3 , 4 } ; int n = arr . length ; System . out . print ( minIndex ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int N = 4 ; static int M = 4 ; static void printIntersection ( int A [ ] [ ] , int B [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] == B [ i ] [ j ] ) System . out . print ( A [ i ] [ j ] + " ▁ " ) ; else System . out . print ( " * ▁ " ) ; } System . out . println ( " ▁ " ) ; } } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 2 , 4 , 6 , 8 } , { 1 , 3 , 5 , 7 } , { 8 , 6 , 4 , 2 } , { 7 , 5 , 3 , 1 } } ; int B [ ] [ ] = { { 2 , 3 , 6 , 8 } , { 1 , 3 , 5 , 2 } , { 8 , 1 , 4 , 2 } , { 3 , 5 , 4 , 1 } } ; printIntersection ( A , B ) ; } }
class GFG { static int countWays ( int [ ] arr , int n ) { int max_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , arr [ i ] ) ; int [ ] freq = new int [ max_val + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; ans += freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) / 6 ; for ( int i = 1 ; i <= max_val ; i ++ ) ans += freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) / 2 ; for ( int i = 1 ; 2 * i <= max_val ; i ++ ) ans += freq [ i ] * ( freq [ i ] - 1 ) / 2 * freq [ 2 * i ] ; for ( int i = 1 ; i <= max_val ; i ++ ) { for ( int j = i + 1 ; i + j <= max_val ; j ++ ) ans += freq [ i ] * freq [ j ] * freq [ i + j ] ; } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( countWays ( arr , n ) ) ; } }
class GFG { static public int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . max ( max_length , count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 9 , 7 , 18 , 29 , 11 } ; int n = arr . length ; int k = 11 ; System . out . print ( LongestSubarray ( arr , n , k ) ) ; } }
public class GFG { static final int M = 3 ; static final int N = 4 ; static boolean binarySearch1D ( int arr [ ] , int K ) { int low = 0 ; int high = N - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == K ) { return true ; } if ( arr [ mid ] < K ) { low = mid + 1 ; } else { high = mid - 1 ; } } return false ; } static boolean searchMatrix ( int matrix [ ] [ ] , int K ) { int low = 0 ; int high = M - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( K >= matrix [ mid ] [ 0 ] && K <= matrix [ mid ] [ N - 1 ] ) { return binarySearch1D ( matrix [ mid ] , K ) ; } if ( K < matrix [ mid ] [ 0 ] ) { high = mid - 1 ; } else { low = mid + 1 ; } } return false ; } public static void main ( String args [ ] ) { int matrix [ ] [ ] = { { 1 , 3 , 5 , 7 } , { 10 , 11 , 16 , 20 } , { 23 , 30 , 34 , 50 } } ; int K = 3 ; if ( searchMatrix ( matrix , K ) ) { System . out . println ( " Found " ) ; } else { System . out . println ( " Not ▁ found " ) ; } } }
import java . util . * ; class Solution { static int numberOfElements ( int height [ ] , int n ) { int max_so_far = 0 ; int coun = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; } public static void main ( String args [ ] ) { int n = 6 ; int height [ ] = { 4 , 8 , 2 , 0 , 0 , 5 } ; System . out . println ( numberOfElements ( height , n ) ) ; } }
import java . util . Arrays ; public class GFG { static void solve ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; if ( k == 1 && arr [ n - 2 ] != arr [ n - 1 ] ) { System . out . println ( arr [ n - 1 ] ) ; return ; } int count = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) count ++ ; else count = 1 ; if ( count == k && ( i == 0 || ( arr [ i - 1 ] != arr [ i ] ) ) ) { System . out . println ( arr [ i ] ) ; return ; } } System . out . println ( " No ▁ such ▁ element " ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 6 , 6 } ; int k = 2 ; int n = arr . length ; solve ( arr , n , k ) ; } }
import java . io . * ; class GFG { static int getMin ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . min ( res , arr [ i ] ) ; return res ; } static int getMax ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; } static int findSum ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min + max ; } static int findProduct ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min * max ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 1234 , 45 , 67 , 1 } ; int n = arr . length ; System . out . println ( " Sum ▁ = ▁ " + findSum ( arr , n ) ) ; System . out . println ( " Product ▁ = ▁ " + findProduct ( arr , n ) ) ; } }
class GFG { static int countChar ( String str ) { int n = str . length ( ) ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( i + 1 ) ) count ++ ; return count ; } public static void main ( String [ ] args ) { String str = " egeeksk " ; System . out . println ( countChar ( str ) ) ; } }
class GfG { private static int next ( int [ ] arr , int target ) { int start = 0 , end = arr . length - 1 ; if ( end == 0 ) return - 1 ; if ( target > arr [ end ] ) return end ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] >= target ) { end = mid - 1 ; } else { ans = mid ; start = mid + 1 ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 5 , 8 , 12 } ; System . out . println ( next ( arr , 5 ) ) ; } }
class GfG { private static int next ( int [ ] arr , int target ) { int start = 0 , end = arr . length - 1 ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 5 , 8 , 12 } ; System . out . println ( next ( arr , 8 ) ) ; } }
import java . util . * ; class solution { static boolean search ( int [ ] arr , int n , int x ) { int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; } public static void main ( String args [ ] ) { int [ ] arr = { 12 , 25 , 36 , 85 , 98 , 75 , 89 , 15 , 63 , 66 , 64 , 74 , 27 , 83 , 97 } ; int [ ] q = { 63 , 63 , 86 , 63 , 78 } ; int n = arr . length ; int m = q . length ; for ( int i = 0 ; i < m ; i ++ ) { if ( search ( arr , n , q [ i ] ) == true ) System . out . print ( " Yes ▁ " ) ; else System . out . print ( " No ▁ " ) ; } } }
class GFG { static float kPresentProbability ( int a [ ] , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ; return count / n ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 7 , 2 , 0 , 8 , 7 , 5 } ; int K = 2 ; int N = A . length ; double n = kPresentProbability ( A , N , K ) ; double p = ( double ) Math . round ( n * 100 ) / 100 ; System . out . println ( p ) ; } }
import java . io . * ; class GFG { static int slopeOfNum ( String num , int n ) { int slope = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( num . charAt ( i ) > num . charAt ( i - 1 ) && num . charAt ( i ) > num . charAt ( i + 1 ) ) slope ++ ; else if ( num . charAt ( i ) < num . charAt ( i - 1 ) && num . charAt ( i ) < num . charAt ( i + 1 ) ) slope ++ ; } return slope ; } public static void main ( String [ ] args ) { String num = "1213321" ; int n = num . length ( ) ; System . out . println ( " Slope ▁ = ▁ " + slopeOfNum ( num , n ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static void prevGreater ( int arr [ ] , int n ) { System . out . print ( " - 1 , ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { System . out . print ( arr [ j ] + " , ▁ " ) ; break ; } } if ( j == - 1 ) System . out . print ( " - 1 , ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 4 , 2 , 20 , 40 , 12 , 30 } ; int n = arr . length ; prevGreater ( arr , n ) ; } }
import java . io . * ; class GFG { static void printDuplicates ( int arr [ ] , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { System . out . print ( arr [ i ] % n + " ▁ " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! ( fl > 0 ) ) System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 6 , 3 , 1 , 3 , 6 , 6 } ; int arr_size = arr . length ; printDuplicates ( arr , arr_size ) ; } }
import java . io . * ; class GFG { static int findMissingNo ( int [ ] arr , int n ) { int val ; int nextval ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= 0 arr [ i ] > n ) continue ; val = arr [ i ] ; while ( arr [ val - 1 ] != val ) { nextval = arr [ val - 1 ] ; arr [ val - 1 ] = val ; val = nextval ; if ( val <= 0 val > n ) break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { return i + 1 ; } } return n + 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 7 , 6 , 8 , - 1 , - 10 , 15 } ; int arr_size = arr . length ; int missing = findMissingNo ( arr , arr_size ) ; System . out . println ( " The ▁ smallest ▁ positive " + " ▁ missing ▁ number ▁ is ▁ " + missing ) ; } }
import java . io . * ; class GFG { static void findTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { System . out . println ( arr [ i ] + " ▁ " + arr [ j ] + " ▁ " + arr [ k ] ) ; } } } } } public static void main ( String [ ] args ) { int arr [ ] = { 0 , - 1 , 2 , - 3 , 1 } ; int n = arr . length ; findTriplets ( arr , n , - 2 ) ; } }
import java . io . * ; class GFG { static int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 3 ; i ++ ) for ( int j = i + 1 ; j < n - 2 ; j ++ ) for ( int k = j + 1 ; k < n - 1 ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 3 , 5 , 6 , 20 } ; int n = arr . length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) System . out . println ( " No ▁ Quadruple ▁ Exists " ) ; else System . out . println ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return - 1 ; Arrays . sort ( arr ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . max ( x , Math . max ( y , z ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 10 , - 3 , 5 , 6 , - 20 } ; int n = arr . length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) System . out . println ( " No ▁ Quadruple ▁ Exists " ) ; else System . out . println ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
import java . io . * ; class GFG { static int maxSum ( int arr [ ] , int n ) { if ( n < 2 ) return - 1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = Math . min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 12 , 2 , 2 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } }
class GFG { static final int N = 3 ; static int getGreatestSum ( int a [ ] [ ] ) { int prev_max = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 ] [ j ] ) prev_max = a [ N - 1 ] [ j ] ; int sum = prev_max ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int curr_max = - 2147483648 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i ] [ j ] && a [ i ] [ j ] > curr_max ) curr_max = a [ i ] [ j ] ; if ( curr_max == - 2147483648 ) return - 1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; } public static void main ( String arg [ ] ) { int a [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; System . out . println ( getGreatestSum ( a ) ) ; int b [ ] [ ] = { { 4 , 5 , 6 } , { 4 , 5 , 6 } , { 4 , 5 , 6 } } ; System . out . println ( getGreatestSum ( b ) ) ; } }
class GFG { static void findElement ( int n , int k ) { int ans = n ; int left = 1 ; int right = ( int ) ( Math . pow ( 2 , n ) - 1 ) ; while ( true ) { int mid = ( left + right ) / 2 ; if ( k == mid ) { System . out . println ( ans ) ; break ; } ans -- ; if ( k < mid ) { right = mid - 1 ; } else { left = mid + 1 ; } } } public static void main ( String [ ] args ) { int n = 4 , k = 8 ; findElement ( n , k ) ; } }
import java . util . * ; import java . io . * ; class GFG { static int checkBit ( int pattern , int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; } static int maxAND ( int arr [ ] , int n ) { int res = 0 , count ; for ( int bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } if ( res == 0 ) System . out . println ( " Not ▁ Possible " ) ; else { System . out . print ( " Pair ▁ = ▁ " ) ; count = 0 ; for ( int i = 0 ; i < n && count < 2 ; i ++ ) { if ( ( arr [ i ] & res ) == res ) { count ++ ; System . out . print ( arr [ i ] + " ▁ " ) ; } } System . out . println ( ) ; } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 8 , 6 , 2 } ; int n = arr . length ; System . out . println ( " Maximum ▁ AND ▁ Value ▁ = ▁ " + maxAND ( arr , n ) ) ; } }
import java . util . Scanner ; import java . io . * ; class GFG { static int countMaxSumPairs ( int a [ ] , int n ) { int first = Integer . MIN_VALUE , second = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } int cnt1 = 0 , cnt2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == first ) cnt1 ++ ; if ( a [ i ] == second ) cnt2 ++ ; } if ( cnt1 == 1 ) return cnt2 ; if ( cnt1 > 1 ) return cnt1 * ( cnt1 - 1 ) / 2 ; return 0 ; } static float findMaxSumProbability ( int a [ ] , int n ) { int total = n * ( n - 1 ) / 2 ; int max_sum_pairs = countMaxSumPairs ( a , n ) ; return ( float ) max_sum_pairs / ( float ) total ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 2 , 3 } ; int n = a . length ; ; System . out . println ( findMaxSumProbability ( a , n ) ) ; } }
class GFG { static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; } public static void main ( String [ ] args ) { int s = 15 ; int n = findS ( s ) ; if ( n == - 1 ) System . out . println ( " - 1" ) ; else System . out . println ( n ) ; } }
class GFG { static int calcSafe ( int pos ) { int j = pos % 10 ; int i = pos / 10 ; int dis_11 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 1 - j ) ) ; int dis_18 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 8 - j ) ) ; int dis_81 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 1 - j ) ) ; int dis_88 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 8 - j ) ) ; int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; } public static void main ( String [ ] args ) { int pos = 34 ; System . out . print ( " Safe ▁ Positions ▁ = ▁ " + calcSafe ( pos ) ) ; } }
import java . io . * ; class GFG { static int getCount ( int arr [ ] , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 } ; int n = arr . length ; int num1 = 5 , num2 = 4 ; System . out . println ( getCount ( arr , n , num1 , num2 ) ) ; } }
class Test { static int sumOfDigit ( int K ) { int sod = 0 ; while ( K != 0 ) { sod += K % 10 ; K /= 10 ; } return sod ; } static int totalNumbersWithSpecificDifference ( int N , int diff ) { int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid - sumOfDigit ( mid ) < diff ) low = mid + 1 ; else high = mid - 1 ; } return ( N - high ) ; } public static void main ( String args [ ] ) { int N = 13 ; int diff = 2 ; System . out . println ( totalNumbersWithSpecificDifference ( N , diff ) ) ; } }
class Test { static int countBuildings ( int arr [ ] , int n ) { int count = 1 ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 4 , 8 , 2 , 9 } ; System . out . println ( countBuildings ( arr , arr . length ) ) ; } }
class GFG { static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 13 } ; int arr2 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 } ; int n = arr2 . length ; System . out . println ( findExtra ( arr1 , arr2 , n ) ) ; } }
class GFG { static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 13 } ; int arr2 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 } ; int n = arr2 . length ; System . out . println ( findExtra ( arr1 , arr2 , n ) ) ; } }
class GFG { public static int computeCost ( int arr [ ] , int N , int X ) { int cost = 0 ; for ( int i = 0 ; i < N ; i ++ ) cost += Math . abs ( arr [ i ] - X ) ; return cost ; } public static int minCostToMakeElementEqual ( int arr [ ] , int N ) { int low , high ; low = high = arr [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( low > arr [ i ] ) low = arr [ i ] ; if ( high < arr [ i ] ) high = arr [ i ] ; } while ( ( high - low ) > 2 ) { int mid1 = low + ( high - low ) / 3 ; int mid2 = high - ( high - low ) / 3 ; int cost1 = computeCost ( arr , N , mid1 ) ; int cost2 = computeCost ( arr , N , mid2 ) ; if ( cost1 < cost2 ) high = mid2 ; else low = mid1 ; } return computeCost ( arr , N , ( low + high ) / 2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 100 , 101 } ; int N = arr . length ; System . out . println ( minCostToMakeElementEqual ( arr , N ) ) ; } }
import java . util . * ; class GFG { static int Next_greater ( int a [ ] , int n , int x ) { Arrays . sort ( a ) ; int low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 5 , 10 , 4 , 7 } , x = 4 ; int n = a . length ; System . out . println ( Next_greater ( a , n , x ) ) ; } }
import java . util . * ; class GFG { static long mod = 1000000007 ; static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } static long powmod ( long a , long n ) { if ( n == 0 ) return 1 ; long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 == 1 ) return ( pt * a ) % mod ; else return pt ; } static long CountSubset ( int [ ] arr , int n ) { long ans = powmod ( 2 , n - 1 ) ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && arr [ j ] == arr [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 2 } ; int n = arr . length ; System . out . println ( CountSubset ( arr , n ) ) ; } }
import java . util . * ; class GFG { static void reArrange ( String words [ ] , int n ) { HashMap < String , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( words [ i ] , ( i + 1 ) ) ; } Arrays . sort ( words ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( freq . get ( words [ i ] ) + " ▁ " ) ; } public static void main ( String [ ] args ) { String words [ ] = { " live " , " place " , " travel " , " word " , " sky " } ; int n = words . length ; reArrange ( words , n ) ; } }
class GFG { static int MAX = 100000 ; static int findSumofEle ( int arr1 [ ] , int m , int arr2 [ ] , int n ) { int hash [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr2 [ i ] ] ++ ; } for ( int i = 1 ; i < MAX ; i ++ ) { hash [ i ] = hash [ i ] + hash [ i - 1 ] ; } int maximumFreq = 0 ; for ( int i = 0 ; i < m ; i ++ ) { maximumFreq = Math . max ( maximumFreq , hash [ arr1 [ i ] ] ) ; } int sumOfElements = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sumOfElements += ( maximumFreq == hash [ arr1 [ i ] ] ) ? arr1 [ i ] : 0 ; } return sumOfElements ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 2 , 5 , 6 , 8 } ; int arr2 [ ] = { 4 , 10 } ; int m = arr1 . length ; int n = arr2 . length ; System . out . println ( findSumofEle ( arr1 , m , arr2 , n ) ) ; } }
import java . util . * ; class GfG { static void printNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int A = arr [ n - 1 ] , B = - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( A % arr [ i ] != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } System . out . print ( " A ▁ = ▁ " + A + " , ▁ B ▁ = ▁ " + B ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 , 1 , 2 , 4 } ; int n = arr . length ; printNumbers ( arr , n ) ; } }
class GFG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void removeMin ( int arr [ ] , int n ) { int i , minVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minVal = Math . min ( minVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; } static void removeFromMax ( int arr [ ] , int n ) { int i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = Math . max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; } static void modifyArray ( int arr [ ] , int n , int k ) { if ( k % 2 == 0 ) removeMin ( arr , n ) ; else removeFromMax ( arr , n ) ; printArray ( arr , n ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 8 , 12 , 16 } ; int n = arr . length ; int k = 2 ; modifyArray ( arr , n , k ) ; } }
import java . util . * ; class GFG { static int findAnswer ( int n , int [ ] arr ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; } public static void main ( String [ ] args ) { int [ ] arr = { 53 , 28 , 143 , 5 } ; int n = arr . length ; System . out . println ( findAnswer ( n , arr ) ) ; } }
import java . util . * ; class GFG { static int n = 4 ; static void merge ( int l , int r , int [ ] output ) { int l_in = l * n , r_in = ( ( l + r ) / 2 + 1 ) * n ; int l_c = ( ( l + r ) / 2 - l + 1 ) * n ; int r_c = ( r - ( l + r ) / 2 ) * n ; int l_arr [ ] = new int [ l_c ] , r_arr [ ] = new int [ r_c ] ; for ( int i = 0 ; i < l_c ; i ++ ) l_arr [ i ] = output [ l_in + i ] ; for ( int i = 0 ; i < r_c ; i ++ ) r_arr [ i ] = output [ r_in + i ] ; int l_curr = 0 , r_curr = 0 ; int in = l_in ; while ( l_curr + r_curr < l_c + r_c ) { if ( r_curr == r_c || ( l_curr != l_c && l_arr [ l_curr ] < r_arr [ r_curr ] ) ) { output [ in ] = l_arr [ l_curr ] ; l_curr ++ ; in ++ ; } else { output [ in ] = r_arr [ r_curr ] ; r_curr ++ ; in ++ ; } } } static void divide ( int l , int r , int [ ] output , int arr [ ] [ ] ) { if ( l == r ) { for ( int i = 0 ; i < n ; i ++ ) output [ l * n + i ] = arr [ l ] [ i ] ; return ; } divide ( l , ( l + r ) / 2 , output , arr ) ; divide ( ( l + r ) / 2 + 1 , r , output , arr ) ; merge ( l , r , output ) ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 5 , 7 , 15 , 18 } , { 1 , 8 , 9 , 17 } , { 1 , 4 , 7 , 7 } } ; int k = arr . length ; int [ ] output = new int [ n * k ] ; divide ( 0 , k - 1 , output , arr ) ; for ( int i = 0 ; i < n * k ; i ++ ) System . out . print ( output [ i ] + " ▁ " ) ; } }
class GFG { static int countDistinct ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) res ++ ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 10 , 9 , 45 , 2 , 10 , 10 , 45 } ; int n = arr . length ; System . out . println ( countDistinct ( arr , n ) ) ; } }
import java . util . Arrays ; class GFG { static int countDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 } ; int n = arr . length ; System . out . println ( countDistinct ( arr , n ) ) ; } }
import java . util . Arrays ; class GfG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void printMaxMean ( int arr [ ] , int n ) { int newArr [ ] = new int [ n ] ; Arrays . sort ( arr , 0 , 2 * n ) ; for ( int i = 0 ; i < n ; i ++ ) newArr [ i ] = arr [ i + n ] ; printArray ( newArr , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 8 , 3 , 1 , 3 , 7 , 0 , 4 } ; int n = arr . length ; printMaxMean ( arr , n / 2 ) ; } }
import java . io . * ; import java . util . * ; class GFG { static double average ( int arr [ ] , int n , int k ) { double total = 0 ; if ( 2 * k >= n ) return 0 ; Arrays . sort ( arr ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 4 , 5 , 6 } ; int n = arr . length ; int k = 2 ; System . out . println ( average ( arr , n , k ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int min_sum ( int n , int k , int a [ ] ) { Arrays . sort ( a ) ; if ( a [ 0 ] < 0 ) return - 1 ; if ( k == 0 ) { if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return - 1 ; } else { int f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int p = a [ i ] - a [ 0 ] ; if ( p % k == 0 ) continue ; else { f = 1 ; break ; } } if ( f > 0 ) return - 1 ; else { if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int K = 1 ; int N = arr . length ; System . out . println ( min_sum ( N , K , arr ) ) ; } }
import java . util . * ; class GfG { static int minCost ( int A [ ] , int n ) { int cost = 0 ; Arrays . sort ( A ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 6 , 7 , 10 } ; int n = A . length ; System . out . println ( minCost ( A , n ) ) ; } }
import java . util . * ; class Solution { static void printArray ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; flag = 1 ; l = i ; } { for ( i = r ; i > r - k && i >= l ; i -- ) System . out . print ( arr [ i ] + " ▁ " ) ; flag = 0 ; r = i ; } k ++ ; } } public static void main ( String args [ ] ) { int n = 6 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; printArray ( arr , n ) ; } }
public class GFG { static boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) < s . charAt ( i - 1 ) ) { return false ; } } return true ; } static public void main ( String [ ] args ) { String s = " aabbbcc " ; if ( isAlphabaticOrder ( s ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . io . * ; class GFG { static int rotateRec ( int n , int L [ ] , int B [ ] ) { int m = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; } public static void main ( String [ ] args ) { int n = 3 ; int L [ ] = { 5 , 5 , 6 } ; int B [ ] = { 6 , 7 , 8 } ; if ( rotateRec ( n , L , B ) == 1 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . Arrays ; class GFG { static void minDistance ( int n , int k , int point [ ] [ ] ) { for ( int i = 0 ; i < k ; i ++ ) Arrays . sort ( point [ i ] ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( point [ i ] [ ( int ) Math . ceil ( ( double ) ( n / 2 ) - 1 ) ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 4 ; int k = 4 ; int point [ ] [ ] = { { 1 , 5 , 2 , 4 } , { 6 , 2 , 0 , 6 } , { 9 , 5 , 1 , 3 } , { 6 , 7 , 5 , 9 } } ; minDistance ( n , k , point ) ; } }
import java . util . * ; class GFG { static void printOrder ( int [ ] arr , int n , int k ) { int len1 = k , len2 = n - k ; int [ ] arr1 = new int [ k ] ; int [ ] arr2 = new int [ n - k ] ; for ( int i = 0 ; i < k ; i ++ ) arr1 [ i ] = arr [ i ] ; for ( int i = k ; i < n ; i ++ ) arr2 [ i - k ] = arr [ i ] ; Arrays . sort ( arr1 , 0 , k ) ; Arrays . sort ( arr2 , k , n - k ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) arr [ i ] = arr1 [ i ] ; else { arr [ i ] = arr2 [ len2 - 1 ] ; len2 -- ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 } ; int k = 4 ; int n = arr . length ; printOrder ( arr , n , k ) ; } }
class GFG { static void findMaxNum ( int arr [ ] , int n ) { int [ ] hash = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 9 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) System . out . print ( i ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 0 } ; int n = arr . length ; findMaxNum ( arr , n ) ; } }
import java . util . * ; class Geeks { static int distribution ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , n / 2 ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 4 } ; int n = arr . length ; System . out . println ( distribution ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static void main ( String [ ] args ) { int a [ ] = { 10 , 12 , 5 } ; Arrays . sort ( a ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } }
import java . io . * ; class GFG { static int printTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) System . out . println ( arr [ i ] + " , ▁ " + arr [ j ] + " , ▁ " + arr [ k ] ) ; } } return 0 ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 1 , 3 , 4 , 7 } ; int n = arr . length ; int sum = 12 ; printTriplets ( arr , n , sum ) ; } }
import java . util . * ; class GFG { public static int countTriplets ( int [ ] arr , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) { ans ++ ; } } } } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 } ; int n = arr . length ; int a = 8 , b = 16 ; System . out . println ( " " + countTriplets ( arr , n , a , b ) ) ; } }
import java . util . * ; class GFG { public static int countTripletsLessThan ( int [ ] arr , int n , int val ) { Arrays . sort ( arr ) ; int ans = 0 ; int j , k ; int sum ; for ( int i = 0 ; i < n - 2 ; i ++ ) { j = i + 1 ; k = n - 1 ; while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ; if ( sum > val ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; } public static int countTriplets ( int arr [ ] , int n , int a , int b ) { int res ; res = countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ; return res ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 } ; int n = arr . length ; int a = 8 , b = 16 ; System . out . println ( " " + countTriplets ( arr , n , a , b ) ) ; } }
import java . io . * ; import java . util . Arrays ; import java . util . * ; class GFG { static int MaxTotalRectangleArea ( Integer [ ] a , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ! flag ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; } public static void main ( String args [ ] ) { Integer [ ] a = { 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 } ; int n = a . length ; System . out . print ( MaxTotalRectangleArea ( a , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void print ( ArrayList < Integer > a , int n ) { for ( int i = 0 ; i <= n ; i ++ ) System . out . print ( a . get ( i ) + " ▁ " ) ; System . out . println ( ) ; } static void sort ( ArrayList < Integer > a , int n ) { for ( int i = n ; i >= 0 ; i -- ) for ( int j = n ; j > n - i ; j -- ) if ( a . get ( j ) > a . get ( j - 1 ) ) { int tempswap = a . get ( j ) ; a . remove ( j ) ; a . add ( j , a . get ( j - 1 ) ) ; a . remove ( j - 1 ) ; a . add ( j - 1 , tempswap ) ; } print ( a , n ) ; } public static void main ( String [ ] args ) { int n = 6 ; ArrayList < Integer > a = new ArrayList < Integer > ( ) ; a . add ( 2 ) ; a . add ( 4 ) ; a . add ( 3 ) ; a . add ( 2 ) ; a . add ( 4 ) ; a . add ( 5 ) ; a . add ( 3 ) ; sort ( a , n ) ; } }
import java . io . * ; class GFG { static int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; } public static void main ( String [ ] args ) { int x [ ] = { - 1 , 1 , 3 , 2 } ; int y [ ] = { 5 , 6 , 5 , 3 } ; int n = x . length ; System . out . println ( distancesum ( x , y , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int distancesum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int res = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += ( arr [ i ] * i - sum ) ; sum += arr [ i ] ; } return res ; } static int totaldistancesum ( int x [ ] , int y [ ] , int n ) { return distancesum ( x , n ) + distancesum ( y , n ) ; } public static void main ( String [ ] args ) { int x [ ] = { - 1 , 1 , 3 , 2 } ; int y [ ] = { 5 , 6 , 5 , 3 } ; int n = x . length ; System . out . println ( totaldistancesum ( x , y , n ) ) ; } }
import java . util . Arrays ; class GFG { static void printMedian ( int arr [ ] , int n , int K ) { Arrays . sort ( arr ) ; System . out . print ( arr [ ( n + K ) / 2 ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 2 , 8 } ; int k = 3 ; int n = arr . length ; printMedian ( arr , n , k ) ; } }
class GFG { static void arrange ( int arr [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { int diff = Math . abs ( arr [ i ] - x ) ; int j = i - 1 ; if ( Math . abs ( arr [ j ] - x ) > diff ) { int temp = arr [ i ] ; while ( j >= 0 && Math . abs ( arr [ j ] - x ) > diff ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } } } static void print ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 5 , 3 , 9 , 2 } ; int n = arr . length ; int x = 7 ; arrange ( arr , n , x ) ; print ( arr , n ) ; } }
import java . util . * ; class GFG { static void printOrder ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } for ( int j = n - 1 ; j >= n / 2 ; j -- ) { System . out . print ( arr [ j ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , - 1 } ; int n = arr . length ; printOrder ( arr , n ) ; } }
import java . util . * ; class GFG { static int findMinimum ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += arr [ i ] ; n = n - k ; } return res ; } static int findMaximum ( int arr [ ] , int n , int k ) { int res = 0 , index = 0 ; for ( int i = n - 1 ; i >= index ; i -- ) { res += arr [ i ] ; index += k ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 , 4 } ; int n = arr . length ; int k = 2 ; Arrays . sort ( arr ) ; System . out . println ( findMinimum ( arr , n , k ) + " ▁ " + findMaximum ( arr , n , k ) ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int maxLevel ( int [ ] boxes , int n ) { Arrays . sort ( boxes ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; } static public void main ( String [ ] args ) { int [ ] boxes = { 10 , 20 , 30 , 50 , 60 , 70 } ; int n = boxes . length ; System . out . println ( maxLevel ( boxes , n ) ) ; } }
import java . util . Arrays ; public class GFG { static void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 2 , 7 , 5 , 4 } ; twoWaySort ( arr , arr . length ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }
class GFG { static final int MAX = 1000000 ; static int ksmallest ( int arr [ ] , int n , int k ) { int b [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k != 1 ) { return j ; } } return Integer . MAX_VALUE ; } public static void main ( String [ ] args ) { int k = 1 ; int arr [ ] = { 1 } ; int n = arr . length ; System . out . println ( ksmallest ( arr , n , k ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void mergeTwoHalf ( int [ ] A , int n ) { Arrays . sort ( A ) ; } static public void main ( String [ ] args ) { int [ ] A = { 2 , 3 , 8 , - 1 , 7 , 10 } ; int n = A . length ; mergeTwoHalf ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; } }
import java . util . * ; class GFG { static int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 100 , 300 , 200 , 1000 , 20 , 30 } ; int n = arr . length ; int k = 3 ; System . out . println ( minDiff ( arr , n , k ) ) ; } }
import java . io . * ; class GFG { static int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; } static int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; } static int countSwaps ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; return _mergeSort ( arr , temp , 0 , n - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = arr . length ; System . out . println ( " Number ▁ of ▁ swaps ▁ is ▁ " + countSwaps ( arr , n ) ) ; } }
class GFG { public static boolean isEven ( int n ) { return ( n % 2 == 0 ) ; } public static void main ( String [ ] args ) { int n = 101 ; if ( isEven ( n ) == true ) System . out . print ( " Even " ) ; else System . out . print ( " Odd " ) ; } }
import java . io . * ; class GFG { static void findSurpasser ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; System . out . print ( count + " ▁ " ) ; } } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 7 , 5 , 3 , 0 , 8 , 1 } ; int n = arr . length ; System . out . println ( " Given ▁ array ▁ is ▁ " ) ; printArray ( arr , n ) ; System . out . println ( " Surpasser ▁ Count ▁ of " + " ▁ array ▁ is ▁ " ) ; findSurpasser ( arr , n ) ; } }
import java . util . Arrays ; class GFG { static int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 8 , 4 , 5 , 2 , 3 } ; int n = arr . length ; System . out . print ( " Sum ▁ is ▁ " + solve ( arr , n ) ) ; } }
class GFG { static int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; } public static void main ( String [ ] args ) { int [ ] arr = { 10 , 3 , 5 , 6 , 20 } ; int n = arr . length ; ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) System . out . println ( " No ▁ Triplet ▁ Exists " ) ; else System . out . println ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
import java . util . * ; class GFG { static int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int [ ] leftMin = new int [ n ] ; int [ ] rightMin = new int [ n ] ; int [ ] leftMax = new int [ n ] ; int [ ] rightMax = new int [ n ] ; Arrays . fill ( leftMin , - 1 ) ; Arrays . fill ( leftMax , - 1 ) ; Arrays . fill ( rightMax , - 1 ) ; Arrays . fill ( rightMin , - 1 ) ; int max_product = Integer . MIN_VALUE ; int max_sum = arr [ 0 ] ; int min_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { leftMax [ i ] = max_sum ; if ( arr [ i ] > max_sum ) max_sum = arr [ i ] ; leftMin [ i ] = min_sum ; if ( arr [ i ] < min_sum ) min_sum = arr [ i ] ; } max_sum = arr [ n - 1 ] ; min_sum = arr [ n - 1 ] ; for ( int j = n - 2 ; j >= 0 ; j -- ) { rightMax [ j ] = max_sum ; if ( arr [ j ] > max_sum ) max_sum = arr [ j ] ; rightMin [ j ] = min_sum ; if ( arr [ j ] < min_sum ) min_sum = arr [ j ] ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int max1 = Math . max ( arr [ i ] * leftMax [ i ] * rightMax [ i ] , arr [ i ] * leftMin [ i ] * rightMin [ i ] ) ; int max2 = Math . max ( arr [ i ] * leftMax [ i ] * rightMin [ i ] , arr [ i ] * leftMin [ i ] * rightMax [ i ] ) ; max_product = Math . max ( max_product , Math . max ( max1 , max2 ) ) ; } return max_product ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 4 , 3 , - 6 , - 7 , 0 } ; int n = arr . length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) System . out . println ( " No ▁ Triplet ▁ Exists " ) ; else System . out . println ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
import java . util . Arrays ; class GFG { static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) { return - 1 ; } Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 10 , - 3 , 5 , 6 , - 20 } ; int n = arr . length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) { System . out . println ( " No ▁ Triplet ▁ Exists " ) ; } else { System . out . println ( " Maximum ▁ product ▁ is ▁ " + max ) ; } } }
import java . util . * ; class GFG { static int Substring ( String s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; } public static void main ( String [ ] args ) { String s = " abcdddddeff " ; System . out . println ( Substring ( s ) ) ; } }
import java . util . * ; class GFG { static void solve ( int n , int k ) { int mini = 0 ; int x1 = 1 ; int [ ] a = new int [ k ] ; for ( int i = 1 ; i <= k ; i ++ ) { mini += x1 ; a [ i - 1 ] = x1 ; x1 += 1 ; } if ( n < mini ) { System . out . print ( " - 1" ) ; return ; } int rem = n - mini ; int cnt = rem / k ; rem = rem % k ; for ( int i = 0 ; i < k ; i ++ ) a [ i ] += cnt ; for ( int i = k - 1 ; i > 0 && rem > 0 ; i -- ) { int xx = a [ i - 1 ] * 2 ; int left = xx - a [ i ] ; if ( rem >= left ) { a [ i ] = xx ; rem -= left ; } else { a [ i ] += rem ; rem = 0 ; } } int sum = a [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) { if ( a [ i ] > 2 * a [ i - 1 ] ) { System . out . print ( " - 1" ) ; return ; } sum += a [ i ] ; } if ( sum != n ) { System . out . print ( " - 1" ) ; return ; } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 26 , k = 6 ; solve ( n , k ) ; } }
import java . util . * ; class GFG { static int maxCoins ( int X , int Y ) { if ( X < Y ) { swap ( X , Y ) ; } int coins = X ; X -- ; coins += Math . max ( X , Y ) ; return coins ; } static void swap ( int X , int Y ) { int temp = X ; X = Y ; Y = temp ; } public static void main ( String [ ] args ) { int X = 7 , Y = 5 ; System . out . println ( maxCoins ( X , Y ) ) ; } }
import java . util . * ; class GFG { static int findElementsCrossed ( int arr [ ] , int a , int b , int n ) { int aa = a ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a == 0 && b == 0 ) break ; else if ( a == 0 ) { if ( arr [ i ] == 1 ) { b -= 1 ; a = Math . min ( aa , a + 1 ) ; } else b -= 1 ; } else if ( b == 0 ) a -- ; else if ( arr [ i ] == 1 && a < aa ) { b -= 1 ; a = Math . min ( aa , a + 1 ) ; } else a -- ; ans ++ ; } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 } ; int n = arr . length ; int a = 1 ; int b = 2 ; System . out . println ( findElementsCrossed ( arr , a , b , n ) ) ; } }
class GFG { static boolean isVowel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; default : return false ; } } static int vowelPairs ( String s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isVowel ( s . charAt ( i ) ) && isVowel ( s . charAt ( i + 1 ) ) ) cnt ++ ; } return cnt ; } public static void main ( String args [ ] ) { String s = " abaebio " ; int n = s . length ( ) ; System . out . print ( vowelPairs ( s , n ) ) ; } }
import java . util . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int solve ( int health [ ] , int n ) { int currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) ; for ( int i = 2 ; i < n ; ++ i ) { currentgcd = gcd ( currentgcd , health [ i ] ) ; } return currentgcd ; } public static void main ( String args [ ] ) { int health [ ] = { 4 , 6 , 8 , 12 } ; int n = health . length ; System . out . println ( solve ( health , n ) ) ; } }
import java . util . * ; class GFG { static void Find_Sequence ( int [ ] arr , int n ) { Vector < Integer > inc_arr = new Vector < > ( ) , dec_arr = new Vector < > ( ) ; int flag = 0 ; long inc = - 1 , dec = ( long ) 1e7 ; for ( int i = 0 ; i < n ; i ++ ) { if ( inc < arr [ i ] && arr [ i ] < dec ) { if ( arr [ i ] < arr [ i + 1 ] ) { inc = arr [ i ] ; inc_arr . add ( arr [ i ] ) ; } else { dec = arr [ i ] ; dec_arr . add ( arr [ i ] ) ; } } else if ( inc < arr [ i ] ) { inc = arr [ i ] ; inc_arr . add ( arr [ i ] ) ; } else if ( dec > arr [ i ] ) { dec = arr [ i ] ; dec_arr . add ( arr [ i ] ) ; } else { System . out . println ( - 1 ) ; flag = 1 ; break ; } } if ( flag == 0 ) { for ( int i : inc_arr ) System . out . print ( i + " ▁ " ) ; System . out . println ( ) ; for ( int i : dec_arr ) System . out . print ( i + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 5 , 1 , 3 , 6 , 8 , 2 , 9 , 0 , 10 } ; int n = arr . length ; Find_Sequence ( arr , n ) ; } }
import java . util . * ; class GFG { static int reverse ( int n ) { int rev = 0 ; while ( n != 0 ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } return rev ; } static void getSum ( int n ) { n = reverse ( n ) ; int sumOdd = 0 , sumEven = 0 , c = 1 ; while ( n != 0 ) { if ( c % 2 == 0 ) sumEven += n % 10 ; else sumOdd += n % 10 ; n /= 10 ; c ++ ; } System . out . println ( " Sum ▁ odd ▁ = ▁ " + sumOdd ) ; System . out . println ( " Sum ▁ even ▁ = ▁ " + sumEven ) ; } public static void main ( String args [ ] ) { int n = 457892 ; getSum ( n ) ; } }
class GFG { static int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ; if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return - 1 ; } public static void main ( String [ ] args ) { int A = 1 , B = 2 , S = 7 , N = 5 ; System . out . print ( bankNotes ( A , B , S , N ) ) ; } }
class GfG { static void twoParts ( String str ) { int flag = 0 ; String a = " " ; char [ ] gfg = str . toCharArray ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( gfg [ i ] == '4' ) { gfg [ i ] = '3' ; a += '1' ; flag = 1 ; } else if ( flag != 0 ) a += '0' ; } str = new String ( gfg ) ; System . out . print ( str + " ▁ " + a ) ; } public static void main ( String [ ] args ) { String str = "9441" ; twoParts ( str ) ; } }
import java . lang . Math ; class GfG { static int longestSubstring ( String s ) { int cnt = 1 , maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; } public static void main ( String [ ] args ) { String s = " ccccdeededff " ; System . out . println ( longestSubstring ( s ) ) ; } }
class GFG { static int Minimum_Operations ( int [ ] a , int n ) { int [ ] np = new int [ n + 1 ] ; np [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ; if ( a [ i ] <= 0 ) np [ i ] ++ ; } int pos = 0 ; int ans = n ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; ans = Math . min ( ans , pos + np [ i + 1 ] ) ; } return ans ; } public static void main ( String args [ ] ) { int [ ] a = { - 1 , 0 , 1 , 2 } ; int n = a . length ; System . out . print ( Minimum_Operations ( a , n ) ) ; } }
class GFG { static int findSumofEle ( int [ ] arr1 , int m , int [ ] arr2 , int n , int k ) { float arraySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; float mean = arraySum / n ; int sumOfElements = 0 ; float difference = 0 ; for ( int i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( - 1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; } public static void main ( String [ ] args ) { int [ ] arr1 = { 1 , 2 , 3 , 4 , 7 , 9 } ; int [ ] arr2 = { 0 , 1 , 2 , 1 , 1 , 4 } ; int k = 2 ; int m = arr1 . length ; int n = arr2 . length ; System . out . println ( findSumofEle ( arr1 , m , arr2 , n , k ) ) ; } }
import java . util . * ; class GFG { static void findIntegers ( int n , int x , int y ) { ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans . add ( 1 ) ; if ( y - ( n - 1 ) <= 0 ) { System . out . print ( " - 1" ) ; return ; } ans . add ( y - ( n - 1 ) ) ; int store = 0 ; for ( int i = 0 ; i < n ; i ++ ) store += ans . get ( i ) * ans . get ( i ) ; if ( store < x ) { System . out . print ( " - 1" ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 3 , x = 254 , y = 18 ; findIntegers ( n , x , y ) ; } }
class CFG { static int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m % 2 != 0 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; } public static void main ( String [ ] args ) { int n = 4 , m = 6 ; System . out . println ( Minsteps ( n , m ) ) ; } }
class GFG { static int getsum ( int x ) { return ( x * ( x + 1 ) ) / 2 ; } static int countJumps ( int n ) { n = Math . abs ( n ) ; int ans = 0 ; while ( getsum ( ans ) < n || ( ( getsum ( ans ) - n ) & 1 ) > 0 ) ans ++ ; return ans ; } public static void main ( String args [ ] ) { int n = 9 ; System . out . println ( countJumps ( n ) ) ; } }
class GFG { static int maxCandies ( int arr [ ] , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = Math . min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 1 , 3 , 6 } ; int n = arr . length ; System . out . println ( maxCandies ( arr , n ) ) ; } }
class GFG { static int minChanges ( char [ ] str , int n ) { int count = 0 , zeros = 0 , ones = 0 ; if ( str [ 0 ] != '1' ) { count ++ ; ones ++ ; } for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) zeros ++ ; else ones ++ ; if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } } return count ; } public static void main ( String [ ] args ) { char [ ] str = "0000" . toCharArray ( ) ; int n = str . length ; System . out . print ( minChanges ( str , n ) ) ; } }
class GFG { static int steps ( int cur , int x , int n ) { if ( x == 0 ) return Integer . MAX_VALUE ; if ( x > 0 ) return Math . abs ( ( n - cur ) / x ) ; else return Math . abs ( ( cur - 1 ) / x ) ; } static int countSteps ( int curx , int cury , int n , int m , int [ ] [ ] moves ) { int count = 0 ; int k = moves . length ; for ( int i = 0 ; i < k ; i ++ ) { int x = moves [ i ] [ 0 ] ; int y = moves [ i ] [ 1 ] ; int stepct = Math . min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } return count ; } public static void main ( String [ ] args ) { int n = 4 , m = 5 , x = 1 , y = 1 ; int [ ] [ ] moves = { { 1 , 1 } , { 1 , 1 } , { 0 , - 2 } } ; System . out . print ( countSteps ( x , y , n , m , moves ) ) ; } }
class GFG { static int min_elimination ( int n , int [ ] arr ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 7 , 9 } ; int n = arr . length ; System . out . println ( min_elimination ( n , arr ) ) ; } }
class GFG { static String getCount ( int N ) { if ( N % 2 == 1 ) return "0" ; String result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( getCount ( N ) ) ; } }
class GFG { static boolean canFormTeam ( int n , int m ) { if ( n >= 1 && m >= 2 ) return true ; if ( m >= 1 && n >= 2 ) return true ; return false ; } static int maxTeams ( int n , int m ) { int count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) { n -= 2 ; m -= 1 ; } else { m -= 2 ; n -= 1 ; } count ++ ; } return count ; } public static void main ( String args [ ] ) { int n = 4 , m = 5 ; System . out . println ( maxTeams ( n , m ) ) ; } }
import java . util . Arrays ; class GFG { static long max ( long a , long b ) { if ( a > b ) return a ; else return b ; } static long smallestSide ( long a [ ] ) { Arrays . sort ( a ) ; long side1 , side2 , side3 , side4 , side11 , side12 , sideOfSquare ; side1 = a [ 0 ] + a [ 3 ] ; side2 = a [ 1 ] + a [ 2 ] ; side3 = a [ 0 ] + a [ 1 ] ; side4 = a [ 2 ] + a [ 3 ] ; side11 = max ( side1 , side2 ) ; side12 = max ( side3 , side4 ) ; sideOfSquare = max ( side11 , side12 ) ; return sideOfSquare ; } public static void main ( String [ ] args ) { long side [ ] = new long [ 4 ] ; System . out . println ( " Test ▁ Case ▁ 1" ) ; side [ 0 ] = 2 ; side [ 1 ] = 2 ; side [ 2 ] = 2 ; side [ 3 ] = 2 ; System . out . println ( smallestSide ( side ) ) ; System . out . println ( " Test Case 2 "); side [ 0 ] = 100000000000000L ; side [ 1 ] = 123450000000000L ; side [ 2 ] = 987650000000000L ; side [ 3 ] = 987654321000000L ; System . out . println ( smallestSide ( side ) ) ; } }
class GFG { static void find_rectangle ( int area ) { int l = 0 , b = 0 ; int M = ( int ) Math . sqrt ( area ) , ans ; for ( int i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = ( area / i ) ; b = i ; break ; } } System . out . println ( " l ▁ = ▁ " + l + " , ▁ b ▁ = ▁ " + b ) ; } public static void main ( String [ ] args ) { int area = 99 ; find_rectangle ( area ) ; } }
import java . util . * ; class GFG { static int sizeSubSet ( int a [ ] , int k , int n ) { Arrays . sort ( a ) ; HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . get ( a [ i ] / k ) == null ) s . put ( a [ i ] , s . get ( a [ i ] ) == null ? 1 : s . get ( a [ i ] ) + 1 ) ; } return s . size ( ) ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = a . length ; int k = 2 ; System . out . println ( sizeSubSet ( a , k , n ) ) ; } }
import java . util . * ; class solution { static int minimumSets ( String s , int y ) { int cnt = 0 ; int num = 0 ; int l = s . length ( ) ; boolean f = false ; for ( int i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s . charAt ( i ) - '0' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s . charAt ( i ) - '0' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; } public static void main ( String args [ ] ) { String s = "1234" ; int y = 30 ; System . out . println ( minimumSets ( s , y ) ) ; } }
import java . util . * ; class solution { void printArr ( int b [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " ▁ " + b [ i ] + " ▁ " ) ; } } void ModifiedArray ( int a [ ] , int n ) { int l = 0 , r = Integer . MAX_VALUE ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n / 2 ; i ++ ) { b [ i ] = Math . max ( l , a [ i ] - r ) ; b [ n - i - 1 ] = a [ i ] - b [ i ] ; l = b [ i ] ; r = b [ n - i - 1 ] ; } printArr ( b , n ) ; } public static void main ( String args [ ] ) { int a [ ] = { 5 , 6 } ; int n = a . length ; solution s = new solution ( ) ; s . ModifiedArray ( a , 2 * n ) ; } }
import java . io . * ; class GFG { static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } static int maxSum ( int a [ ] , int n ) { int S = 0 ; int S1 = maxSubArraySum ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; } public static void main ( String [ ] args ) { int a [ ] = { - 35 , 32 , - 24 , 0 , 27 , - 10 , 0 , - 19 } ; int n = a . length ; System . out . println ( maxSum ( a , n ) ) ; } }
import java . util . * ; class GFG { static int minimizeDiff ( int [ ] arr , int n , int k ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; if ( ( max - min ) <= k ) { return ( max - min ) ; } int avg = ( max + min ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > avg ) { arr [ i ] -= k ; } else { arr [ i ] += k ; } } max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; return ( max - min ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 16 , 12 , 9 , 20 } ; int n = 5 ; int k = 3 ; System . out . println ( " Max ▁ height ▁ difference ▁ = ▁ " + minimizeDiff ( arr , n , k ) ) ; } }
class GFG { static void maxLitres ( int budget , int plastic , int glass , int refund ) { if ( glass - refund < plastic ) { int ans = Math . max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; System . out . println ( ans ) ; } else { System . out . println ( ( budget / plastic ) ) ; } } public static void main ( String [ ] args ) { int budget = 10 , plastic = 11 , glass = 9 , refund = 8 ; maxLitres ( budget , plastic , glass , refund ) ; } }
import java . util . * ; class GFG { static int leastValue ( int P , int A , int N , int a [ ] ) { int ans = - 1 ; float tmp = Float . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { float t = ( float ) ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; } public static void main ( String [ ] args ) { int N = 2 , P = 12 , A = 2005 ; int a [ ] = { 1000 , 2000 } ; System . out . println ( leastValue ( P , A , N , a ) ) ; } }
import java . lang . * ; import java . util . * ; class GFG { static int findPermutation ( int n ) { int len = ( int ) Math . ceil ( Math . log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = ( n / 10 ) + ( n % 10 ) * ( int ) Math . pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; } public static void main ( String args [ ] ) { int n = 132 ; System . out . println ( findPermutation ( n ) ) ; } }
class GFG { static boolean isSellingPossible ( int n , int a [ ] ) { int i , c25 = 0 , c50 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 25 ) c25 ++ ; else if ( a [ i ] == 50 ) { c50 ++ ; if ( c25 == 0 ) break ; c25 -- ; } else { if ( c50 > 0 && c25 > 0 ) { c50 -- ; c25 -- ; } else if ( c25 >= 3 ) c25 -= 3 ; else break ; } } if ( i == n ) return true ; else return false ; } public static void main ( String [ ] args ) { int a [ ] = { 25 , 25 , 50 , 100 } ; int n = a . length ; if ( isSellingPossible ( n , a ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; class GFG { static boolean checkIfOverlap ( String str ) { int len = str . length ( ) ; int [ ] visited = new int [ len + 1 ] ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' . ' ) continue ; for ( int j = Math . max ( 0 , i - str . charAt ( i ) ) ; j <= Math . min ( len , i + str . charAt ( i ) ) ; j ++ ) visited [ j ] ++ ; } for ( int i = 0 ; i < len ; i ++ ) { if ( visited [ i ] > 1 ) { return true ; } } return false ; } public static void main ( String [ ] args ) { String str = " . 2 . . 2 . " ; if ( checkIfOverlap ( str ) ) System . out . println ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . io . * ; class GFG { static boolean isCorrectOrder ( int n ) { boolean flag = true ; int prev = - 1 ; int type = - 1 ; while ( n != 0 ) { if ( type == - 1 ) { if ( prev == - 1 ) { prev = n % 10 ; n = n / 10 ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = n / 10 ; continue ; } prev = n % 10 ; n = n / 10 ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = n / 10 ; } } return flag ; } public static void main ( String [ ] args ) { int n = 123454321 ; if ( isCorrectOrder ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static void printCoins ( int arr [ ] , int n ) { int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 8 , 15 , 3 , 7 } ; int n = arr1 . length ; printCoins ( arr1 , n ) ; System . out . println ( ) ; int arr2 [ ] = { 2 , 2 , 2 , 2 } ; n = arr2 . length ; printCoins ( arr2 , n ) ; System . out . println ( ) ; int arr3 [ ] = { 20 , 30 , 2 , 2 , 2 , 10 } ; n = arr3 . length ; printCoins ( arr3 , n ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void finalPos ( String command , int n , int x , int y ) { int cup , cdown , cleft , cright ; int final_x , final_y ; cup = cdown = cleft = cright = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( command . charAt ( i ) == ' U ' ) cup ++ ; else if ( command . charAt ( i ) == ' D ' ) cdown ++ ; else if ( command . charAt ( i ) == ' L ' ) cleft ++ ; else if ( command . charAt ( i ) == ' R ' ) cright ++ ; } final_x = x + ( cright - cleft ) ; final_y = y + ( cdown - cup ) ; System . out . println ( " Final ▁ Position : ▁ " + " ( " + final_x + " , ▁ " + final_y + " ) " ) ; } public static void main ( String [ ] args ) { String command = " DDLRULL " ; int n = command . length ( ) ; int x = 3 , y = 4 ; finalPos ( command , n , x , y ) ; } }
import java . io . * ; class GFG { static int smallestSumSubarr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; int sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum_here = Math . max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 } ; int n = arr . length ; System . out . print ( " Smallest ▁ sum : ▁ " + smallestSumSubarr ( arr , n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GFG { static void printLargest ( int a [ ] , int n ) { int max = - 1 ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num > 0 ) { int r = num % 10 ; num = num / 10 ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( int i = ind ; i < n ; i ++ ) System . out . print ( a [ i ] ) ; for ( int i = 0 ; i < ind ; i ++ ) System . out . print ( a [ i ] ) ; } public static void main ( String args [ ] ) { int a [ ] = { 54 , 546 , 548 , 60 } ; int n = a . length ; printLargest ( a , n ) ; } }
import java . io . * ; class GFG { static int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 6 } ; int n = arr . length ; int k = 5 ; System . out . println ( MinOperation ( arr , n , k ) ) ; } }
class GFG { static int maxProductSubset ( int a [ ] , int n ) { if ( n == 1 ) { return a [ 0 ] ; } int max_neg = Integer . MIN_VALUE ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) { return 0 ; } if ( count_neg % 2 == 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) { return 0 ; } prod = prod / max_neg ; } return prod ; } public static void main ( String [ ] args ) { int a [ ] = { - 1 , - 1 , - 2 , 4 , 3 } ; int n = a . length ; System . out . println ( maxProductSubset ( a , n ) ) ; } }
import java . io . * ; class GFG { static void digitsNum ( int N ) { if ( N == 0 ) System . out . println ( "0" ) ; if ( N % 9 != 0 ) System . out . print ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) System . out . print ( "9" ) ; for ( int i = 1 ; i <= N ; ++ i ) System . out . print ( "0" ) ; System . out . print ( " " ) ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . print ( " The ▁ number ▁ is ▁ : ▁ " ) ; digitsNum ( N ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void printVector ( Vector < Integer > v ) { System . out . println ( v . size ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( v . get ( i ) + " ▁ " ) ; System . out . println ( ) ; } static void findTwoGroup ( int n ) { int sum = n * ( n + 1 ) / 2 ; int group1Sum = sum / 2 ; Vector < Integer > group1 = new Vector < Integer > ( ) ; Vector < Integer > group2 = new Vector < Integer > ( ) ; for ( int i = n ; i > 0 ; i -- ) { if ( group1Sum - i >= 0 ) { group1 . add ( i ) ; group1Sum -= i ; } else { group2 . add ( i ) ; } } printVector ( group1 ) ; printVector ( group2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; findTwoGroup ( n ) ; } }
import java . util . * ; class GFG { static int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; } public static void main ( String args [ ] ) { int arr [ ] = { 8 , 4 , 5 , 2 , 10 } ; int N = arr . length ; int k = 2 ; System . out . println ( maxDifference ( arr , N , k ) ) ; } }
import java . math . * ; class GFG { static int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 4 , 5 , 4 } ; int b [ ] = { 3 , 4 , 2 , 3 , 2 } ; int n = 5 , k = 3 ; System . out . println ( minproduct ( a , b , n , k ) ) ; } }
import java . io . * ; class GFG { static int count ( int n ) { if ( n < 4 ) return - 1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } return 0 ; } public static void main ( String [ ] args ) { int n = 90 ; System . out . println ( count ( n ) ) ; n = 143 ; System . out . println ( count ( n ) ) ; } }
class GFG { static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; } public static void main ( String [ ] args ) { int input = 28756 ; int unlock_code = 98234 ; System . out . println ( " Minimum ▁ Rotation ▁ = ▁ " + minRotation ( input , unlock_code ) ) ; } }
import java . io . * ; import java . util . Arrays ; public class GFG { static void preprocess ( int [ ] coin , int n ) { Arrays . sort ( coin ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) coin [ i ] += coin [ i - 1 ] ; } static int minCost ( int [ ] coin , int n , int k ) { int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; return coin [ coins_needed - 1 ] ; } static public void main ( String [ ] args ) { int [ ] coin = { 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 } ; int n = coin . length ; preprocess ( coin , n ) ; int k = 3 ; System . out . println ( minCost ( coin , n , k ) ) ; k = 7 ; System . out . println ( minCost ( coin , n , k ) ) ; } }
class GFG { static int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } public static void main ( String arg [ ] ) { int arr [ ] = { - 2 , 0 , 5 , - 1 , 2 } ; int k = 4 ; int n = arr . length ; System . out . print ( maximumSum ( arr , n , k ) ) ; } }
class GFG { static int maxLen = 10 ; static int dp [ ] = new int [ maxLen ] ; static boolean v [ ] = new boolean [ maxLen ] ; static int maxSum ( int arr [ ] , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 9 , 7 , 33 } ; int n = arr . length ; System . out . println ( maxSum ( arr , 0 , n ) ) ; } }
class GFG { static int N = 5 ; static int func ( int idx , int cur , int a [ ] , int dp [ ] [ ] , int n , int x ) { if ( idx == n ) { return 0 ; } if ( dp [ idx ] [ cur ] != - 1 ) { return dp [ idx ] [ cur ] ; } int ans = 0 ; if ( cur == 0 ) { ans = Math . max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) ; ans = Math . max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) ; } else if ( cur == 1 ) { ans = Math . max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) ; ans = Math . max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) ; } { ans = Math . max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) ; } return dp [ idx ] [ cur ] = ans ; } static int getMaximumSum ( int a [ ] , int n , int x ) { int dp [ ] [ ] = new int [ n ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxi = Math . max ( maxi , func ( i , 0 , a , dp , n , x ) ) ; } return maxi ; } public static void main ( String [ ] args ) { int a [ ] = { - 3 , 8 , - 2 , 1 , - 6 } ; int n = a . length ; int x = - 1 ; System . out . println ( getMaximumSum ( a , n , x ) ) ; } }
class GFG { static int N = 100 ; static void pre_process ( boolean dp [ ] [ ] , char [ ] s ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = false ; } } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } } } static int countPairs ( String s ) { boolean dp [ ] [ ] = new boolean [ N ] [ N ] ; pre_process ( dp , s . toCharArray ( ) ) ; int n = s . length ( ) ; int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; left [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( dp [ j ] [ i ] == true ) { left [ i ] ++ ; } } } right [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] ; for ( int j = n - 1 ; j >= i ; j -- ) { if ( dp [ i ] [ j ] == true ) { right [ i ] ++ ; } } } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += left [ i ] * right [ i + 1 ] ; } return ans ; } public static void main ( String [ ] args ) { String s = " abacaba " ; System . out . println ( countPairs ( s ) ) ; } }
class GFG { static int N = 100 ; static void pre_process ( boolean dp [ ] [ ] , char [ ] s ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = false ; } } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } } } static void answerQuery ( int l , int r , boolean dp [ ] [ ] ) { if ( dp [ l ] [ r ] ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { String s = " abaaab " ; boolean [ ] [ ] dp = new boolean [ N ] [ N ] ; pre_process ( dp , s . toCharArray ( ) ) ; int queries [ ] [ ] = { { 0 , 1 } , { 1 , 5 } } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) { answerQuery ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , dp ) ; } } }
class GFG { static int N = 100005 ; static int LIS ( int a [ ] , int n ) { int dp [ ] = new int [ N ] , d [ ] = new int [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = a . length ; System . out . print ( LIS ( a , n ) ) ; } }
class GFG { static int findSum ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 1 ; dp [ 0 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( 4 * ( i * i ) ) - 6 * ( i - 1 ) + dp [ i - 2 ] ; } return dp [ n ] ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( findSum ( n ) ) ; } }
class GFG { static int n = 3 ; static int MAX = 30 ; static int dp [ ] [ ] [ ] = new int [ n ] [ n ] [ MAX ] ; static boolean v [ ] [ ] [ ] = new boolean [ n ] [ n ] [ MAX ] ; static int findCount ( int mat [ ] [ ] , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int m = 5 ; System . out . println ( findCount ( mat , n - 1 , n - 1 , m ) ) ; } }
class GFG { static int N = 10 ; static int findMinimumDeletion ( int l , int r , int dp [ ] [ ] , String s ) { if ( l > r ) { return 0 ; } if ( l == r ) { return 1 ; } if ( dp [ l ] [ r ] != - 1 ) { return dp [ l ] [ r ] ; } int res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) ; for ( int i = l + 1 ; i <= r ; ++ i ) { if ( s . charAt ( l ) == s . charAt ( i ) ) { res = Math . min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) ; } } return dp [ l ] [ r ] = res ; } public static void main ( String [ ] args ) { String s = " abcddcba " ; int n = s . length ( ) ; int dp [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . println ( findMinimumDeletion ( 0 , n - 1 , dp , s ) ) ; } }
import java . util . * ; class GFG { static final int N = 5005 ; static int n , k ; static Vector < Integer > [ ] gr = new Vector [ N ] ; static int [ ] [ ] d = new int [ N ] [ 505 ] ; static int ans = 0 ; static void Add_edge ( int x , int y ) { gr [ x ] . add ( y ) ; gr [ y ] . add ( x ) ; } static void dfs ( int v , int par ) { d [ v ] [ 0 ] = 1 ; for ( Integer i : gr [ v ] ) { if ( i != par ) { dfs ( i , v ) ; for ( int j = 1 ; j <= k ; j ++ ) ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] ; for ( int j = 1 ; j <= k ; j ++ ) d [ v ] [ j ] += d [ i ] [ j - 1 ] ; } } } public static void main ( String [ ] args ) { n = 5 ; k = 2 ; for ( int i = 0 ; i < N ; i ++ ) gr [ i ] = new Vector < Integer > ( ) ; Add_edge ( 1 , 2 ) ; Add_edge ( 2 , 3 ) ; Add_edge ( 3 , 4 ) ; Add_edge ( 2 , 5 ) ; dfs ( 1 , 0 ) ; System . out . print ( ans ) ; } }
import java . util . * ; class GFG { static int findXorSum ( int arr [ ] , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { int c_odd = 0 ; boolean odd = false ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) odd = ( ! odd ) ; if ( odd ) c_odd ++ ; } for ( int j = 0 ; j < n ; j ++ ) { sum += ( mul * c_odd ) ; if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) c_odd = ( n - j - c_odd ) ; } mul *= 2 ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 8 , 13 } ; int n = arr . length ; System . out . println ( findXorSum ( arr , n ) ) ; } }
import java . lang . Math ; class GfG { static boolean checkCombinations ( int a [ ] , int n ) { int pow_set_size = ( int ) Math . pow ( 2 , n ) ; int counter , j ; for ( counter = 0 ; counter < pow_set_size ; counter ++ ) { int sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) else } if ( sum % ( 24 * 60 ) == 0 ) return true ; } return false ; } public static void main ( String [ ] args ) { int a [ ] = { 60 , 60 , 120 } ; int n = a . length ; if ( checkCombinations ( a , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { final static int n = 4 ; final static int m = 4 ; static float calcProbability ( int M [ ] [ ] , int k ) { float dp [ ] [ ] = new float [ m ] [ n ] ; float sum [ ] = new float [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { dp [ 0 ] [ j ] = M [ 0 ] [ j ] ; sum [ 0 ] = sum [ 0 ] + dp [ 0 ] [ j ] ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] / sum [ i - 1 ] + M [ i ] [ j ] ; sum [ i ] += dp [ i ] [ j ] ; } } return dp [ n - 1 ] [ k - 1 ] / sum [ n - 1 ] ; } public static void main ( String [ ] args ) { int M [ ] [ ] = { { 1 , 1 , 0 , 3 } , { 2 , 3 , 2 , 3 } , { 9 , 3 , 0 , 2 } , { 2 , 3 , 2 , 2 } } ; int k = 3 ; System . out . println ( calcProbability ( M , k ) ) ; } }
import java . util . * ; class GFG { static int MaximumNumbers ( String s ) { int n = s . length ( ) ; int [ ] remIndex = { - 1 , - 1 , - 1 } ; remIndex [ 0 ] = 0 ; int [ ] res = new int [ n + 1 ] ; int r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { r = ( r + s . charAt ( i - 1 ) - '0' ) % 3 ; res [ i ] = res [ i - 1 ] ; if ( remIndex [ r ] != - 1 ) res [ i ] = Math . max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) ; remIndex [ r ] = i + 1 ; } return res [ n ] ; } public static void main ( String [ ] args ) { String s = "12345" ; System . out . println ( MaximumNumbers ( s ) ) ; } }
public class GFG { static int max = 4 ; static int c = 2 ; static int countPaths ( int sum , int get , int m , int n , int dp [ ] [ ] ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != - 1 ) return dp [ sum ] [ get ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 , x = 3 ; int dp [ ] [ ] = new int [ max + 1 ] [ 2 ] ; for ( int i = 0 ; i <= max ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = - 1 ; System . out . println ( countPaths ( x , 0 , m , n , dp ) ) ; } }
import java . io . * ; class GFG { static int MAX_K = 15 ; static int fac [ ] = new int [ MAX_K ] ; static void factorial ( int k ) { fac [ 0 ] = 1 ; for ( int i = 1 ; i <= k + 1 ; i ++ ) { fac [ i ] = ( i * fac [ i - 1 ] ) ; } } static int bin ( int a , int b ) { int ans = ( ( fac [ a ] ) / ( fac [ a - b ] * fac [ b ] ) ) ; return ans ; } static int sumofn ( int n , int k ) { int p = 0 ; int num1 , temp ; int arr [ ] = new int [ 1000 ] ; for ( int j = 1 ; j <= k ; j ++ ) { if ( j == 1 ) { num1 = ( n * ( n + 1 ) ) / 2 ; arr [ p ++ ] = num1 ; temp = num1 ; } else { temp = ( ( int ) Math . pow ( n + 1 , j + 1 ) - 1 - n ) ; for ( int s = 1 ; s < j ; s ++ ) { temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) ; } temp = temp / ( j + 1 ) ; arr [ p ++ ] = temp ; } } temp = arr [ p - 1 ] ; return temp ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; factorial ( k ) ; System . out . println ( sumofn ( n , k ) ) ; } }
class solution { static final int max = 4 ; static int countWays ( int index , int cnt , int dp [ ] [ ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; } public static void main ( String args [ ] ) { int n = 3 , m = 3 , k = 2 ; int dp [ ] [ ] = new int [ n + 1 ] [ max ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) for ( int j = 0 ; j < max ; j ++ ) dp [ i ] [ j ] = - 1 ; System . out . println ( m * countWays ( 1 , 0 , dp , n , m , k ) ) ; } }
import java . io . * ; class GFG { static int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ 2 * n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( " Even ▁ indexed ▁ Fibonacci ▁ Sum ▁ upto ▁ " + n + " ▁ terms : ▁ " + + calculateEvenSum ( n ) ) ; } }
class GFG { static final int MAX = 32768 ; static int [ ] arr = new int [ 2 * MAX ] ; static void gouldSequence ( ) { arr [ 0 ] = 1 ; int i = 1 ; int p = 1 ; while ( i <= MAX ) { int j = 0 ; while ( j < i ) { arr [ i + j ] = 2 * arr [ j ] ; j ++ ; } i = ( 1 << p ) ; p ++ ; } } static void printSequence ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { gouldSequence ( ) ; int n = 16 ; printSequence ( n ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int MatrixChainOrder ( int p [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 20 , 30 , 40 , 30 } ; int size = arr . length ; System . out . print ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " + MatrixChainOrder ( arr , size ) ) ; } }
public class GFG { static int CommomSubsequencesCount ( String s , String t ) { int n1 = s . length ( ) ; int n2 = t . length ( ) ; int dp [ ] [ ] = new int [ n1 + 1 ] [ n2 + 1 ] ; char ch1 , ch2 ; for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i <= n1 ; i ++ ) { for ( int j = 1 ; j <= n2 ; j ++ ) { ch1 = s . charAt ( i - 1 ) ; ch2 = t . charAt ( j - 1 ) ; if ( ch1 == ch2 ) dp [ i ] [ j ] = 1 + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] - dp [ i - 1 ] [ j - 1 ] ; } } return dp [ n1 ] [ n2 ] ; } public static void main ( String args [ ] ) { String s = " ajblqcpdz " ; String t = " aefcnbtdi " ; System . out . println ( CommomSubsequencesCount ( s , t ) ) ; } }
public class AQW { static int fib [ ] = new int [ 43 ] ; static void fibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i < 43 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } static int rec ( int x , int y , int last ) { if ( y == 0 ) { if ( x == 0 ) return 1 ; return 0 ; } int sum = 0 ; for ( int i = last ; i >= 0 && fib [ i ] * y >= x ; i -- ) { if ( fib [ i ] > x ) continue ; sum += rec ( x - fib [ i ] , y - 1 , i ) ; } return sum ; } public static void main ( String [ ] args ) { fibonacci ( ) ; int n = 13 , k = 3 ; System . out . println ( " Possible ▁ ways ▁ are : ▁ " + rec ( n , k , 42 ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int minimumCost ( int cost [ ] , int n ) { int dp [ ] = new int [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; } public static void main ( String args [ ] ) { int a [ ] = { 16 , 19 , 10 , 12 , 18 } ; int n = a . length ; System . out . print ( minimumCost ( a , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; } public static void main ( String args [ ] ) { int a [ ] = { 2 , 5 , 3 , 1 , 7 , 3 , 4 } ; int n = a . length ; System . out . print ( minimumCost ( a , n ) ) ; } }
class GFG { static int editDistanceWith2Ops ( String X , String Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { L [ i ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; } else { L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } } int lcs = L [ m ] [ n ] ; return ( m - lcs ) + ( n - lcs ) ; } public static void main ( String [ ] args ) { String X = " abc " , Y = " acd " ; System . out . println ( editDistanceWith2Ops ( X , Y ) ) ; } }
class GFG { static int lcs ( String X , String Y , int m , int n ) { if ( m == 0 n == 0 ) { return 0 ; } if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) { return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; } else { return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } } public static void main ( String [ ] args ) { String X = " AGGTAB " ; String Y = " GXTXAYB " ; int m = X . length ( ) ; int n = Y . length ( ) ; System . out . println ( " Length ▁ of ▁ LCS : ▁ " + lcs ( X , Y , m , n ) ) ; } }
import java . io . * ; class GFG { static int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countPaths ( n ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static void getMinimumPenalty ( String x , String y , int pxy , int pgap ) { int dp [ ] [ ] = new int [ n + m + 1 ] [ n + m + 1 ] ; for ( int [ ] x1 : dp ) Arrays . fill ( x1 , 0 ) ; for ( i = 0 ; i <= ( n + m ) ; i ++ ) { dp [ i ] [ 0 ] = i * pgap ; dp [ 0 ] [ i ] = i * pgap ; } for ( i = 1 ; i <= m ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { if ( x . charAt ( i - 1 ) == y . charAt ( j - 1 ) ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = Math . min ( Math . min ( dp [ i - 1 ] [ j - 1 ] + pxy , dp [ i - 1 ] [ j ] + pgap ) , dp [ i ] [ j - 1 ] + pgap ) ; } } } i = m ; j = n ; int xpos = l ; int ypos = l ; int xans [ ] = new int [ l + 1 ] ; int yans [ ] = new int [ l + 1 ] ; while ( ! ( i == 0 j == 0 ) ) { if ( x . charAt ( i - 1 ) == y . charAt ( j - 1 ) ) { xans [ xpos -- ] = ( int ) x . charAt ( i - 1 ) ; yans [ ypos -- ] = ( int ) y . charAt ( j - 1 ) ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j - 1 ] + pxy == dp [ i ] [ j ] ) { xans [ xpos -- ] = ( int ) x . charAt ( i - 1 ) ; yans [ ypos -- ] = ( int ) y . charAt ( j - 1 ) ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j ] + pgap == dp [ i ] [ j ] ) { xans [ xpos -- ] = ( int ) x . charAt ( i - 1 ) ; yans [ ypos -- ] = ( int ) ' _ ' ; i -- ; } else if ( dp [ i ] [ j - 1 ] + pgap == dp [ i ] [ j ] ) { xans [ xpos -- ] = ( int ) ' _ ' ; yans [ ypos -- ] = ( int ) y . charAt ( j - 1 ) ; j -- ; } } while ( xpos > 0 ) { if ( i > 0 ) xans [ xpos -- ] = ( int ) x . charAt ( -- i ) ; else xans [ xpos -- ] = ( int ) ' _ ' ; } while ( ypos > 0 ) { if ( j > 0 ) yans [ ypos -- ] = ( int ) y . charAt ( -- j ) ; else yans [ ypos -- ] = ( int ) ' _ ' ; } int id = 1 ; for ( i = l ; i >= 1 ; i -- ) { if ( ( char ) yans [ i ] == ' _ ' && ( char ) xans [ i ] == ' _ ' ) { id = i + 1 ; break ; } } System . out . print ( " Minimum ▁ Penalty ▁ in ▁ " + " aligning ▁ the ▁ genes ▁ = ▁ " ) ; System . out . print ( dp [ m ] [ n ] + "NEW_LINE"); System . out . println ( " The ▁ aligned ▁ genes ▁ are ▁ : " ) ; for ( i = id ; i <= l ; i ++ ) { System . out . print ( ( char ) xans [ i ] ) ; } System . out . print ( "NEW_LINE"); for ( i = id ; i <= l ; i ++ ) { System . out . print ( ( char ) yans [ i ] ) ; } return ; } public static void main ( String [ ] args ) { String gene1 = " AGGGCT " ; String gene2 = " AGGCA " ; int misMatchPenalty = 3 ; int gapPenalty = 2 ; getMinimumPenalty ( gene1 , gene2 , misMatchPenalty , gapPenalty ) ; } }
import java . io . * ; class GFG { static int lds ( int arr [ ] , int n ) { int lds [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 } ; int n = arr . length ; System . out . print ( " Length ▁ of ▁ LDS ▁ is ▁ " + lds ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int MAX = 100 ; static void binomialCoeff ( int C [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } } static int sumOfproduct ( int n ) { int sum = 0 ; int C [ ] = new int [ MAX ] ; binomialCoeff ( C , n ) ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ i ] * C [ i + 1 ] ; return sum ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( sumOfproduct ( n ) ) ; } }
class GFG { static int MAX = 100 ; static void binomialCoeff ( int n , int C [ ] ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } } static int summation ( int n ) { int C [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) C [ i ] = 0 ; binomialCoeff ( n , C ) ; int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( i * C [ i ] ) ; return sum ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( summation ( n ) ) ; } }
import java . io . * ; class GFG { static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static int countArray ( int N , int K ) { return binomialCoeff ( K - 1 , N - 1 ) ; } public static void main ( String [ ] args ) { int N = 2 , K = 3 ; System . out . println ( countArray ( N , K ) ) ; } }
import java . io . * ; class GFG { static int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) { int ind ; int val ; int [ ] [ ] dp = new int [ n ] [ maxLimit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) dp [ ind ] [ val ] = 1 ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else { dp [ ind ] [ val ] = 0 ; } } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] == 1 ) { return val ; } } return - 1 ; } public static void main ( String args [ ] ) { int num = 1 ; int [ ] arr = new int [ ] { 3 , 10 , 6 , 4 , 5 } ; int n = arr . length ; int maxLimit = 15 ; System . out . print ( findMaxVal ( arr , n , num , maxLimit ) ) ; } }
class GFG { public static int gen ( int n ) { if ( n == 0 ) return 0 ; else if ( n == 1 ) return 1 ; else if ( n % 2 == 0 ) return 4 * gen ( n / 2 ) ; else if ( n % 2 == 1 ) return 4 * gen ( n / 2 ) + 1 ; return 0 ; } public static void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( gen ( i ) + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( " First ▁ " + n + " ▁ terms ▁ of ▁ " + " Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ " ) ; moserDeBruijn ( n ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int A [ ] [ ] = { { 2 } , { 3 , 9 } , { 1 , 6 , 7 } } ; static int minSumPath ( ) { int [ ] memo = new int [ A . length ] ; int n = A . length - 1 ; for ( int i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . length - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; } public static void main ( String args [ ] ) { System . out . print ( minSumPath ( ) ) ; } }
import java . util . Arrays ; class GFG { static int MAX = 100 ; static int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; static int countRemovals ( int a [ ] , int i , int j , int k ) { if ( i >= j ) return 0 ; else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ; else if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; else if ( ( a [ j ] - a [ i ] ) > k ) { dp [ i ] [ j ] = 1 + Math . min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) ; } return dp [ i ] [ j ] ; } static int removals ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; for ( int [ ] rows : dp ) Arrays . fill ( rows , - 1 ) ; if ( n == 1 ) return 0 ; else return countRemovals ( a , 0 , n - 1 , k ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 } ; int n = a . length ; int k = 4 ; System . out . print ( removals ( a , n , k ) ) ; } }
class GFG { static int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ; } return count ; } public static void main ( String arg [ ] ) { int a [ ] = { 3 , 4 , 2 } ; int n = a . length ; System . out . print ( countPairs ( a , n ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static long dp [ ] [ ] = new long [ 1000 ] [ 1000 ] ; static long sum ( int a [ ] , int i , int j ) { long ans = 0 ; for ( int m = i ; m <= j ; m ++ ) ans = ( ans + a [ m ] ) % 100 ; return ans ; } static long solve ( int a [ ] , int i , int j ) { if ( i == j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; dp [ i ] [ j ] = 100000000 ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) ; } return dp [ i ] [ j ] ; } static void initialize ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = - 1 ; } public static void main ( String args [ ] ) { int a [ ] = { 40 , 60 , 20 } ; int n = a . length ; initialize ( n ) ; System . out . println ( solve ( a , 0 , n - 1 ) ) ; } }
import java . io . * ; class GFG { static void reverseFibonacci ( int n ) { int a [ ] = new int [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { System . out . print ( a [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 5 ; reverseFibonacci ( n ) ; } }
import java . io . * ; class GFG { static float find_prob ( int N , float P ) { double dp [ ] = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( ( float ) ( dp [ N ] ) ) ; } public static void main ( String args [ ] ) { int n = 5 ; float p = 0.2f ; System . out . printf ( " % .2f " , find_prob ( n , p ) ) ; } }
import java . util . * ; class GFG { static int N = 5 ; static void printHosoya ( int n ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) System . out . print ( dp [ i ] [ j ] + " ▁ " ) ; System . out . println ( " " ) ; } } public static void main ( String [ ] args ) { int n = 5 ; printHosoya ( n ) ; } }
import java . io . * ; class GFG { static int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; } public static void main ( String args [ ] ) { int n = 3 , m = 1 ; System . out . println ( numberofways ( n , m ) ) ; } }
import java . util . * ; class GFG { static int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; } public static void main ( String [ ] args ) { int n = 4 , k = 3 ; System . out . println ( zigzag ( n , k ) ) ; } }
import java . util . * ; class Eulerian { public static int eulerian ( int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; } public static void main ( String [ ] args ) { int n = 3 , m = 1 ; System . out . print ( eulerian ( n , m ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; } public static void main ( String args [ ] ) { int n = 3 , m = 4 ; System . out . println ( dealnnoy ( n , m ) ) ; } }
import java . io . * ; class GFG { static int dealnnoy ( int n , int m ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; } public static void main ( String args [ ] ) { int n = 3 , m = 4 ; System . out . println ( dealnnoy ( n , m ) ) ; } }
import java . util . * ; class Longest { public static void longestAlternating ( int arr [ ] , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int a [ ] = { - 5 , - 1 , - 1 , 2 , - 2 , - 3 } ; int n = 6 ; longestAlternating ( a , n ) ; } }
import java . io . * ; class GFG { static int maxDP ( int n ) { int res [ ] = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; } public static void main ( String [ ] args ) { int n = 60 ; System . out . println ( " MaxSum ▁ = ▁ " + maxDP ( n ) ) ; } }
class GFG { static boolean isSafe ( int x , int y ) { return ( x < 4 && y < 3 ) ; } static int minJump ( int height [ ] [ ] , int x , int y ) { if ( x == 4 - 1 && y == 3 - 1 ) return 0 ; int diag = Integer . MAX_VALUE ; if ( isSafe ( x + 1 , y + 1 ) ) diag = minJump ( height , x + 1 , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; int down = Integer . MAX_VALUE ; if ( isSafe ( x + 1 , y ) ) down = minJump ( height , x + 1 , y ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ; int right = Integer . MAX_VALUE ; if ( isSafe ( x , y + 1 ) ) right = minJump ( height , x , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ; return Math . min ( down , Math . min ( right , diag ) ) ; } public static void main ( String [ ] args ) { int height [ ] [ ] = { { 5 , 4 , 2 } , { 9 , 2 , 1 } , { 2 , 5 , 9 } , { 1 , 3 , 11 } } ; System . out . println ( minJump ( height , 0 , 0 ) ) ; } }
import java . io . * ; class GFG { static int maxSum ( int arr [ ] , int N , int k ) { int MS [ ] = new int [ N ] ; MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = Math . max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; } public static void main ( String [ ] args ) { int N = 10 , k = 2 ; int arr [ ] = { 50 , 70 , 40 , 50 , 90 , 70 , 60 , 40 , 70 , 50 } ; System . out . println ( maxSum ( arr , N , k ) ) ; } }
class GFG { static void alternateSubarray ( boolean arr [ ] , int n ) { int len [ ] = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) System . out . print ( len [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { boolean arr [ ] = { true , false , true , false , false , true } ; int n = arr . length ; alternateSubarray ( arr , n ) ; } }
class GFG { static void alternateSubarray ( boolean arr [ ] , int n ) { int count = 1 ; boolean prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == false ) { while ( count > 0 ) { System . out . print ( count -- + " ▁ " ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { System . out . print ( count -- + " ▁ " ) ; } } public static void main ( String args [ ] ) { boolean arr [ ] = { true , false , true , false , false , true } ; int n = arr . length ; alternateSubarray ( arr , n ) ; } }
public class GFG { static long countWays ( int n ) { long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( " Total ▁ no ▁ of ▁ ways ▁ with ▁ n ▁ = ▁ " + n + " ▁ are : ▁ " + countWays ( n ) ) ; } }
import java . util . * ; class GFG { public static int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 } ; int n = arr . length ; System . out . println ( " Maximum ▁ length ▁ subsequence ▁ = ▁ " + maxLenSub ( arr , n ) ) ; } }
import java . util . Arrays ; public class GFG { static boolean findWinner ( int x , int y , int n ) { boolean [ ] dp = new boolean [ n + 1 ] ; Arrays . fill ( dp , false ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; } public static void main ( String args [ ] ) { int x = 3 , y = 4 , n = 5 ; if ( findWinner ( x , y , n ) == true ) System . out . println ( ' A ' ) ; else System . out . println ( ' B ' ) ; } }
class Max_game_winner { static int maxGameByWinner ( int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; } public static void main ( String args [ ] ) { int N = 10 ; System . out . println ( maxGameByWinner ( N ) ) ; } }
public class Main { static int minRemove ( int arr [ ] , int n ) { int LIS [ ] = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 6 , 5 , 4 } ; int n = arr . length ; System . out . println ( minRemove ( arr , n ) ) ; } }
public class GFG { static final int MAX = 1000 ; static int maxSubsequenceSubstring ( char x [ ] , char y [ ] , int n , int m ) { int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ; return ans ; } public static void main ( String [ ] args ) { char x [ ] = " ABCD " . toCharArray ( ) ; char y [ ] = " BACDBDCD " . toCharArray ( ) ; int n = x . length , m = y . length ; System . out . println ( maxSubsequenceSubstring ( x , y , n , m ) ) ; } }
import java . util . * ; class GFG { public static int maxSum ( int grid [ ] [ ] , int n ) { int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; } public static void main ( String [ ] args ) { int grid [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 10 } } ; int n = 5 ; System . out . println ( maxSum ( grid , n ) ) ; } }
class Main { static int minInsertionStepToSortArray ( int arr [ ] , int N ) { int [ ] lis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 1 , 4 , 7 , 6 } ; int N = arr . length ; System . out . println ( minInsertionStepToSortArray ( arr , N ) ) ; } }
class GFG { static final int MAX = 1005 ; static int shortestSeq ( char [ ] S , char [ ] T ) { int m = S . length , n = T . length ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = MAX ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = S [ i - 1 ] ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) { if ( T [ k ] == ch ) { break ; } } if ( k == - 1 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } } int ans = dp [ m ] [ n ] ; if ( ans >= MAX ) { ans = - 1 ; } return ans ; } public static void main ( String [ ] args ) { char S [ ] = " babab " . toCharArray ( ) ; char T [ ] = " babba " . toCharArray ( ) ; int m = S . length , n = T . length ; System . out . println ( " Length ▁ of ▁ shortest " + " subsequence ▁ is ▁ : ▁ " + shortestSeq ( S , T ) ) ; } }
import java . util . Arrays ; class GFG { static void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ ] = new int [ n ] ; Arrays . fill ( count_jump , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count_jump [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 } ; int n = arr . length ; countWaysToJump ( arr , n ) ; } }
public class GFG { static int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str . charAt ( i ) == str . charAt ( K ) ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; } public static void main ( String args [ ] ) { String str = "2553432" ; System . out . println ( minStepToDeleteString ( str ) ) ; } }
import java . io . * ; class GFG { static int inf = 1000000000 ; static int ans = inf ; static void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; } public static void main ( String [ ] args ) { int k = 2 ; int a [ ] = { 1 , 5 , 8 , 10 } ; int n = a . length ; solve ( - 1 , 0 , a , n , k , 0 ) ; System . out . println ( ans ) ; } }
import java . io . * ; class GFG { static int getMinSteps ( int n , int memo [ ] ) { if ( n == 1 ) return 0 ; if ( memo [ n ] != - 1 ) return memo [ n ] ; int res = getMinSteps ( n - 1 , memo ) ; if ( n % 2 == 0 ) res = Math . min ( res , getMinSteps ( n / 2 , memo ) ) ; if ( n % 3 == 0 ) res = Math . min ( res , getMinSteps ( n / 3 , memo ) ) ; memo [ n ] = 1 + res ; return memo [ n ] ; } static int getMinSteps ( int n ) { int memo [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) memo [ i ] = - 1 ; return getMinSteps ( n , memo ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( getMinSteps ( n ) ) ; } }
public class GFG { static int stringReduction ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; ++ i ) { count [ str . charAt ( i ) - ' a ' ] ++ ; } if ( count [ 0 ] == n count [ 1 ] == n count [ 2 ] == n ) { return n ; } if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) { return 2 ; } return 1 ; } public static void main ( String [ ] args ) { String str = " abcbbaacb " ; System . out . println ( stringReduction ( str ) ) ; } }
public class No_of_subsequence { static int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' a ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s . charAt ( i ) == ' b ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s . charAt ( i ) == ' c ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; } public static void main ( String args [ ] ) { String s = " abbc " ; System . out . println ( countSubsequences ( s ) ) ; } }
class GFG { static int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) { int [ ] maxRev = new int [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; } public static void main ( String [ ] args ) { int m = 20 ; int [ ] x = new int [ ] { 6 , 7 , 12 , 13 , 14 } ; int [ ] revenue = new int [ ] { 5 , 6 , 5 , 3 , 1 } ; int n = x . length ; int t = 5 ; System . out . println ( maxRevenue ( m , x , revenue , n , t ) ) ; } }
class GFG { static int Row = 6 , Col = 6 ; static int largestKSubmatrix ( int [ ] [ ] a ) { int [ ] [ ] dp = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; } public static void main ( String [ ] args ) { int [ ] [ ] a = { { 2 , 2 , 3 , 3 , 4 , 4 } , { 5 , 5 , 7 , 7 , 7 , 4 } , { 1 , 2 , 7 , 7 , 7 , 4 } , { 4 , 4 , 7 , 7 , 7 , 4 } , { 5 , 5 , 5 , 1 , 2 , 7 } , { 8 , 7 , 9 , 4 , 4 , 4 } } ; System . out . println ( largestKSubmatrix ( a ) ) ; } }
class GFG { public static double fact [ ] ; public static double probability ( int k , int n ) { double ans = 0 ; for ( int i = k ; i <= n ; ++ i ) ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) ; ans = ans / ( 1 << n ) ; return ans ; } public static void precompute ( ) { fact [ 0 ] = fact [ 1 ] = 1 ; for ( int i = 2 ; i < 20 ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; } public static void main ( String [ ] args ) { fact = new double [ 100 ] ; precompute ( ) ; System . out . println ( probability ( 2 , 3 ) ) ; System . out . println ( probability ( 3 , 6 ) ) ; System . out . println ( probability ( 12 , 18 ) ) ; } }
class GFG { static int countStrings ( int n , int k ) { int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; System . out . println ( countStrings ( n , k ) ) ; } }
class GFG { static int [ ] dp = new int [ 1000 ] ; static int countFriendsPairings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 1000 ; i ++ ) dp [ i ] = - 1 ; int n = 4 ; System . out . println ( countFriendsPairings ( n ) ) ; } }
import java . io . * ; class GFG { static int N = 3 ; static int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; } public static void main ( String [ ] args ) { int tri [ ] [ ] = { { 1 , 0 , 0 } , { 4 , 8 , 0 } , { 1 , 5 , 3 } } ; System . out . println ( maxPathSum ( tri , 2 , 2 ) ) ; } }
class GFG { static String X = " AGGT12" ; static String Y = "12TXAYB " ; static String Z = "12XBA " ; static int [ ] [ ] [ ] dp = new int [ 100 ] [ 100 ] [ 100 ] ; static int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 j == - 1 k == - 1 ) { return 0 ; } if ( dp [ i ] [ j ] [ k ] != - 1 ) { return dp [ i ] [ j ] [ k ] ; } if ( X . charAt ( i ) == Y . charAt ( j ) && Y . charAt ( j ) == Z . charAt ( k ) ) { return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; } else { return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; } } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 100 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { for ( int k = 0 ; k < 100 ; k ++ ) { dp [ i ] [ j ] [ k ] = - 1 ; } } } int m = X . length ( ) ; int n = Y . length ( ) ; int o = Z . length ( ) ; System . out . print ( " Length ▁ of ▁ LCS ▁ is ▁ " + lcsOf3 ( m - 1 , n - 1 , o - 1 ) ) ; } }
import java . io . * ; class GFG { static int R = 4 ; static int C = 4 ; static int countPaths ( int maze [ ] [ ] ) { if ( maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; } public static void main ( String [ ] args ) { int maze [ ] [ ] = { { 0 , 0 , 0 , 0 } , { 0 , - 1 , 0 , 0 } , { - 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; System . out . println ( countPaths ( maze ) ) ; } }
class GFG { static final int N = 4 ; static int maxDecimalValue ( int mat [ ] [ ] , int i , int j , int p ) { if ( i >= N j >= N ) { return 0 ; } int result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) { return ( int ) ( Math . pow ( 2 , p ) + result ) ; } else { return result ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; System . out . println ( maxDecimalValue ( mat , 0 , 0 , 0 ) ) ; } }
public class GFG { static int CountPS ( char str [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; boolean P [ ] [ ] = new boolean [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { String str = " abaab " ; System . out . println ( CountPS ( str . toCharArray ( ) , str . length ( ) ) ) ; } }
import java . io . * ; class GFG { static int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 100 , 1000 , 100 , 1000 , 1 } ; int n = arr . length ; System . out . println ( maxSumWO3Consec ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = arr . length ; int K = 4 ; System . out . println ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) ; } }
class GFG { public static int lucas ( int n ) { if ( n == 0 ) return 2 ; if ( n == 1 ) return 1 ; return lucas ( n - 1 ) + lucas ( n - 2 ) ; } public static void main ( String args [ ] ) { int n = 9 ; System . out . println ( lucas ( n ) ) ; } }
import java . io . * ; class GFG { static int breakSum ( int n ) { if ( n == 0 n == 1 ) return n ; return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( breakSum ( n ) ) ; } }
public class GFG { static int countPS ( String str ) { int N = str . length ( ) ; int [ ] [ ] cps = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( str . charAt ( i ) == str . charAt ( k ) ) { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; } else { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; } public static void main ( String args [ ] ) { String str = " abcb " ; System . out . println ( " Total ▁ palindromic ▁ " + " subsequence ▁ are ▁ : ▁ " + countPS ( str ) ) ; } }
class GFG { static int n ; static int [ ] [ ] dp = new int [ 1000 ] [ 1000 ] ; static String str = " abcb " ; static int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 1000 ; i ++ ) for ( int j = 0 ; j < 1000 ; j ++ ) dp [ i ] [ j ] = - 1 ; n = str . length ( ) ; System . out . println ( " Total ▁ palindromic ▁ subsequence " + " are ▁ : ▁ " + countPS ( 0 , n - 1 ) ) ; } }
import java . io . * ; class GFG { static int minimum ( int a , int b , int c ) { return Math . min ( Math . min ( a , b ) , c ) ; } static int findMinSum ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; sum [ 0 ] = arr [ 0 ] ; sum [ 1 ] = arr [ 1 ] ; sum [ 2 ] = arr [ 2 ] ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ; return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 20 , 2 , 10 , 1 } ; int n = arr . length ; System . out . println ( " Min ▁ Sum ▁ is ▁ " + findMinSum ( arr , n ) ) ; } }
import java . util . * ; class GFG { public static int MinimumCost ( int cost [ ] , int n , int W ) { Vector < Integer > val = new Vector < Integer > ( ) ; Vector < Integer > wt = new Vector < Integer > ( ) ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . add ( cost [ i ] ) ; wt . add ( i + 1 ) ; size ++ ; } } n = size ; int min_cost [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) min_cost [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt . get ( i - 1 ) > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt . get ( i - 1 ) ] + val . get ( i - 1 ) ) ; } } return ( min_cost [ n ] [ W ] == Integer . MAX_VALUE ) ? - 1 : min_cost [ n ] [ W ] ; } public static void main ( String [ ] args ) { int cost [ ] = { 1 , 2 , 3 , 4 , 5 } , W = 5 ; int n = cost . length ; System . out . println ( MinimumCost ( cost , n , W ) ) ; } }
import java . io . * ; class GFG { static int count ( String a , String b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; } public static void main ( String [ ] args ) { String a = " GeeksforGeeks " ; String b = " Gks " ; System . out . println ( count ( a , b , a . length ( ) , b . length ( ) ) ) ; } }
import java . io . * ; class GFG { static int lcs ( String X , String Y , int m , int n ) { int L [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } static int findMinCost ( String X , String Y , int costX , int costY ) { int m = X . length ( ) ; int n = Y . length ( ) ; int len_LCS ; len_LCS = lcs ( X , Y , m , n ) ; return costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ; } public static void main ( String [ ] args ) { String X = " ef " ; String Y = " gh " ; System . out . println ( " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ " + " ▁ identical ▁ is ▁ = ▁ " + findMinCost ( X , Y , 10 , 20 ) ) ; } }
import java . io . * ; class GFG { static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countIntegralSolutions ( n ) ) ; } }
import java . io . * ; class GFG { static int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countIntegralSolutions ( n ) ) ; } }
import java . util . * ; class GFG { static int maxLeftSubArraySum ( int a [ ] , int size , int sum [ ] ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; sum [ 0 ] = max_so_far ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; sum [ i ] = max_so_far ; } return max_so_far ; } static int maxRightSubArraySum ( int a [ ] , int n , int sum [ ] ) { int max_so_far = a [ n ] ; int curr_max = a [ n ] ; sum [ n ] = max_so_far ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; sum [ i ] = max_so_far ; } return max_so_far ; } static int findMaxAbsDiff ( int arr [ ] , int n ) { int leftMax [ ] = new int [ n ] ; maxLeftSubArraySum ( arr , n , leftMax ) ; int rightMax [ ] = new int [ n ] ; maxRightSubArraySum ( arr , n - 1 , rightMax ) ; int invertArr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) invertArr [ i ] = - arr [ i ] ; int leftMin [ ] = new int [ n ] ; maxLeftSubArraySum ( invertArr , n , leftMin ) ; for ( int i = 0 ; i < n ; i ++ ) leftMin [ i ] = - leftMin [ i ] ; int rightMin [ ] = new int [ n ] ; maxRightSubArraySum ( invertArr , n - 1 , rightMin ) ; for ( int i = 0 ; i < n ; i ++ ) rightMin [ i ] = - rightMin [ i ] ; int result = - 2147483648 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int absValue = Math . max ( Math . abs ( leftMax [ i ] - rightMin [ i + 1 ] ) , Math . abs ( leftMin [ i ] - rightMax [ i + 1 ] ) ) ; if ( absValue > result ) result = absValue ; } return result ; } public static void main ( String [ ] args ) { int a [ ] = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = a . length ; System . out . print ( findMaxAbsDiff ( a , n ) ) ; } }
class GFG { static int countWays ( int p , int q , int r , int last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( last == 0 ) return countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; if ( last == 1 ) return countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; if ( last == 2 ) return countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return 0 ; } static int countUtil ( int p , int q , int r ) { } public static void main ( String [ ] args ) { int p = 1 , q = 1 , r = 1 ; System . out . print ( countUtil ( p , q , r ) ) ; } }
import java . io . * ; class GFG { public static int countP ( int n , int k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; } public static void main ( String args [ ] ) { System . out . println ( countP ( 3 , 2 ) ) ; } }
class GFG { static int countP ( int n , int k ) { int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; } public static void main ( String [ ] args ) { System . out . println ( countP ( 5 , 2 ) ) ; } }
import java . io . * ; class GFG { static int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; } public static void main ( String [ ] args ) { int dist = 4 ; System . out . println ( printCountRec ( dist ) ) ; } }
import java . io . * ; class GFG { static int countNumbersWith4 ( int n ) { int result = 0 ; for ( int x = 1 ; x <= n ; x ++ ) result += has4 ( x ) ? 1 : 0 ; return result ; } static boolean has4 ( int x ) { while ( x != 0 ) { if ( x % 10 == 4 ) return true ; x = x / 10 ; } return false ; } public static void main ( String args [ ] ) { int n = 328 ; System . out . println ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ a ▁ digit ▁ is ▁ " + countNumbersWith4 ( n ) ) ; } }
class GFG { static int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = ( int ) Math . log10 ( n ) ; int [ ] a = new int [ d + 2 ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ( int ) Math . ceil ( Math . pow ( 10 , i - 1 ) ) ; int p = ( int ) Math . ceil ( Math . pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; } public static void main ( String [ ] args ) { int n = 328 ; System . out . println ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + n + " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is ▁ " + countNumbersWith4 ( n ) ) ; } }
class GFG { static int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) { min = val ; } if ( val > max ) { max = val ; } if ( 2 * min <= max ) { break ; } if ( end - start > longest_end - longest_start longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) { return n ; } return ( n - ( longest_end - longest_start + 1 ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 } ; int n = arr . length ; System . out . println ( minRemovalsDP ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int optimalStrategyOfGame ( int arr [ ] , int n ) { int table [ ] [ ] = new int [ n ] [ n ] ; int gap , i , j , x , y , z ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 8 , 15 , 3 , 7 } ; int n = arr1 . length ; System . out . println ( " " + optimalStrategyOfGame ( arr1 , n ) ) ; int arr2 [ ] = { 2 , 2 , 2 , 2 } ; n = arr2 . length ; System . out . println ( " " + optimalStrategyOfGame ( arr2 , n ) ) ; int arr3 [ ] = { 20 , 30 , 2 , 2 , 2 , 10 } ; n = arr3 . length ; System . out . println ( " " + optimalStrategyOfGame ( arr3 , n ) ) ; } }
class GFG { static int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = arr . length ; System . out . println ( " Sum ▁ of ▁ maximum ▁ sum ▁ " + " increasing ▁ subsequence ▁ is ▁ " + maxSumIS ( arr , n ) ) ; } }
class GfG { static boolean endsWith ( String str , String pat ) { int patLen = pat . length ( ) ; int strLen = str . length ( ) ; if ( patLen > strLen ) return false ; patLen -- ; strLen -- ; while ( patLen >= 0 ) { if ( pat . charAt ( patLen ) != str . charAt ( strLen ) ) return false ; patLen -- ; strLen -- ; } return true ; } static int countOfStrings ( String pat , int n , String sArr [ ] ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( endsWith ( sArr [ i ] , pat ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { String pat = " ks " ; int n = 4 ; String sArr [ ] = { " geeks " , " geeksforgeeks " , " games " , " unit " } ; System . out . println ( countOfStrings ( pat , n , sArr ) ) ; } }
class GFG { static int getEndingIndex ( String str , int n , int i ) { i ++ ; while ( i < n ) { char curr = str . charAt ( i ) ; char prev = str . charAt ( i - 1 ) ; if ( ( curr == ' a ' && prev == ' z ' ) || ( curr - prev == 1 ) ) i ++ ; else break ; } return i - 1 ; } static int largestSubStr ( String str , int n ) { int len = 0 ; int i = 0 ; while ( i < n ) { int end = getEndingIndex ( str , n , i ) ; len = Math . max ( end - i + 1 , len ) ; i = end + 1 ; } return len ; } public static void main ( String args [ ] ) { String str = " abcabcdefabc " ; int n = str . length ( ) ; System . out . print ( largestSubStr ( str , n ) ) ; } }
import java . io . * ; class GFG { static long getSum ( long n , int d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; long k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; } public static void main ( String [ ] args ) { long n = 30 ; int d = 3 ; System . out . println ( getSum ( n , d ) ) ; } }
import java . io . * ; class GFG { static int replace ( String A , String B ) { int n = A . length ( ) , m = B . length ( ) ; int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( i + j >= n ) break ; else if ( A . charAt ( i + j ) != B . charAt ( j ) ) break ; } if ( j == m ) { count ++ ; i += m - 1 ; } } return count ; } public static void main ( String args [ ] ) { String str1 = " aaaaaaaa " ; String str2 = " aaa " ; System . out . println ( replace ( str1 , str2 ) ) ; } }
class GFG { static int isSubstring ( String s1 , String s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 . charAt ( i + j ) != s1 . charAt ( j ) ) break ; if ( j == M ) return i ; } return - 1 ; } public static void main ( String args [ ] ) { String s1 = " for " ; String s2 = " geeksforgeeks " ; int res = isSubstring ( s1 , s2 ) ; if ( res == - 1 ) System . out . println ( " Not ▁ present " ) ; else System . out . println ( " Present ▁ at ▁ index ▁ " + res ) ; } }
import java . io . * ; class GFG { static int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; } public static void main ( String [ ] args ) { String str = "1001ab010abc01001" ; System . out . println ( patternCount ( str ) ) ; } }
public class GFG { static int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == s . length ( ) ) break ; if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ; } return count ; } public static void main ( String args [ ] ) { String S = " digger " ; String T = " biggerdiagram " ; System . out . println ( maxPrefix ( S , T ) ) ; } }
import java . io . * ; class GFG { static void translate ( char str [ ] ) { for ( int i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; int j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ▁ ' ; } } return ; } public static void main ( String args [ ] ) { String st = " helloABworldABGfG " ; char str [ ] = st . toCharArray ( ) ; translate ( str ) ; System . out . println ( " The ▁ modified ▁ string ▁ is ▁ : " ) ; System . out . println ( str ) ; } }
public class GFG { public static final int NUM = 31 ; static void positions ( String str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ( str . charAt ( i ) & NUM ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { String str = " Geeks " ; int n = str . length ( ) ; positions ( str , n ) ; } }
import java . util . Arrays ; import java . lang . Math ; class GFG { public static int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . toCharArray ( ) ; for ( int i = 0 ; i < new_str . length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; } public static void main ( String [ ] args ) { String s = " synapse " ; System . out . println ( lenoflongestnonpalindrome ( s ) ) ; } }
class GFG { static String makePalindrome ( char [ ] str ) { int i = 0 , j = str . length - 1 ; while ( i <= j ) { if ( str [ i ] == ' * ' && str [ j ] == ' * ' ) { str [ i ] = ' a ' ; str [ j ] = ' a ' ; } else if ( str [ j ] == ' * ' ) str [ j ] = str [ i ] ; else if ( str [ i ] == ' * ' ) str [ i ] = str [ j ] ; else if ( str [ i ] != str [ j ] ) return " - 1" ; i ++ ; j -- ; } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { char [ ] str = " na * an " . toCharArray ( ) ; System . out . println ( makePalindrome ( str ) ) ; } }
class GFG { public static int calcScore ( String str ) { int score = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; ) { int chunkSize = 1 ; char currentChar = str . charAt ( i ++ ) ; while ( i < len && str . charAt ( i ) == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == '1' ) score += Math . pow ( chunkSize , 2 ) ; else score -= Math . pow ( chunkSize , 2 ) ; } return score ; } public static void main ( String [ ] args ) { String str = "11011" ; System . out . println ( calcScore ( str ) ) ; } }
class GFG { static int countSubString ( char [ ] s , char c , int k ) { int leftCount = 0 , rightCount = 0 ; int left = 0 , right = 0 ; int freq = 0 ; int result = 0 , len = s . length ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; } public static void main ( String [ ] args ) { String s = " abada " ; char c = ' a ' ; int k = 2 ; System . out . println ( countSubString ( s . toCharArray ( ) , c , k ) ) ; } }
import java . util . * ; class GFG { static boolean isValid ( String str , int n ) { if ( ! ( ( str . charAt ( 0 ) >= ' a ' && str . charAt ( 0 ) <= ' z ' ) || ( str . charAt ( 0 ) >= ' A ' && str . charAt ( 0 ) <= ' Z ' ) || str . charAt ( 0 ) == ' _ ' ) ) return false ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( ! ( ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) || ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) || ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) || str . charAt ( i ) == ' _ ' ) ) return false ; } return true ; } public static void main ( String args [ ] ) { String str = " _ geeks123" ; int n = str . length ( ) ; if ( isValid ( str , n ) ) System . out . println ( " Valid " ) ; else System . out . println ( " Invalid " ) ; } }
class GFG { static String FirstAndLast ( String str ) { char [ ] ch = str . toCharArray ( ) ; for ( int i = 0 ; i < ch . length ; i ++ ) { int k = i ; while ( i < ch . length && ch [ i ] != ' ▁ ' ) i ++ ; ch [ k ] = ( char ) ( ch [ k ] >= ' a ' && ch [ k ] <= ' z ' ? ( ( int ) ch [ k ] - 32 ) : ( int ) ch [ k ] ) ; ch [ i - 1 ] = ( char ) ( ch [ i - 1 ] >= ' a ' && ch [ i - 1 ] <= ' z ' ? ( ( int ) ch [ i - 1 ] - 32 ) : ( int ) ch [ i - 1 ] ) ; } return new String ( ch ) ; } public static void main ( String args [ ] ) { String str = " Geeks ▁ for ▁ Geeks " ; System . out . println ( str ) ; System . out . println ( FirstAndLast ( str ) ) ; } }
import java . util . * ; class GFG { static int findM ( String s , int x ) { int cnt = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) - '0' != x ) cnt ++ ; } return cnt ; } public static void main ( String args [ ] ) { String s = "3662123" ; int x = 6 ; System . out . println ( findM ( s , x ) ) ; } }
class GFG { static int [ ] compute_lps ( String s ) { int n = s . length ( ) ; int [ ] lps = new int [ n ] ; int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else { lps [ i ] = 0 ; i ++ ; } } } return lps ; } static void Longestsubstring ( String s ) { int [ ] lps = compute_lps ( s ) ; int n = s . length ( ) ; if ( lps [ n - 1 ] == 0 ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { System . out . println ( s . substring ( 0 , lps [ i ] ) ) ; return ; } } if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) System . out . println ( - 1 ) ; else System . out . println ( s . substring ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ) ; } public static void main ( String [ ] args ) { String s = " fixprefixsuffix " ; Longestsubstring ( s ) ; } }
class GFG { static int MAX = 64 ; static int getBitmask ( char [ ] s ) { int temp = 0 ; for ( int j = 0 ; j < s . length ; j ++ ) { switch ( s [ j ] ) { case ' s ' : temp = temp | ( 1 ) ; break ; case ' t ' : temp = temp | ( 2 ) ; break ; case ' r ' : temp = temp | ( 4 ) ; break ; case ' i ' : temp = temp | ( 8 ) ; break ; case ' n ' : temp = temp | ( 16 ) ; break ; case ' g ' : temp = temp | ( 32 ) ; break ; default : break ; } } return temp ; } static int countPairs ( String arr [ ] , int n ) { int [ ] bitMask = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) bitMask [ getBitmask ( arr [ i ] . toCharArray ( ) ) ] ++ ; int cnt = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i ; j < MAX ; j ++ ) { if ( ( i j ) == ( MAX - 1 ) ) { if ( i == j ) cnt += ( ( bitMask [ i ] * bitMask [ i ] - 1 ) / 2 ) ; else cnt += ( bitMask [ i ] * bitMask [ j ] ) ; } } } return cnt ; } public static void main ( String [ ] args ) { String arr [ ] = { " strrr " , " string " , " gstrin " } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
class GFG { static int countOcc ( String s ) { int cnt = 0 ; for ( int i = 0 ; i < s . length ( ) - 3 ; i ++ ) { int c = 0 , l = 0 , a = 0 , p = 0 ; for ( int j = i ; j < i + 4 ; j ++ ) { switch ( s . charAt ( j ) ) { case ' c ' : c ++ ; break ; case ' l ' : l ++ ; break ; case ' a ' : a ++ ; break ; case ' p ' : p ++ ; break ; } } if ( c == 1 && l == 1 && a == 1 && p == 1 ) cnt ++ ; } return cnt ; } public static void main ( String args [ ] ) { String s = " clapc " ; System . out . print ( countOcc ( s . toLowerCase ( ) ) ) ; } }
class GfG { static int calculateWays ( String s , int n , int l , int r ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < l i > r ) freq [ s . charAt ( i ) - ' a ' ] ++ ; } int ways = 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( freq [ s . charAt ( i ) - ' a ' ] != 0 ) { ways = ways * freq [ s . charAt ( i ) - ' a ' ] ; freq [ s . charAt ( i ) - ' a ' ] -- ; } else { ways = 0 ; break ; } } return ways ; } public static void main ( String [ ] args ) { String s = " cabcaab " ; int n = s . length ( ) ; int l = 1 , r = 3 ; System . out . println ( calculateWays ( s , n , l , r ) ) ; } }
class GFG { static void asciiToSentence ( String str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str . charAt ( i ) - '0' ) ; if ( num >= 32 && num <= 122 ) { char ch = ( char ) num ; System . out . print ( ch ) ; num = 0 ; } } } public static void main ( String args [ ] ) { String str = "7110110110711510211111471101101107115" ; int len = str . length ( ) ; asciiToSentence ( str , len ) ; } }
class GFG { static final int arr [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 } ; public static int countKeyPressed ( String str , int len ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) count = count + arr [ str . charAt ( i ) - ' a ' ] ; return count ; } public static void main ( String [ ] args ) { String str = " abcdef " ; int len = str . length ( ) ; System . out . print ( countKeyPressed ( str , len ) ) ; } }
class GFG { static boolean isReverseEqual ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int len = s1 . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) if ( s1 . charAt ( i ) != s2 . charAt ( len - i - 1 ) ) return false ; return true ; } static String getWord ( String str [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isReverseEqual ( str [ i ] , str [ j ] ) ) return str [ i ] ; return " - 1" ; } public static void main ( String [ ] args ) { String str [ ] = { " geeks " , " for " , " skeeg " } ; int n = str . length ; System . out . print ( getWord ( str , n ) ) ; } }
class GFG { static boolean isPrefix ( String str , int len , int i , int k ) { if ( i + k > len ) return false ; for ( int j = 0 ; j < k ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; } return true ; } static boolean isKPeriodic ( String str , int len , int k ) { for ( int i = k ; i < len ; i += k ) if ( ! isPrefix ( str , len , i , k ) ) return false ; return true ; } public static void main ( String [ ] args ) { String str = " geeksgeeks " ; int len = str . length ( ) ; int k = 5 ; if ( isKPeriodic ( str , len , k ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; } public static void main ( String args [ ] ) { int n = 52 ; System . out . print ( minLettersNeeded ( n ) ) ; } }
class GFG { static int minReplacement ( String s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) == '1' ) ans ++ ; if ( i % 2 == 1 && s . charAt ( i ) == '0' ) ans ++ ; } return Math . min ( ans , len - ans ) ; } public static void main ( String args [ ] ) { String s = "1100" ; int len = s . length ( ) ; System . out . print ( minReplacement ( s , len ) ) ; } }
class GFG { static String groupCharacters ( char [ ] s , int len ) { String temp = " " ; for ( int i = 0 ; i < len ; i ++ ) if ( s [ i ] != ' ▁ ' ) temp = temp + s [ i ] ; len = temp . length ( ) ; String ans = " " ; int i = 0 ; while ( i < len ) { if ( temp . charAt ( i ) >= ( ' A ' ) && temp . charAt ( i ) <= ( ' Z ' ) ) { while ( i < len && temp . charAt ( i ) >= ( ' A ' ) && temp . charAt ( i ) <= ( ' Z ' ) ) { ans = ans + temp . charAt ( i ) ; i ++ ; } ans = ans + " ▁ " ; } else if ( temp . charAt ( i ) >= ( '0' ) && temp . charAt ( i ) <= ( '9' ) ) { while ( i < len && temp . charAt ( i ) >= ( '0' ) && temp . charAt ( i ) <= ( '9' ) ) { ans = ans + temp . charAt ( i ) ; i ++ ; } ans = ans + " ▁ " ; } else { while ( i < len && temp . charAt ( i ) >= ( ' * ' ) && temp . charAt ( i ) <= ( ' / ' ) ) { ans = ans + temp . charAt ( i ) ; i ++ ; } ans = ans + " ▁ " ; } } return ans ; } public static void main ( String [ ] args ) { String s = "34FTG234 + ▁ + - ▁ * " ; int len = s . length ( ) ; System . out . print ( groupCharacters ( s . toCharArray ( ) , len ) ) ; } }
import java . util . * ; class GFG { static int Preprocess ( String A , String B ) { int n = A . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { HashMap < Character , Integer > mp = new HashMap < > ( ) ; if ( mp . containsKey ( A . charAt ( i ) ) ) mp . put ( A . charAt ( i ) , mp . get ( A . charAt ( i ) ) + 1 ) ; else mp . put ( A . charAt ( i ) , 1 ) ; if ( mp . containsKey ( A . charAt ( n - i - 1 ) ) ) mp . put ( A . charAt ( n - i - 1 ) , mp . get ( A . charAt ( n - i - 1 ) ) + 1 ) ; else mp . put ( A . charAt ( n - i - 1 ) , 1 ) ; if ( mp . containsKey ( B . charAt ( i ) ) ) mp . put ( B . charAt ( i ) , mp . get ( B . charAt ( i ) ) + 1 ) ; else mp . put ( B . charAt ( i ) , 1 ) ; if ( mp . containsKey ( B . charAt ( n - i - 1 ) ) ) mp . put ( B . charAt ( n - i - 1 ) , mp . get ( B . charAt ( n - i - 1 ) ) + 1 ) ; else mp . put ( B . charAt ( n - i - 1 ) , 1 ) ; int sz = mp . size ( ) ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A . charAt ( i ) == A . charAt ( n - i - 1 ) ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp . get ( A . charAt ( i ) ) != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A . charAt ( n / 2 ) != B . charAt ( n / 2 ) ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { String A = " abacaba " , B = " bacabaa " ; System . out . println ( Preprocess ( A , B ) ) ; } }
class GfG { static String leastLexiString ( String s ) { if ( s . length ( ) == 1 ) return s ; String x = leastLexiString ( s . substring ( 0 , s . length ( ) / 2 ) ) ; String y = leastLexiString ( s . substring ( s . length ( ) / 2 ) ) ; return String . valueOf ( ( x + y ) . compareTo ( y + x ) ) ; } static boolean areEquivalent ( String a , String b ) { return ! ( leastLexiString ( a ) . equals ( leastLexiString ( b ) ) ) ; } public static void main ( String [ ] args ) { String a = " aaba " ; String b = " abaa " ; if ( areEquivalent ( a , b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; a = " aabb " ; b = " abab " ; if ( areEquivalent ( a , b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static void generateString ( int A , int B ) { String rt = " " ; while ( 0 < A 0 < B ) { if ( A < B ) { if ( 0 < B -- ) { rt += ( ' b ' ) ; } if ( 0 < B -- ) { rt += ( ' b ' ) ; } if ( 0 < A -- ) { rt += ( ' a ' ) ; } } else if ( B < A ) { if ( 0 < A -- ) { rt += ( ' a ' ) ; } if ( 0 < A -- ) { rt += ( ' a ' ) ; } if ( 0 < B -- ) { rt += ( ' b ' ) ; } } else { if ( 0 < A -- ) { rt += ( ' a ' ) ; } if ( 0 < B -- ) { rt += ( ' b ' ) ; } } } System . out . println ( rt ) ; } public static void main ( String [ ] args ) { int A = 2 , B = 6 ; generateString ( A , B ) ; } }
class GFG { static String getSubSeq ( String s , int n ) { String res = " " ; int cr = 0 ; while ( cr < n ) { char mx = s . charAt ( cr ) ; for ( int i = cr + 1 ; i < n ; i ++ ) { mx = ( char ) Math . max ( mx , s . charAt ( i ) ) ; } int lst = cr ; for ( int i = cr ; i < n ; i ++ ) { if ( s . charAt ( i ) == mx ) { res += s . charAt ( i ) ; lst = i ; } } cr = lst + 1 ; } return res ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; int n = s . length ( ) ; System . out . println ( getSubSeq ( s , n ) ) ; } }
class GFG { static int countSubStr ( String str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str . charAt ( j ) - '0' ) ; if ( n % k == 0 ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { String str = "33445" ; int len = str . length ( ) ; int k = 11 ; System . out . println ( countSubStr ( str , len , k ) ) ; } }
class GfG { static char Colour_Combination ( String s ) { char temp = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( temp != s . charAt ( i ) ) { if ( ( temp == ' B ' temp == ' G ' ) && ( s . charAt ( i ) == ' G ' || s . charAt ( i ) == ' B ' ) ) temp = ' Y ' ; else if ( ( temp == ' B ' temp == ' Y ' ) && ( s . charAt ( i ) == ' Y ' || s . charAt ( i ) == ' B ' ) ) temp = ' G ' ; else temp = ' B ' ; } } return temp ; } public static void main ( String [ ] args ) { String s = " GBYGB " ; System . out . println ( Colour_Combination ( s ) ) ; } }
class GfG { static void reverse ( String str , int x ) { int n = ( str . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x - 1 ; i >= n ; i -- ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x ; i < str . length ( ) ; i ++ ) System . out . print ( str . charAt ( i ) ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int x = 3 ; reverse ( str , x ) ; } }
class GFG { static int getSteps ( String str , int i , int j , int n ) { int k = i + 1 ; int steps = 0 ; char ch = str . charAt ( i ) ; while ( k <= j ) { if ( str . charAt ( k ) != ch ) { steps ++ ; ch = str . charAt ( k ) ; } k ++ ; } return steps ; } static int getMinSteps ( String str , int i , int j , int n ) { if ( j < i ) { int temp = i ; i = j ; j = temp ; } int stepsToRight = getSteps ( str , i , j , n ) ; int stepsToLeft = getSteps ( str , 0 , i , n ) + getSteps ( str , j , n - 1 , n ) ; if ( str . charAt ( 0 ) != str . charAt ( n - 1 ) ) stepsToLeft ++ ; return Math . min ( stepsToLeft , stepsToRight ) ; } public static void main ( String [ ] args ) { String str = " SSNSS " ; int n = str . length ( ) ; int i = 0 , j = 3 ; System . out . println ( getMinSteps ( str , i , j , n ) ) ; } }
class GFG { static String removeChars ( String s ) { String modifiedStr = " " ; modifiedStr += s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( Character . isUpperCase ( s . charAt ( i ) ) && Character . isLowerCase ( s . charAt ( i - 1 ) ) || Character . isLowerCase ( s . charAt ( i ) ) && Character . isUpperCase ( s . charAt ( i - 1 ) ) ) modifiedStr += s . charAt ( i ) ; } return modifiedStr ; } public static void main ( String [ ] args ) { String s = " GeeksForGeeks " ; System . out . println ( removeChars ( s ) ) ; } }
class GFG { static int pangramCost ( int arr [ ] , String str ) { int cost = 0 ; boolean [ ] occurred = new boolean [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) occurred [ i ] = false ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) occurred [ str . charAt ( i ) - ' a ' ] = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( occurred [ i ] == false ) cost += arr [ i ] ; } return cost ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 } ; String str = " abcdefghijklmopqrstuvwz " ; System . out . println ( pangramCost ( arr , str ) ) ; } }
class GFG { static String output = " " ; static void pairStar ( String input , int i ) { output = output + input . charAt ( i ) ; if ( i == input . length ( ) - 1 ) return ; if ( input . charAt ( i ) == input . charAt ( i + 1 ) ) output = output + ' * ' ; pairStar ( input , i + 1 ) ; } public static void main ( String [ ] args ) { String input = " geeks " ; pairStar ( input , 0 ) ; System . out . println ( output ) ; } }
class GFG { static int maxOperations ( String str ) { int i , g , gk , gks ; i = g = gk = gks = 0 ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' g ' ) { g ++ ; } else if ( str . charAt ( i ) == ' k ' ) { if ( g > 0 ) { g -- ; gk ++ ; } } else if ( str . charAt ( i ) == ' s ' ) { if ( gk > 0 ) { gk -- ; gks ++ ; } } } return gks ; } public static void main ( String args [ ] ) { String a = " ggkssk " ; System . out . print ( maxOperations ( a ) ) ; } }
class GFG { static String printFinalString ( String s ) { int i , n ; n = s . length ( ) ; int x = 0 , y = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' x ' ) { x ++ ; else { y ++ ; } } String finalString = " " ; if ( x > y ) { for ( i = 0 ; i < x - y ; i ++ ) { finalString += " x " ; } } else { for ( i = 0 ; i < y - x ; i ++ ) { finalString += " y " ; } } return finalString ; } public static void main ( String args [ ] ) { String s = " xxyyxyy " ; System . out . println ( printFinalString ( s ) ) ; } }
class GfG { static String K_String ( String s , int k ) { int n = s . length ( ) ; int fre [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) fre [ s . charAt ( i ) - ' a ' ] ++ ; String str = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( fre [ i ] % k == 0 ) { int x = fre [ i ] / k ; while ( x != 0 ) { str += ( char ) ( i + ' a ' ) ; x -- ; } } else { return " - 1" ; } } return str ; } public static void main ( String [ ] args ) { String s = " aabb " ; int k = 2 ; System . out . println ( K_String ( s , k ) ) ; } }
import java . util . * ; class Solution { static int CountCharacters ( String str , int l , int r ) { int cnt = 0 ; Map < Character , Integer > m = new HashMap < Character , Integer > ( ) ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str . charAt ( i ) && str . charAt ( i ) <= r ) ) { cnt ++ ; if ( m . get ( str . charAt ( i ) ) != null ) if ( m . get ( str . charAt ( i ) ) != 1 ) { System . out . print ( str . charAt ( i ) + " ▁ " ) ; m . put ( str . charAt ( i ) , m . get ( str . charAt ( i ) ) == null ? 0 : m . get ( str . charAt ( i ) ) + 1 ) ; } } } return cnt ; } public static void main ( String args [ ] ) { String str = " geeksforgeeks " ; int l = 102 , r = 111 ; System . out . println ( "Characters with ASCII values not in the range [l, r]  in the given string are : "); System . out . println ( " and their count is " + CountCharacters(str, l, r)); } }
class GFG { static void CountWords ( String str , int k ) { int sum = 0 ; int NumberOfWords = 0 ; int counter = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { if ( str . charAt ( i ) == ' ▁ ' ) { if ( sum < k ) { counter ++ ; } sum = 0 ; NumberOfWords ++ ; } { sum += str . charAt ( i ) ; } } NumberOfWords ++ ; if ( sum < k ) { counter ++ ; } System . out . println ( " Number ▁ of ▁ words ▁ having ▁ sum ▁ " + " of ▁ ASCII ▁ values ▁ less ▁ than ▁ k ▁ = ▁ " + counter ) ; System . out . println ( " Number ▁ of ▁ words ▁ having ▁ sum ▁ of ▁ " + " ASCII ▁ values ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ k ▁ = ▁ " + ( NumberOfWords - counter ) ) ; } public static void main ( String [ ] args ) { String str = " Learn ▁ how ▁ to ▁ code " ; int k = 400 ; CountWords ( str , k ) ; } }
class GFG { final static int MAX_CHAR = 26 ; static int countPalindrome ( String str ) { int n = str . length ( ) ; int sum = 0 ; int hashTable [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { hashTable [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( hashTable [ i ] != 0 ) { sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) / 2 ) ; } } return sum ; } public static void main ( String [ ] args ) { String str = " ananananddd " ; System . out . println ( countPalindrome ( str ) ) ; } }
class GFG { static int countConsecutive ( String s ) { int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { i ++ ; } else { count ++ ; } } return count ; } public static void main ( String args [ ] ) { String str = "44522255" ; System . out . println ( countConsecutive ( str ) ) ; } }
class Geeks { static int check_digits ( int n ) { while ( n > 0 ) { return 0 ; n /= 10 ; } return 1 ; } static int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) > 0 ) return i ; } public static void main ( String args [ ] ) { int N = 2397 ; System . out . println ( smallest_number ( N ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static int CountCharacters ( String str , int l , int r ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( l <= str . charAt ( i ) && str . charAt ( i ) <= r ) { cnt ++ ; System . out . print ( str . charAt ( i ) + " ▁ " ) ; } } return cnt ; } public static void main ( String args [ ] ) { String str = " geeksforgeeks " ; int l = 102 , r = 111 ; System . out . print ( " Characters ▁ with ▁ ASCII ▁ values " + " in the range [l, r] are NEW_LINE"); System . out . print ( " and their count is " + CountCharacters ( str , l , r ) ) ; } }
import java . util . * ; class GFG { static int minSteps ( String str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) - 2 ; i ++ ) { if ( ( ( int ) str . charAt ( i ) ) == '0' ) { if ( str . charAt ( i + 1 ) == '1' ) { if ( str . charAt ( i + 2 ) == '0' ) { count ++ ; i += 2 ; } } } } return count ; } public static void main ( String args [ ] ) { String str = "0101010" ; System . out . println ( minSteps ( str ) ) ; } }
import java . util . * ; class GFG { static int CountCharacters ( String str , int k ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( ( int ) str . charAt ( i ) ) < k ) cnt ++ ; } return cnt ; } public static void main ( String args [ ] ) { String str = " GeeksForGeeks " ; int k = 90 ; int count = CountCharacters ( str , k ) ; System . out . println ( " Characters ▁ with ▁ ASCII ▁ values ▁ less ▁ than ▁ K ▁ are ▁ " + count ) ; System . out . println ( " Characters ▁ with ▁ ASCII ▁ values ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ K ▁ are ▁ " + ( str . length ( ) - count ) ) ; } }
class GFG { static int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { f = f * i ; } return f ; } static int npr ( int n , int r ) { return fact ( n ) / fact ( n - r ) ; } static int countPermutations ( String str ) { int even = ( int ) Math . floor ( ( double ) ( str . length ( ) / 2 ) ) ; int odd = str . length ( ) - even ; int ways = 0 ; int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ ( int ) ( str . charAt ( i ) - ' a ' ) ] ++ ; } int nvowels = freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ; int nconsonants = str . length ( ) - nvowels ; ways = npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ; return ways ; } public static void main ( String [ ] args ) { String str = " geeks " ; System . out . println ( countPermutations ( str ) ) ; } }
class GFG { static boolean isVowel ( char ch ) { if ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' ) { return false ; } return true ; } static String replaceConsonants ( char [ ] s ) { for ( int i = 0 ; i < s . length ; i ++ ) { if ( ! isVowel ( s [ i ] ) ) { if ( s [ i ] == ' z ' ) { s [ i ] = ' b ' ; } else { s [ i ] = ( char ) ( s [ i ] + 1 ) ; if ( isVowel ( s [ i ] ) ) { s [ i ] = ( char ) ( s [ i ] + 1 ) ; } } } } return String . valueOf ( s ) ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; System . out . println ( replaceConsonants ( s . toCharArray ( ) ) ) ; } }
import java . io . * ; class GFG { static int countOnOff ( String n ) { int Led [ ] = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 } ; int len = n . length ( ) ; int sum = Led [ n . charAt ( 0 ) - '0' ] ; for ( int i = 1 ; i < len ; i ++ ) { sum = sum + Math . abs ( Led [ n . charAt ( i ) - '0' ] - Led [ n . charAt ( i - 1 ) - '0' ] ) ; } return sum ; } public static void main ( String args [ ] ) { String n = "082" ; System . out . println ( countOnOff ( n ) ) ; } }
class GFG { static int max_length_substring ( String st , int n , int k ) { int max_len = 0 ; int len = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( st . charAt ( i ) == '0' ) len ++ ; else len = 0 ; max_len = Math . max ( max_len , len ) ; } if ( max_len == n ) return n * k ; int pref = 0 , suff = 0 ; for ( int i = 0 ; st . charAt ( i ) == '0' ; ++ i , ++ pref ) ; for ( int i = n - 1 ; st . charAt ( i ) == '0' ; -- i , ++ suff ) ; if ( k > 1 ) max_len = Math . max ( max_len , pref + suff ) ; return max_len ; } public static void main ( String [ ] args ) { int n = 6 ; int k = 3 ; String st = "110010" ; int ans = max_length_substring ( st , n , k ) ; System . out . println ( ans ) ; } }
import java . util . * ; class GFG { static int count ( String S , int X ) { int count = 0 ; int N = S . length ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( S . charAt ( i ) != '0' ) { for ( int len = 1 ; ( i + len ) <= N ; ++ len ) { int num = Integer . parseInt ( S . substring ( i , i + len ) ) ; if ( num > X ) count ++ ; } } } return count ; } public static void main ( String [ ] args ) { String S = "2222" ; int X = 97 ; System . out . println ( count ( S , X ) ) ; } }
import java . util . * ; class Solution { static boolean isBinary ( int n ) { while ( n != 0 ) { int temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = n / 10 ; } return true ; } static void formBinaryStr ( int n , int a [ ] ) { boolean flag = true ; String s = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( isBinary ( a [ i ] ) ) s += " " + a [ i ] ; else { flag = false ; break ; } } if ( flag ) System . out . print ( s + "NEW_LINE"); else System . out . print ( "-1NEW_LINE"); } public static void main ( String args [ ] ) { int a [ ] = { 10 , 1 , 0 , 11 , 10 } ; int N = a . length ; formBinaryStr ( N , a ) ; } }
import java . util . * ; class GFG { static boolean checkPalindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) return false ; } return true ; } static boolean CheckOdd ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String x = " " ; for ( int j = i ; j < n ; j ++ ) { x += s . charAt ( j ) ; if ( x . length ( ) % 2 == 0 && checkPalindrome ( x ) == true ) return false ; } } return true ; } public static void main ( String args [ ] ) { String s = " geeksforgeeks " ; if ( CheckOdd ( s ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . util . * ; class solution { static int fact ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result *= i ; return result ; } static int getResult ( String str , char ch ) { int has [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) has [ i ] = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) has [ str . charAt ( i ) - ' A ' ] ++ ; int particular = has [ ch - ' A ' ] ; if ( particular == 0 ) return 0 ; has [ ch - ' A ' ] = 0 ; int total = str . length ( ) ; total = total - particular + 1 ; int result = fact ( total ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( has [ i ] > 1 ) { result = result / fact ( has [ i ] ) ; } } return result ; } public static void main ( String args [ ] ) { String str = " MISSISSIPPI " ; System . out . println ( getResult ( str , ' S ' ) ) ; } }
class GFG { static long factorial ( long n ) { long res = 1 ; for ( int i = 1 ; i <= n ; i ++ ) res = res * i ; return res ; } static long count ( String word ) { int freq [ ] = new int [ 27 ] ; for ( int i = 0 ; i < 27 ; i ++ ) freq [ i ] = 0 ; long vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { freq [ word . charAt ( i ) - ' A ' ] ++ ; if ( word . charAt ( i ) == ' A ' || word . charAt ( i ) == ' E ' || word . charAt ( i ) == ' I ' || word . charAt ( i ) == ' O ' || word . charAt ( i ) == ' U ' ) { vowel ++ ; } else consonant ++ ; } long vowelArrange ; vowelArrange = factorial ( vowel ) ; vowelArrange /= factorial ( freq [ 0 ] ) ; vowelArrange /= factorial ( freq [ 4 ] ) ; vowelArrange /= factorial ( freq [ 8 ] ) ; vowelArrange /= factorial ( freq [ 14 ] ) ; vowelArrange /= factorial ( freq [ 20 ] ) ; long consonantArrange ; consonantArrange = factorial ( consonant ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 ) consonantArrange /= factorial ( freq [ i ] ) ; } long total = vowelArrange * consonantArrange ; return total ; } public static void main ( String [ ] args ) { String word = " COMPUTER " ; long ans = count ( word ) ; System . out . println ( ans ) ; } }
class GFG { static long productAscii ( String str ) { long prod = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { prod *= str . charAt ( i ) ; } return prod ; } public static void main ( String [ ] args ) { String str = " GfG " ; System . out . println ( productAscii ( str ) ) ; } }
class GFG { public static void balancedString ( String str ) { int count = 0 , i ; int n = str . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) { System . out . print ( str . charAt ( i ) ) ; count ++ ; } else if ( str . charAt ( i ) == ' ) ' && count != 0 ) { System . out . print ( str . charAt ( i ) ) ; count -- ; } else if ( str . charAt ( i ) != ' ) ' ) System . out . print ( str . charAt ( i ) ) ; } if ( count != 0 ) for ( i = 0 ; i < count ; i ++ ) System . out . print ( " ) " ) ; } public static void main ( String args [ ] ) { String str = " gau ) ra ) v ( ku ( mar ( rajput ) ) " ; balancedString ( str ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int countStrings ( String s ) { int sum = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) == ' $ ' ) sum *= 21 ; else if ( s . charAt ( i ) == ' $ ' ) sum *= 5 ; } return sum ; } public static void main ( String args [ ] ) { String str = " s $ $ e $ " ; System . out . println ( countStrings ( str ) ) ; } }
import java . util . Arrays ; class GFG { static char [ ] removeDuplicatesFromString ( String string ) { int counter = 0 ; char [ ] str = string . toCharArray ( ) ; int i = 0 ; int size = str . length ; int x ; int length = 0 ; while ( i < size ) { x = str [ i ] - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = ( char ) ( ' a ' + x ) ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return Arrays . copyOfRange ( str , 0 , length ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . println ( removeDuplicatesFromString ( str ) ) ; } }
import java . io . * ; class GFG { static int firstPos ( String str , int start , int end ) { int firstChar = - 1 ; for ( int i = start ; i <= end ; i ++ ) { if ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) { firstChar = i ; break ; } } return firstChar ; } static int lastPos ( String str , int start , int end ) { int lastChar = - 1 ; for ( int i = start ; i >= end ; i -- ) { if ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) { lastChar = i ; break ; } } return lastChar ; } static boolean isPalindrome ( String str ) { int firstChar = 0 , lastChar = str . length ( ) - 1 ; boolean ch = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { firstChar = firstPos ( str , firstChar , lastChar ) ; lastChar = lastPos ( str , lastChar , firstChar ) ; if ( lastChar < 0 firstChar < 0 ) break ; if ( str . charAt ( firstChar ) == str . charAt ( lastChar ) ) { firstChar ++ ; lastChar -- ; continue ; } ch = false ; break ; } return ch ; } public static void main ( String [ ] args ) { String str = " m ▁ a ▁ 343 ▁ la ▁ y ▁ a ▁ l ▁ am " ; if ( isPalindrome ( str ) ) System . out . print ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . ArrayList ; public class string_sort { public static int powerOfJump ( String s ) { int count = 1 ; int max_so_far = Integer . MIN_VALUE ; char ch = s . charAt ( s . length ( ) - 1 ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; } public static void main ( String [ ] args ) { String st = "1010101" ; System . out . println ( powerOfJump ( st ) ) ; } }
import java . io . * ; class GFG { public static int averageValue ( String s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum_char += ( int ) s . charAt ( i ) ; } return sum_char / s . length ( ) ; } public static void main ( String [ ] args ) { String s = " GeeksforGeeks " ; System . out . println ( averageValue ( s ) ) ; } }
import java . util . Arrays ; class GFG { static String commonPrefixUtil ( String str1 , String str2 ) { String result = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; for ( int i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( j ) ) { break ; } result += str1 . charAt ( i ) ; } return ( result ) ; } static void commonPrefix ( String arr [ ] , int n ) { Arrays . sort ( arr ) ; System . out . println ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) ; } public static void main ( String [ ] args ) { String arr [ ] = { " geeksforgeeks " , " geeks " , " geek " , " geezer " } ; int n = arr . length ; commonPrefix ( arr , n ) ; } }
class GFG { static String addBinaryUtil ( String a , String b ) { String result = " " ; int s = 0 ; int i = a . length ( ) - 1 , j = b . length ( ) - 1 ; while ( i >= 0 j >= 0 s == 1 ) { s += ( ( i >= 0 ) ? a . charAt ( i ) - '0' : 0 ) ; s += ( ( j >= 0 ) ? b . charAt ( j ) - '0' : 0 ) ; result = s % 2 + result ; s /= 2 ; i -- ; j -- ; } return result ; } static String addBinary ( String arr [ ] , int n ) { String result = " " ; for ( int i = 0 ; i < n ; i ++ ) { result = addBinaryUtil ( result , arr [ i ] ) ; } return result ; } public static void main ( String [ ] args ) { String arr [ ] = { "1" , "10" , "11" } ; int n = arr . length ; System . out . println ( addBinary ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int prefix ( String k , int n ) { int a = 0 , b = 0 , count = 0 ; int i = 0 ; int len = k . length ( ) ; for ( i = 0 ; i < len ; i ++ ) { if ( k . charAt ( i ) == ' a ' ) a ++ ; if ( k . charAt ( i ) == ' b ' ) b ++ ; if ( a > b ) { count ++ ; } } if ( count == 0 n == 1 ) { System . out . println ( count ) ; return 0 ; } if ( count == len a - b == 0 ) { System . out . println ( count * n ) ; return 0 ; } int n2 = n - 1 , count2 = 0 ; while ( n2 != 0 ) { for ( i = 0 ; i < len ; i ++ ) { if ( k . charAt ( i ) == ' a ' ) a ++ ; if ( k . charAt ( i ) == ' b ' ) b ++ ; if ( a > b ) { count2 ++ ; } } count += count2 ; n2 -- ; if ( count2 == 0 ) break ; if ( count2 == len ) { count += ( n2 * count2 ) ; break ; } count2 = 0 ; } return count ; } public static void main ( String [ ] args ) { String S = " aba " ; int N = 2 ; System . out . println ( prefix ( S , N ) ) ; S = " baa " ; N = 3 ; System . out . println ( prefix ( S , N ) ) ; } }
class GFG { static boolean isCommonBase ( String base , String s1 , String s2 ) { for ( int j = 0 ; j < s1 . length ( ) ; ++ j ) { if ( base . charAt ( j % base . length ( ) ) != s1 . charAt ( j ) ) { return false ; } } for ( int j = 0 ; j < s2 . length ( ) ; ++ j ) { if ( base . charAt ( j % base . length ( ) ) != s2 . charAt ( j ) ) { return false ; } } return true ; } static int countCommonBases ( String s1 , String s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; int count = 0 ; for ( int i = 1 ; i <= Math . min ( n1 , n2 ) ; i ++ ) { String base = s1 . substring ( 0 , i ) ; if ( isCommonBase ( base , s1 , s2 ) ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { String s1 = " pqrspqrs " ; String s2 = " pqrspqrspqrspqrs " ; System . out . println ( countCommonBases ( s1 , s2 ) ) ; } }
import java . io . * ; class GFG { static boolean isPerfectSquareString ( String str ) { int sum = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str . charAt ( i ) ; long squareRoot = ( long ) Math . sqrt ( sum ) ; return ( ( squareRoot - Math . floor ( squareRoot ) ) == 0 ) ; } public static void main ( String [ ] args ) { String str = " d " ; if ( isPerfectSquareString ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static boolean is_vow ( char c ) { return ( c == ' a ' ) || ( c == ' e ' ) || ( c == ' i ' ) || ( c == ' o ' ) || ( c == ' u ' ) ; } static void removeVowels ( String str ) { System . out . print ( str . charAt ( 0 ) ) ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) if ( ( ! is_vow ( str . charAt ( i - 1 ) ) ) || ( ! is_vow ( str . charAt ( i ) ) ) ) System . out . print ( str . charAt ( i ) ) ; } public static void main ( String [ ] args ) { String str = " geeks ▁ for ▁ geeks " ; removeVowels ( str ) ; } }
import java . io . * ; public class GFG { static boolean transformString ( StringBuilder s ) { char ch = ' a ' ; if ( s . length ( ) < 26 ) return false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( int ) ch > ( int ) ' z ' ) break ; if ( s . charAt ( i ) <= ch ) { s . setCharAt ( i , ch ) ; ch = ( char ) ( ( int ) ch + 1 ) ; } } if ( ch <= ' z ' ) return false ; return true ; } public static void main ( String args [ ] ) { StringBuilder str = new StringBuilder ( " aaaaaaaaaaaaaaaaaaaaaaaaaa " ) ; if ( transformString ( str ) ) System . out . println ( str . toString ( ) ) ; else System . out . println ( " Not ▁ Possible " ) ; } }
import java . io . * ; import java . util . * ; class GFG { static ArrayList < String > v = new ArrayList < String > ( ) ; static int isPanDigital ( String s ) { int digits [ ] = new int [ 10 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) digits [ s . charAt ( i ) - ( int ) '0' ] = 1 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( digits [ i ] == 0 ) return 0 ; return 1 ; } static int countPandigitalPairs ( ) { int pairs = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) for ( int j = i + 1 ; j < v . size ( ) ; j ++ ) if ( isPanDigital ( v . get ( i ) + v . get ( j ) ) == 1 ) pairs ++ ; return pairs ; } public static void main ( String args [ ] ) { v . add ( "123567" ) ; v . add ( "098234" ) ; v . add ( "14765" ) ; v . add ( "19804" ) ; System . out . print ( countPandigitalPairs ( ) ) ; } }
import java . lang . * ; import java . util . * ; class GFG { static final int MAX_CHAR = 26 ; public static int minChanges ( String str ) { int n = str . length ( ) ; if ( n > MAX_CHAR ) return - 1 ; int dist_count = 0 ; int count [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ str . charAt ( i ) - ' a ' ] == 0 ) dist_count ++ ; count [ str . charAt ( i ) - ' a ' ] ++ ; } return ( n - dist_count ) ; } public static void main ( String [ ] args ) { String str = " aebaecedabbee " ; System . out . println ( minChanges ( str ) ) ; } }
import java . io . * ; class GFG { static int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * ( int ) Math . pow ( m - 2 , n - 2 ) ; } public static void main ( String [ ] args ) { int n = 2 , m = 3 ; System . out . println ( numofstring ( n , m ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { public static int CountSpecialPalindrome ( String str ) { int n = str . length ( ) ; int result = 0 ; int [ ] sameChar = new int [ n ] ; for ( int v = 0 ; v < n ; v ++ ) sameChar [ v ] = 0 ; int i = 0 ; while ( i < n ) { int sameCharCount = 1 ; int j = i + 1 ; while ( j < n && str . charAt ( i ) == str . charAt ( j ) ) { sameCharCount ++ ; j ++ ; } result += ( sameCharCount * ( sameCharCount + 1 ) / 2 ) ; sameChar [ i ] = sameCharCount ; i = j ; } for ( int j = 1 ; j < n ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) ) sameChar [ j ] = sameChar [ j - 1 ] ; if ( j > 0 && j < ( n - 1 ) && ( str . charAt ( j - 1 ) == str . charAt ( j + 1 ) && str . charAt ( j ) != str . charAt ( j - 1 ) ) ) result += Math . min ( sameChar [ j - 1 ] , sameChar [ j + 1 ] ) ; } return result - n ; } public static void main ( String args [ ] ) { String str = " abccba " ; System . out . print ( CountSpecialPalindrome ( str ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void printBracketNumber ( String exp , int n ) { int left_bnum = 1 ; Stack < Integer > right_bnum = new Stack < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp . charAt ( i ) == ' ( ' ) { System . out . print ( left_bnum + " ▁ " ) ; right_bnum . push ( left_bnum ) ; left_bnum ++ ; } else if ( exp . charAt ( i ) == ' ) ' ) { System . out . print ( right_bnum . peek ( ) + " ▁ " ) ; right_bnum . pop ( ) ; } } } public static void main ( String args [ ] ) { String exp = " ( a + ( b * c ) ) + ( d / e ) " ; int n = exp . length ( ) ; printBracketNumber ( exp , n ) ; } }
import java . io . * ; class GFG { static boolean isCornerPresent ( String str , String corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . equals ( corner ) && str . substring ( n - cl , n ) . equals ( corner ) ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; String corner = " geeks " ; if ( isCornerPresent ( str , corner ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static boolean isConvertible ( String str1 , String str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 == str2 ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { String str1 = " geek " ; String str2 = " geek " ; int k = 7 ; if ( isConvertible ( str1 , str2 , k ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; str1 = " geeks " ; str2 = " geek " ; k = 5 ; if ( isConvertible ( str1 , str2 , k ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Arrays ; class GFG { static final int MAX_CHAR = 26 ; static int maxLower ( String str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { i ++ ; break ; } } int maxCount = 0 ; int count [ ] = new int [ MAX_CHAR ] ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { int currCount = 0 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) { if ( count [ j ] > 0 ) { currCount ++ ; } } maxCount = Math . max ( maxCount , currCount ) ; Arrays . fill ( count , 0 ) ; } if ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) { count [ str . charAt ( i ) - ' a ' ] ++ ; } } return maxCount ; } public static void main ( String [ ] args ) { String str = " zACaAbbaazzC " ; System . out . println ( maxLower ( str ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static char first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return 0 ; } public static void main ( String args [ ] ) { String str = " geeksforGeeKS " ; char res = first ( str ) ; if ( res == 0 ) System . out . println ( " No ▁ uppercase ▁ letter " ) ; else System . out . println ( res ) ; } }
import java . io . * ; class GFG { static int evenDecimalValue ( String str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str . charAt ( k ) - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; } public static void main ( String [ ] args ) { String str = "10010" ; int n = 5 ; System . out . println ( evenDecimalValue ( str , n ) ) ; } }
import java . io . * ; class GFG { public static void solve ( String s ) { int l = s . length ( ) ; int x = l / 2 ; int y = l ; String p = " " ; while ( x > 0 && y > l / 2 ) { char ch = s . charAt ( x - 1 ) ; p += ch ; x -- ; ch = s . charAt ( y - 1 ) ; p += ch ; y -- ; } if ( y > l / 2 ) { char ch = s . charAt ( x - 1 ) ; p += ch ; y -- ; } System . out . println ( p ) ; } public static void main ( String args [ ] ) { String s = " sunshine " ; solve ( s ) ; } }
import java . util . * ; public class GFG { private static int recLen ( String str ) { if ( str . equals ( " " ) ) return 0 ; else return recLen ( str . substring ( 1 ) ) + 1 ; } public static void main ( String [ ] args ) { String str = " GeeksforGeeks " ; System . out . println ( recLen ( str ) ) ; } }
import java . io . * ; class GFG { static boolean isConsonant ( char ch ) { ch = Character . toUpperCase ( ch ) ; return ! ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) && ch >= 65 && ch <= 90 ; } static int totalConsonants ( String str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isConsonant ( str . charAt ( i ) ) ) ++ count ; return count ; } public static void main ( String args [ ] ) { String str = " abc ▁ de " ; System . out . println ( totalConsonants ( str ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static long reverseBits ( long n ) { long rev = 0 ; while ( n > 0 ) { rev <<= 1 ; if ( ( n & 1 ) == 1 ) rev ^= 1 ; n >>= 1 ; } return rev ; } public static boolean isPalindrome ( long n ) { long rev = reverseBits ( n ) ; return ( n == rev ) ; } public static void main ( String argc [ ] ) { long n = 9 ; if ( isPalindrome ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class Geek { static void solve ( int n , int t , char s [ ] ) { for ( int i = 0 ; i < t ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) if ( s [ j ] == ' B ' && s [ j + 1 ] == ' G ' ) { char temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j ++ ; } System . out . print ( s ) ; } public static void main ( String args [ ] ) { int n = 6 , t = 2 ; String s = " BBGBBG " ; char str [ ] = s . toCharArray ( ) ; solve ( n , t , str ) ; } }
import java . io . * ; class GFG { static int calSumUtil ( int a [ ] , int b [ ] , int n , int m ) { int [ ] sum = new int [ n ] ; int i = n - 1 , j = m - 1 , k = n - 1 ; int carry = 0 , s = 0 ; while ( j >= 0 ) { s = a [ i ] + b [ j ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; k -- ; i -- ; j -- ; } while ( i >= 0 ) { s = a [ i ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; i -- ; k -- ; } int ans = 0 ; if ( carry == 1 ) ans = 10 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { ans += sum [ i ] ; ans *= 10 ; } return ans / 10 ; } static int calSum ( int a [ ] , int b [ ] , int n , int m ) { if ( n >= m ) return calSumUtil ( a , b , n , m ) ; else return calSumUtil ( b , a , m , n ) ; } public static void main ( String [ ] args ) { int a [ ] = { 9 , 3 , 9 } ; int b [ ] = { 6 , 1 } ; int n = a . length ; int m = b . length ; System . out . println ( calSum ( a , b , n , m ) ) ; } }
import java . io . * ; class GFG { static int SIZE = 26 ; static int longCommomAnagramSubseq ( String str1 , String str2 , int n1 , int n2 ) { int [ ] freq1 = new int [ SIZE ] ; int [ ] freq2 = new int [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ ( int ) str1 . charAt ( i ) - ( int ) ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ ( int ) str2 . charAt ( i ) - ( int ) ' a ' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; } public static void main ( String args [ ] ) { String str1 = " abdacp " ; String str2 = " ckamb " ; int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; System . out . print ( " Length ▁ = ▁ " + longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) ) ; } }
class GFG { static boolean isPanalphabeticWindow ( String s , int n ) { char ch = ' a ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ch ) ch ++ ; if ( ch == ' z ' + 1 ) return true ; } return false ; } public static void main ( String [ ] args ) { String s = " abujm ▁ zvcd ▁ acefc ▁ deghf " + " ▁ gijklem ▁ n ▁ o ▁ p ▁ pafqrstuvwxyzfap " ; int n = s . length ( ) ; if ( isPanalphabeticWindow ( s , n ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static void prime_index ( String input ) { int n = input . length ( ) ; for ( int i = 2 ; i <= n ; i ++ ) if ( isPrime ( i ) ) System . out . print ( input . charAt ( i - 1 ) ) ; } public static void main ( String [ ] args ) { String input = " GeeksforGeeks " ; prime_index ( input ) ; } }
class GFG { static boolean isHeterogram ( String s , int n ) { int hash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != ' ▁ ' ) { if ( hash [ s . charAt ( i ) - ' a ' ] == 0 ) hash [ s . charAt ( i ) - ' a ' ] = 1 ; else return false ; } } return true ; } public static void main ( String [ ] args ) { String s = " the ▁ big ▁ dwarf ▁ only ▁ jumps " ; int n = s . length ( ) ; if ( isHeterogram ( s , n ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . util . * ; import java . lang . * ; class GeeksforGeeks { static void ASCIISentence ( String str ) { int l = str . length ( ) ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str . charAt ( i ) ; System . out . print ( convert ) ; } } public static void main ( String args [ ] ) { String str = " GeeksforGeeks " ; System . out . println ( " ASCII ▁ Sentence : " ) ; ASCIISentence ( str ) ; } }
import java . io . * ; class GFG { static void convert ( String str ) { int n = str . length ( ) ; String str1 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) str1 = str1 + ' _ ' ; else str1 = str1 + Character . toLowerCase ( str . charAt ( i ) ) ; } System . out . print ( str1 ) ; } public static void main ( String args [ ] ) { String str = " I ▁ got ▁ intern ▁ at ▁ geeksforgeeks " ; convert ( str ) ; } }
class GFG { static String replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return String . valueOf ( arr ) ; } public static void main ( String [ ] args ) { String s = " grrksfoegrrks " ; char c1 = ' e ' , c2 = ' r ' ; System . out . println ( replace ( s , c1 , c2 ) ) ; } }
class GFG { static String constructPalin ( char [ ] str , int len ) { int i = 0 , j = len - 1 ; for ( ; i < j ; i ++ , j -- ) { if ( str [ i ] == str [ j ] && str [ i ] != ' * ' ) continue ; else if ( str [ i ] == str [ j ] && str [ i ] == ' * ' ) { str [ i ] = ' a ' ; str [ j ] = ' a ' ; continue ; } else if ( str [ i ] == ' * ' ) { str [ i ] = str [ j ] ; continue ; } else if ( str [ j ] == ' * ' ) { str [ j ] = str [ i ] ; continue ; } System . out . println ( " Not ▁ Possible " ) ; return " " ; } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { String str = " bca * xc * * b " ; int len = str . length ( ) ; System . out . println ( constructPalin ( str . toCharArray ( ) , len ) ) ; } }
class GFG { static final int max = 100 ; static void carveCross ( String str ) { int n = str . length ( ) ; if ( n % 2 == 0 ) { System . out . print ( " Not ▁ possible . ▁ Please ▁ enter ▁ " + "odd length string.NEW_LINE"); } else { char arr [ ] [ ] = new char [ max ] [ max ] ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = ' X ' ; } } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ m ] = str . charAt ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ m ] [ i ] = str . charAt ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; } System . out . print ( "NEW_LINE"); } } } public static void main ( String [ ] args ) { String str = " PICTURE " ; carveCross ( str ) ; } }
import java . io . * ; class GFG { static int remainder ( String str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str . charAt ( i ) - '0' ) ; rem = num % 11 ; } return rem ; } public static void main ( String args [ ] ) { String str = "3435346456547566345436457867978" ; System . out . println ( remainder ( str ) ) ; } }
class GFG { static void findPermutations ( char str [ ] , int index , int n ) { if ( index >= n || ( index + 1 ) >= n ) { System . out . println ( str ) ; return ; } findPermutations ( str , index + 1 , n ) ; swap ( str , index ) ; findPermutations ( str , index + 2 , n ) ; swap ( str , index ) ; } static void swap ( char arr [ ] , int index ) { char temp = arr [ index ] ; arr [ index ] = arr [ index + 1 ] ; arr [ index + 1 ] = temp ; } public static void main ( String [ ] args ) { char str [ ] = "12345" . toCharArray ( ) ; int n = str . length ; findPermutations ( str , 0 , n ) ; } }
import java . io . * ; class GFG { static boolean isUnique ( int [ ] a , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; } static public void main ( String [ ] args ) { int [ ] a = { 3 , 3 , 3 } ; int n = a . length ; int k = 12 ; if ( isUnique ( a , n , k ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static boolean isPalindrome ( String s , int i , int j ) { int p = j ; for ( int k = i ; k <= p ; k ++ ) { if ( s . charAt ( k ) != s . charAt ( p ) ) return false ; p -- ; } return true ; } static int countWays ( String s ) { int n = s . length ( ) ; int count = 0 ; if ( isPalindrome ( s , 0 , n - 1 ) ) { for ( int i = n / 2 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) count ++ ; else break ; } { count ++ ; } else } else { for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( n - 1 - i ) ) { int j = n - 1 - i ; if ( isPalindrome ( s , i , n - 2 - i ) ) { for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( s . charAt ( k ) != s . charAt ( j ) ) break ; count ++ ; } count ++ ; } if ( isPalindrome ( s , i + 1 , n - 1 - i ) ) { for ( int k = n - i ; k < n ; k ++ ) { if ( s . charAt ( k ) != s . charAt ( i ) ) break ; count ++ ; } count ++ ; } break ; } } } return count ; } public static void main ( String [ ] args ) { String s = " abca " ; System . out . println ( countWays ( s ) ) ; } }
import java . io . * ; public class GFG { static int countOfSubstringWithKOnes ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int [ ] freq = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s . charAt ( i ) - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; } static public void main ( String [ ] args ) { String s = "10010" ; int K = 1 ; System . out . println ( countOfSubstringWithKOnes ( s , K ) ) ; } }
import java . util . * ; class NextHigherPalindrome { public static void reverse ( char num [ ] , int i , int j ) { while ( i < j ) { char temp = num [ i ] ; num [ i ] = num [ j ] ; num [ j ] = temp ; i ++ ; j -- ; } } public static void nextPalin ( char num [ ] , int n ) { if ( n <= 3 ) { System . out . println ( " Not ▁ Possible " ) ; return ; } char temp ; int mid = n / 2 - 1 ; int i , j ; for ( i = mid - 1 ; i >= 0 ; i -- ) if ( num [ i ] < num [ i + 1 ] ) break ; if ( i < 0 ) { System . out . println ( " Not ▁ Possible " ) ; return ; } int smallest = i + 1 ; for ( j = i + 2 ; j <= mid ; j ++ ) if ( num [ j ] > num [ i ] && num [ j ] <= num [ smallest ] ) smallest = j ; temp = num [ i ] ; num [ i ] = num [ smallest ] ; num [ smallest ] = temp ; temp = num [ n - i - 1 ] ; num [ n - i - 1 ] = num [ n - smallest - 1 ] ; num [ n - smallest - 1 ] = temp ; reverse ( num , i + 1 , mid ) ; if ( n % 2 == 0 ) reverse ( num , mid + 1 , n - i - 2 ) ; else reverse ( num , mid + 2 , n - i - 2 ) ; String result = String . valueOf ( num ) ; System . out . println ( " Next ▁ Palindrome : ▁ " + result ) ; } public static void main ( String args [ ] ) { String str = "4697557964" ; char num [ ] = str . toCharArray ( ) ; int n = str . length ( ) ; nextPalin ( num , n ) ; } }
import java . io . * ; class GFG { static void printRec ( String number , int extraOnes , int remainingPlaces ) { if ( 0 == remainingPlaces ) { System . out . print ( number + " ▁ " ) ; return ; } printRec ( number + "1" , extraOnes + 1 , remainingPlaces - 1 ) ; if ( 0 < extraOnes ) printRec ( number + "0" , extraOnes - 1 , remainingPlaces - 1 ) ; } static void printNums ( int n ) { String str = " " ; printRec ( str , 0 , n ) ; } public static void main ( String [ ] args ) { int n = 4 ; printNums ( n ) ; } }
import java . io . * ; import java . util . * ; class stem { public static String findstem ( String arr [ ] ) { int n = arr . length ; String s = arr [ 0 ] ; int len = s . length ( ) ; String res = " " ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i + 1 ; j <= len ; j ++ ) { String stem = s . substring ( i , j ) ; int k = 1 ; for ( k = 1 ; k < n ; k ++ ) if ( ! arr [ k ] . contains ( stem ) ) break ; if ( k == n && res . length ( ) < stem . length ( ) ) res = stem ; } } return res ; } public static void main ( String args [ ] ) { String arr [ ] = { " grace " , " graceful " , " disgraceful " , " gracefully " } ; String stems = findstem ( arr ) ; System . out . println ( stems ) ; } }
class GFG { static String nextHighUsingAtMostOneSwap ( String st ) { char num [ ] = st . toCharArray ( ) ; int l = num . length ; int posRMax = l - 1 ; int index = - 1 ; for ( int i = l - 2 ; i >= 0 ; i -- ) { if ( num [ i ] >= num [ posRMax ] ) posRMax = i ; else { index = i ; break ; } } if ( index == - 1 ) return " Not ▁ Possible " ; int greatSmallDgt = - 1 ; for ( int i = l - 1 ; i > index ; i -- ) { if ( num [ i ] > num [ index ] ) { if ( greatSmallDgt == - 1 ) greatSmallDgt = i ; else if ( num [ i ] <= num [ greatSmallDgt ] ) greatSmallDgt = i ; } } char temp = num [ index ] ; num [ index ] = num [ greatSmallDgt ] ; num [ greatSmallDgt ] = temp ; return ( String . valueOf ( num ) ) ; } public static void main ( String [ ] args ) { String num = "218765" ; System . out . println ( " Original ▁ number : ▁ " + num ) ; System . out . println ( " Next ▁ higher ▁ number : ▁ " + nextHighUsingAtMostOneSwap ( num ) ) ; } }
import java . util . * ; class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } static int longestVowel ( String str ) { int count = 0 , res = 0 ; char [ ] s = str . toCharArray ( ) ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( isVowel ( s [ i ] ) ) count ++ ; else { res = Math . max ( res , count ) ; count = 0 ; } } return Math . max ( res , count ) ; } public static void main ( String [ ] args ) { String s = " theeare " ; System . out . println ( longestVowel ( s ) ) ; } }
class GFG { static int MAX_CHAR = 26 ; static boolean check ( int freq [ ] , int k ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( freq [ i ] != 0 && freq [ i ] != k ) return false ; return true ; } static int substrings ( String s , int k ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int freq [ ] = new int [ MAX_CHAR ] ; for ( int j = i ; j < s . length ( ) ; j ++ ) { int index = s . charAt ( j ) - ' a ' ; freq [ index ] ++ ; if ( freq [ index ] > k ) break ; else if ( freq [ index ] == k && check ( freq , k ) == true ) res ++ ; } } return res ; } public static void main ( String [ ] args ) { String s = " aabbcc " ; int k = 2 ; System . out . println ( substrings ( s , k ) ) ; s = " aabbc " ; k = 2 ; System . out . println ( substrings ( s , k ) ) ; } }
class GFG { static int countSubstrs ( String str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ; return res ; } public static void main ( String [ ] args ) { String str = " abcab " ; int n = str . length ( ) ; System . out . print ( countSubstrs ( str , 0 , n - 1 , n ) ) ; } }
public class Similar_strings { static int countManipulations ( String s1 , String s2 ) { int count = 0 ; int char_count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char_count [ s1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { char_count [ s2 . charAt ( i ) - ' a ' ] -- ; } for ( int i = 0 ; i < 26 ; ++ i ) { if ( char_count [ i ] != 0 ) { count += Math . abs ( char_count [ i ] ) ; } } return count / 2 ; } public static void main ( String [ ] args ) { String s1 = " ddcf " ; String s2 = " cedk " ; System . out . println ( countManipulations ( s1 , s2 ) ) ; } }
public class First_Palin { static final int MAX_CHAR = 26 ; static char stringPalindrome ( String A , String B ) { int [ ] countA = new int [ MAX_CHAR ] ; int [ ] countB = new int [ MAX_CHAR ] ; int l1 = A . length ( ) ; int l2 = B . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' A ' ; return ' B ' ; } public static void main ( String args [ ] ) { String a = " abcdea " ; String b = " bcdesg " ; System . out . println ( stringPalindrome ( a , b ) ) ; } }
class GFG { static final int MAX_CHAR = 256 ; static int countBalance ( String s ) { char [ ] str = s . toCharArray ( ) ; int [ ] rightVisited = new int [ MAX_CHAR ] ; int [ ] leftVisited = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) rightVisited [ str [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { leftVisited [ str [ i ] ] ++ ; rightVisited [ str [ i ] ] -- ; int j ; for ( j = 0 ; j < MAX_CHAR ; j ++ ) { if ( ( leftVisited [ j ] == 0 && rightVisited [ j ] != 0 ) || ( leftVisited [ j ] != 0 && rightVisited [ j ] == 0 ) ) break ; } if ( j == MAX_CHAR ) res ++ ; } return res ; } public static void main ( String [ ] args ) { String str = " abaababa " ; System . out . println ( countBalance ( str ) ) ; } }
public class minFlips { static int findFlips ( String str , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return res / 2 ; } public static void main ( String [ ] args ) { String str = "00011110001110" ; int n = str . length ( ) ; System . out . println ( findFlips ( str , n ) ) ; } }
public class GFG { static int findLen ( String A , int n , int k , char ch ) { int maxlen = 1 ; int cnt = 0 ; int l = 0 , r = 0 ; while ( r < n ) { if ( A . charAt ( r ) != ch ) ++ cnt ; while ( cnt > k ) { if ( A . charAt ( l ) != ch ) -- cnt ; ++ l ; } maxlen = Math . max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; } static int answer ( String A , int n , int k ) { int maxlen = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) { maxlen = Math . max ( maxlen , findLen ( A , n , k , ( char ) ( i + ' A ' ) ) ) ; maxlen = Math . max ( maxlen , findLen ( A , n , k , ( char ) ( i + ' a ' ) ) ) ; } return maxlen ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; String A = " ABABA " ; System . out . println ( " Maximum ▁ length ▁ = ▁ " + answer ( A , n , k ) ) ; n = 6 ; k = 4 ; String B = " HHHHHH " ; System . out . println ( " Maximum ▁ length ▁ = ▁ " + answer ( B , n , k ) ) ; } }
public class GFG { static final int MAX_CHAR = 26 ; static boolean checkCorrectOrNot ( String s ) { int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s . charAt ( i ) - ' a ' ] ++ ; count2 [ s . charAt ( j ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; } public static void main ( String args [ ] ) { String s = " abab " ; if ( checkCorrectOrNot ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static String maximumNum ( String curr_num , String res ) { int len1 = curr_num . length ( ) ; int len2 = res . length ( ) ; if ( len1 == len2 ) { int i = 0 ; while ( curr_num . charAt ( i ) == res . charAt ( i ) ) i ++ ; if ( curr_num . charAt ( i ) < res . charAt ( i ) ) return res ; else return curr_num ; } return len1 < len2 ? res : curr_num ; } static String extractMaximum ( String str ) { int n = str . length ( ) ; String curr_num = " " ; String res = " " ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n && str . charAt ( i ) == '0' ) i ++ ; while ( i < n && Character . isDigit ( str . charAt ( i ) ) ) { curr_num = curr_num + str . charAt ( i ) ; i ++ ; } if ( i == n ) break ; if ( curr_num . length ( ) > 0 ) i -- ; res = maximumNum ( curr_num , res ) ; curr_num = " " ; } if ( curr_num . length ( ) == 0 && res . length ( ) == 0 ) res = res + '0' ; return maximumNum ( curr_num , res ) ; } public static void main ( String [ ] args ) { String str = "100klh564abc365bg " ; System . out . println ( extractMaximum ( str ) ) ; } }
class Test { static boolean isDivisible999 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( num . charAt ( i ++ ) - '0' ) * 100 ; group += ( num . charAt ( i ++ ) - '0' ) * 10 ; group += num . charAt ( i ) - '0' ; gSum += group ; } if ( gSum > 1000 ) { num = Integer . toString ( gSum ) ; n = num . length ( ) ; gSum = isDivisible999 ( num ) ? 1 : 0 ; } return ( gSum == 999 ) ; } public static void main ( String args [ ] ) { String num = "1998" ; System . out . println ( isDivisible999 ( num ) ? " Divisible " : " Not ▁ divisible " ) ; } }
class Test { static final int MAX_CHAR = 26 ; static String arrangeString ( String str ) { int char_count [ ] = new int [ MAX_CHAR ] ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) char_count [ str . charAt ( i ) - ' A ' ] ++ ; else sum = sum + ( str . charAt ( i ) - '0' ) ; } String res = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( ' A ' + i ) ; while ( char_count [ i ] -- != 0 ) res = res + ch ; } if ( sum > 0 ) res = res + sum ; return res ; } public static void main ( String args [ ] ) { String str = " ACCBA10D2EW30" ; System . out . println ( arrangeString ( str ) ) ; } }
class GFG { static void subString ( char str [ ] , int n ) { for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; for ( int k = i ; k <= j ; k ++ ) { System . out . print ( str [ k ] ) ; } System . out . println ( ) ; } } } public static void main ( String [ ] args ) { char str [ ] = { ' a ' , ' b ' , ' c ' } ; subString ( str , str . length ) ; } }
public class GFG { static boolean isVowel ( char ch ) { ch = Character . toUpperCase ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } static int countVowels ( String str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ count ; return count ; } public static void main ( String args [ ] ) { String str = " abc ▁ de " ; System . out . println ( countVowels ( str ) ) ; } }
class Test { static void printRotatedString ( String str ) { int len = str . length ( ) ; StringBuffer sb ; for ( int i = 0 ; i < len ; i ++ ) { sb = new StringBuffer ( ) ; int j = i ; int k = 0 ; for ( int k2 = j ; k2 < str . length ( ) ; k2 ++ ) { sb . insert ( k , str . charAt ( j ) ) ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { sb . insert ( k , str . charAt ( j ) ) ; j ++ ; k ++ ; } System . out . println ( sb ) ; } } public static void main ( String [ ] args ) { String str = new String ( " geeks " ) ; printRotatedString ( str ) ; } }
public class GFG { static Boolean isPalindrome ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) if ( str . charAt ( i ) != str . charAt ( n - i - 1 ) ) return false ; return true ; } static int maxLengthNonPalinSubstring ( String str ) { int n = str . length ( ) ; char ch = str . charAt ( 0 ) ; int i = 1 ; for ( i = 1 ; i < n ; i ++ ) if ( str . charAt ( i ) != ch ) break ; if ( i == n ) return 0 ; if ( isPalindrome ( str ) ) return n - 1 ; return n ; } public static void main ( String args [ ] ) { String str = " abba " ; System . out . println ( " Maximum ▁ Length ▁ = ▁ " + maxLengthNonPalinSubstring ( str ) ) ; } }
import java . io . * ; class GFG { static void isKthBitSet ( int n , int k ) { if ( ( ( n >> ( k - 1 ) ) & 1 ) > 0 ) System . out . println ( " SET " ) ; else System . out . println ( " NOT ▁ SET " ) ; } public static void main ( String [ ] args ) { int n = 5 , k = 1 ; isKthBitSet ( n , k ) ; } }
class GFG { static char MAX_CHAR = 26 ; static void countFreq ( String str , int freq [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } } static boolean canMakePalindrome ( int freq [ ] , int len ) { int count_odd = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { count_odd ++ ; } } if ( len % 2 == 0 ) { if ( count_odd > 0 ) { return false ; } else { return true ; } } if ( count_odd != 1 ) { return false ; } return true ; } static String findOddAndRemoveItsFreq ( int freq [ ] ) { String odd_str = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { freq [ i ] -- ; odd_str = odd_str + ( char ) ( i + ' a ' ) ; return odd_str ; } } return odd_str ; } static String findPalindromicString ( String str ) { int len = str . length ( ) ; int freq [ ] = new int [ MAX_CHAR ] ; countFreq ( str , freq , len ) ; if ( ! canMakePalindrome ( freq , len ) ) { return " No ▁ Palindromic ▁ String " ; } String odd_str = findOddAndRemoveItsFreq ( freq ) ; String front_str = " " , rear_str = " ▁ " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { String temp = " " ; if ( freq [ i ] != 0 ) { char ch = ( char ) ( i + ' a ' ) ; for ( int j = 1 ; j <= freq [ i ] / 2 ; j ++ ) { temp = temp + ch ; } front_str = front_str + temp ; rear_str = temp + rear_str ; } } return ( front_str + odd_str + rear_str ) ; } public static void main ( String [ ] args ) { String str = " malayalam " ; System . out . println ( findPalindromicString ( str ) ) ; } }
public class GFG { static boolean checkEquality ( String s ) { return ( s . charAt ( 0 ) == s . charAt ( s . length ( ) - 1 ) ) ; } static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) if ( checkEquality ( s . substring ( i , i + len ) ) ) result ++ ; return result ; } public static void main ( String args [ ] ) { String s = " abcab " ; System . out . println ( countSubstringWithEqualEnds ( s ) ) ; } }
public class GFG { static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; } public static void main ( String args [ ] ) { String s = " abcab " ; System . out . println ( countSubstringWithEqualEnds ( s ) ) ; } }
public class GFG { static char maxRepeating ( String str ) { int len = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } } return res ; } public static void main ( String args [ ] ) { String str = " aaaabbaaccde " ; System . out . println ( maxRepeating ( str ) ) ; } }
import java . util . * ; class GFG { static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; str1 = new StringBuilder ( str1 ) . reverse ( ) . toString ( ) ; str2 = new StringBuilder ( str2 ) . reverse ( ) . toString ( ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; str = new StringBuilder ( str ) . reverse ( ) . toString ( ) ; return str ; } public static void main ( String [ ] args ) { String str1 = "12" ; String str2 = "198111" ; System . out . println ( findSum ( str1 , str2 ) ) ; } }
import java . util . * ; class GFG { static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i + diff ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; return new StringBuilder ( str ) . reverse ( ) . toString ( ) ; } public static void main ( String [ ] args ) { String str1 = "12" ; String str2 = "198111" ; System . out . println ( findSum ( str1 , str2 ) ) ; } }
class GFG { static boolean areChractersUnique ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; } public static void main ( String [ ] args ) { String s = " aaabbccdaa " ; if ( areChractersUnique ( s ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
public class GFG { static int countWords ( String str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) count *= 1 ; else count *= 2 ; return count ; } public static void main ( String args [ ] ) { String str = " abc " ; int len = str . length ( ) ; System . out . println ( countWords ( str , len ) ) ; } }
class GFG { static int replaceDig ( int x , int from , int to ) { int result = 0 ; int multiply = 1 ; while ( x > 0 ) { int reminder = x % 10 ; if ( reminder == from ) result = result + to * multiply ; else result = result + reminder * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; } static void calculateMinMaxSum ( int x1 , int x2 ) { int minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) ; int maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) ; System . out . print ( " Minimum ▁ sum ▁ = ▁ " + minSum ) ; System . out . print ( " Maximum sum = " + maxSum); } public static void main ( String [ ] args ) { int x1 = 5466 , x2 = 4555 ; calculateMinMaxSum ( x1 , x2 ) ; } }
class GFG { static void qType1 ( int l , int x , char str [ ] ) { str [ l - 1 ] = ( char ) x ; } static void qType2 ( int l , int r , char str [ ] ) { int freq [ ] = new int [ 27 ] ; for ( int i = l - 1 ; i <= r - 1 ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } int count = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( freq [ j ] % 2 != 0 ) { count ++ ; } } if ( count <= 1 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { char str [ ] = " geeksforgeeks " . toCharArray ( ) ; int n = str . length ; qType1 ( 4 , ' g ' , str ) ; qType2 ( 1 , 4 , str ) ; qType2 ( 2 , 3 , str ) ; qType1 ( 10 , ' t ' , str ) ; qType2 ( 10 , 11 , str ) ; } }
class Test { static String findTwoscomplement ( StringBuffer str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == '1' ) break ; if ( i == - 1 ) return "1" + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == '1' ) str . replace ( k , k + 1 , "0" ) ; else str . replace ( k , k + 1 , "1" ) ; } return str . toString ( ) ; } public static void main ( String [ ] args ) { StringBuffer str = new StringBuffer ( "00000101" ) ; System . out . println ( findTwoscomplement ( str ) ) ; } }
import java . io . * ; class GFG { static boolean isequal ( String str ) { int n = str . length ( ) ; int num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( '0' <= str . charAt ( i ) && str . charAt ( i ) <= '9' ) { num = ( str . charAt ( i ) - '0' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; } static public void main ( String [ ] args ) { String str = " geeksforgeeks13" ; if ( isequal ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) return result ; } static public void main ( String [ ] args ) { System . out . println ( countToMake0lternate ( "000111" ) ) ; System . out . println ( countToMake0lternate ( "11111" ) ) ; System . out . println ( countToMake0lternate ( "01010101" ) ) ; } }
class GFG { static boolean isPossiblePalindrome ( char str [ ] ) { int n = str . length ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( str [ i ] != ' . ' && str [ n - i - 1 ] != ' . ' && str [ i ] != str [ n - i - 1 ] ) return false ; } return true ; } static void smallestPalindrome ( char str [ ] ) { if ( ! isPossiblePalindrome ( str ) ) System . out . println ( " Not ▁ Possible " ) ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' . ' ) { if ( str [ n - i - 1 ] != ' . ' ) str [ i ] = str [ n - i - 1 ] ; else str [ i ] = str [ n - i - 1 ] = ' a ' ; } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( str [ i ] + " " ) ; } public static void main ( String [ ] args ) { String str = " ab . . e . c . a " ; char [ ] s = str . toCharArray ( ) ; smallestPalindrome ( s ) ; } }
class GFG { public static char flip ( char ch ) { return ( ch == '0' ) ? '1' : '0' ; } public static int getFlipWithStartingCharcter ( String str , char expected ) { int flipCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != expected ) flipCount ++ ; expected = flip ( expected ) ; } return flipCount ; } public static int minFlipToMakeStringAlternate ( String str ) { return Math . min ( getFlipWithStartingCharcter ( str , '0' ) , getFlipWithStartingCharcter ( str , '1' ) ) ; } public static void main ( String args [ ] ) { String str = "0001010111" ; System . out . println ( minFlipToMakeStringAlternate ( str ) ) ; } }
class GFG { static int remainderWith7 ( String num ) { int series [ ] = { 1 , 3 , 2 , - 1 , - 3 , - 2 } ; int series_index = 0 ; int result = 0 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { int digit = num . charAt ( i ) - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; } public static void main ( String [ ] args ) { String str = "12345" ; System . out . print ( " Remainder ▁ with ▁ 7 ▁ is ▁ " + remainderWith7 ( str ) ) ; } }
class GFG { static String intToRoman ( int num ) { String m [ ] = { " " , " M " , " MM " , " MMM " } ; String c [ ] = { " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM " } ; String x [ ] = { " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " } ; String i [ ] = { " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " } ; String thousands = m [ num / 1000 ] ; String hundereds = c [ ( num % 1000 ) / 100 ] ; String tens = x [ ( num % 100 ) / 10 ] ; String ones = i [ num % 10 ] ; String ans = thousands + hundereds + tens + ones ; return ans ; } public static void main ( String [ ] args ) { int number = 3549 ; System . out . println ( intToRoman ( number ) ) ; } }
class GFG { static void pattern ( String str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { int j = len - 1 - i ; for ( int k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) System . out . print ( str . charAt ( k ) ) ; else System . out . print ( " ▁ " ) ; } System . out . println ( " " ) ; } } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int len = str . length ( ) ; pattern ( str , len ) ; } }
public class GFG { static final int no_of_chars = 256 ; static String findSubString ( String str , String pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } int hash_pat [ ] = new int [ no_of_chars ] ; int hash_str [ ] = new int [ no_of_chars ] ; for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat . charAt ( i ) ] ++ ; int start = 0 , start_index = - 1 , min_len = Integer . MAX_VALUE ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_str [ str . charAt ( j ) ] ++ ; if ( hash_str [ str . charAt ( j ) ] <= hash_pat [ str . charAt ( j ) ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] || hash_pat [ str . charAt ( start ) ] == 0 ) { if ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] ) hash_str [ str . charAt ( start ) ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } if ( start_index == - 1 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } return str . substring ( start_index , start_index + min_len ) ; } public static void main ( String [ ] args ) { String str = " this ▁ is ▁ a ▁ test ▁ string " ; String pat = " tist " ; System . out . print ( "Smallest window is :NEW_LINE " + findSubString ( str , pat ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static ArrayList < Integer > set = new ArrayList < Integer > ( ) ; static ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; static boolean isPrime ( int x ) { int sqroot = ( int ) Math . sqrt ( x ) ; if ( x == 1 ) return false ; for ( int i = 2 ; i <= sqroot ; i ++ ) if ( x % i == 0 ) return false ; return true ; } static void display ( ) { int length = set . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) System . out . print ( set . get ( i ) + " ▁ " ) ; System . out . println ( ) ; } static void primeSum ( int total , int N , int S , int index ) { if ( total == S && set . size ( ) == N ) { display ( ) ; return ; } if ( total > S || index == prime . size ( ) || set . size ( ) >= N ) return ; set . add ( prime . get ( index ) ) ; primeSum ( total + prime . get ( index ) , N , S , index + 1 ) ; set . remove ( set . size ( ) - 1 ) ; primeSum ( total , N , S , index + 1 ) ; } static void allPrime ( int N , int S , int P ) { for ( int i = P + 1 ; i <= S ; i ++ ) { if ( isPrime ( i ) ) prime . add ( i ) ; } if ( prime . size ( ) < N ) return ; primeSum ( 0 , N , S , 0 ) ; } public static void main ( String args [ ] ) { int S = 54 , N = 2 , P = 3 ; allPrime ( N , S , P ) ; } }
class GFG { static long F ( long A , long B ) { if ( A == 1 ) return ( 4 % B ) ; else { long temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } } public static void main ( String args [ ] ) { long A = 25 , B = 50 ; System . out . println ( F ( A , B ) ) ; } }
class GFG { static final int MOD = 1000000007 ; static int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = Math . max ( l , a ) ; int R = Math . min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; } public static void main ( String args [ ] ) { int l = 98 , r = 102 ; System . out . print ( rangeSum ( l , r ) ) ; } }
import java . util . Vector ; class GFG { static Vector < Integer > permutation = new Vector < > ( ) ; static void printPermutation ( ) { permutation . stream ( ) . forEach ( ( i ) -> { System . out . print ( i + " ▁ " ) ; } ) ; } static int give_random_number ( int l , int r ) { int x = ( int ) ( Math . random ( ) % ( r - l + 1 ) + l ) ; return x ; } static void generate_random_permutation ( int l , int r ) { if ( l > r ) return ; int n = give_random_number ( l , r ) ; permutation . add ( n ) ; generate_random_permutation ( l , n - 1 ) ; generate_random_permutation ( n + 1 , r ) ; } public static void main ( String [ ] args ) { int l = 5 ; int r = 15 ; generate_random_permutation ( l , r ) ; printPermutation ( ) ; } }
import java . util . * ; class solution { static int INF = 99999 ; static int size = 10 ; static int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n != 0 ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; } static int findMinimum ( int x ) { int low = 0 , high = 100000 ; int ans = high ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( getSetBitsFromOneToN ( mid ) >= x ) { ans = Math . min ( ans , mid ) ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; } public static void main ( String args [ ] ) { int x = 20 ; System . out . println ( findMinimum ( x ) ) ; } }
import java . io . * ; class GFG { static int trailingZeroes ( int n ) { int cnt = 0 ; while ( n > 0 ) { n /= 5 ; cnt += n ; } return cnt ; } static void binarySearch ( int n ) { int low = 0 ; int high = 1000000 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int count = trailingZeroes ( mid ) ; if ( count < n ) low = mid + 1 ; else high = mid ; } int result [ ] = new int [ 1000 ] ; int k = 0 ; while ( trailingZeroes ( low ) == n ) { result [ k ] = low ; k ++ ; low ++ ; } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( result [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int n = 3 ; binarySearch ( n ) ; } }
import java . lang . * ; class GFG { static int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . ceil ( eq_root ) + l ) ; } public static void main ( String [ ] args ) { System . out . println ( minDaysToEmpty ( 5 , 2 ) ) ; System . out . println ( minDaysToEmpty ( 6514683 , 4965 ) ) ; } }
class Main { static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 2 , 3 , 6 , 7 , 9 } ; int arr2 [ ] = { 1 , 4 , 8 , 10 } ; int k = 5 ; System . out . print ( kth ( arr1 , arr2 , 5 , 4 , k ) ) ; } }
import java . util . Arrays ; class GFG { static final int R = 2 ; static final int C = 2 ; static int bsearch ( int low , int high , int n , int arr [ ] ) { int mid = ( low + high ) / 2 ; if ( low <= high ) { if ( arr [ mid ] < n ) return bsearch ( mid + 1 , high , n , arr ) ; return bsearch ( low , mid - 1 , n , arr ) ; } return low ; } static int mindiff ( int arr [ ] [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( arr [ i ] ) ; int ans = + 2147483647 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int p = bsearch ( 0 , m - 1 , arr [ i ] [ j ] , arr [ i + 1 ] ) ; ans = Math . min ( ans , Math . abs ( arr [ i + 1 ] [ p ] - arr [ i ] [ j ] ) ) ; if ( p - 1 >= 0 ) ans = Math . min ( ans , Math . abs ( arr [ i + 1 ] [ p - 1 ] - arr [ i ] [ j ] ) ) ; } } return ans ; } public static void main ( String [ ] args ) { int m [ ] [ ] = { { 8 , 5 } , { 6 , 8 } } ; System . out . println ( mindiff ( m , R , C ) ) ; } }
import java . io . * ; class GFG { static int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 } ; int n = arr . length ; int index = binarySearch ( arr , 1 , n - 2 ) ; if ( index != - 1 ) System . out . println ( arr [ index ] ) ; } }
class Test { static int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 4 , 5 } ; int index = findRepeatingElement ( arr , 0 , arr . length - 1 ) ; if ( index != - 1 ) System . out . println ( arr [ index ] ) ; } }
import java . io . * ; class GFG { static double diff ( double n , double mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; } static double cubicRoot ( double n ) { double start = 0 , end = n ; double e = 0.0000001 ; while ( true ) { double mid = ( start + end ) / 2 ; double error = diff ( n , mid ) ; if ( error <= e ) return mid ; if ( ( mid * mid * mid ) > n ) end = mid ; else start = mid ; } } public static void main ( String [ ] args ) { double n = 3 ; System . out . println ( " Cube ▁ root ▁ of ▁ " + n + " ▁ is ▁ " + cubicRoot ( n ) ) ; } }
class GFG { static int floorSqrt ( int x ) { if ( x == 0 x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; } public static void main ( String [ ] args ) { int x = 11 ; System . out . print ( floorSqrt ( x ) ) ; } }
class GFG { static int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( ( n - 2 ) * 180 ) ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . print ( sumOfInternalAngles ( n ) ) ; } }
class GFG { static float diagonal_length ( float a ) { float L ; L = a * ( float ) Math . sqrt ( 3 ) ; return L ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( diagonal_length ( a ) ) ; } }
class GFG { static double PI = 3.14 ; static double find_area ( int r , int d ) { double R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; double area = PI * Math . pow ( R , 2 ) ; return area ; } public static void main ( String [ ] args ) { int r = 4 , d = 5 ; System . out . println ( find_area ( r , d ) ) ; } }
class GFG { public static int Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; } public static void main ( String [ ] args ) { int a = 80 , b = 70 , c = 100 , d = 110 ; if ( Valid ( a , b , c , d ) == 1 ) System . out . println ( " Valid ▁ quadrilateral " ) ; else System . out . println ( " Invalid ▁ quadrilateral " ) ; } }
import java . io . * ; class GFG { static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; } public static void main ( String [ ] args ) { int x1 = - 10 , y1 = 8 ; int x2 = 14 , y2 = - 24 ; int r1 = 30 , r2 = 10 ; int t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) System . out . println ( " There ▁ are ▁ 3 ▁ common ▁ tangents " + " ▁ between ▁ the ▁ circles . " ) ; else if ( t < 0 ) System . out . println ( " There ▁ are ▁ 4 ▁ common ▁ tangents " + " ▁ between ▁ the ▁ circles . " ) ; else System . out . println ( " There ▁ are ▁ 2 ▁ common ▁ tangents " + " ▁ between ▁ the ▁ circles . " ) ; } }
import java . io . * ; class GFG { static int GCD ( int a , int b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; } static void ratiotang ( int r1 , int r2 ) { System . out . println ( " The ▁ ratio ▁ is ▁ " + r1 / GCD ( r1 , r2 ) + " : " + r2 / GCD ( r1 , r2 ) ) ; } public static void main ( String [ ] args ) { int r1 = 4 , r2 = 8 ; ratiotang ( r1 , r2 ) ; } }
import java . io . * ; class GFG { static int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; } public static void main ( String [ ] args ) { int V = 5 , E = 7 ; System . out . println ( Regions ( V , E ) ) ; } }
class GFG { static int GCD ( int a , int b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; } static void ratiotang ( int r1 , int r2 ) { System . out . println ( " The ▁ ratio ▁ is ▁ " + r1 / GCD ( r1 , r2 ) + " ▁ : ▁ " + r2 / GCD ( r1 , r2 ) ) ; } public static void main ( String args [ ] ) { int r1 = 4 , r2 = 6 ; ratiotang ( r1 , r2 ) ; } }
class GFG { static void lengthOfTangent ( double r1 , double r2 , double d ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ transverse " + " ▁ common ▁ tangent ▁ is ▁ " + Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 + r2 ) , 2 ) ) ) ; } public static void main ( String args [ ] ) { double r1 = 4 , r2 = 6 , d = 12 ; lengthOfTangent ( r1 , r2 , d ) ; } }
class GFG { static int remainingArea ( int N , int M , int K ) { while ( K -- > 0 && N > 0 && M > 0 ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; } public static void main ( String [ ] args ) { int N = 5 , M = 3 , K = 2 ; System . out . println ( remainingArea ( N , M , K ) ) ; } }
class GFG { static void lengtang ( double r1 , double r2 ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ " + " direct ▁ common ▁ tangent ▁ is ▁ " + ( 2 * Math . sqrt ( r1 * r2 ) ) ) ; } public static void main ( String [ ] args ) { double r1 = 5 , r2 = 9 ; lengtang ( r1 , r2 ) ; } }
class GFG { static void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { System . out . println ( " The ▁ shortest ▁ distance ▁ " + " between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " + ( Math . sqrt ( ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) ) ; } public static void main ( String [ ] args ) { double x1 = 4 , y1 = 6 , x2 = 35 , y2 = 42 , r = 5 ; dist ( x1 , y1 , x2 , y2 , r ) ; } }
class GFG { static double dist ( double m , double b1 , double b2 ) { double d = Math . abs ( b2 - b1 ) / ( ( m * m ) - 1 ) ; return d ; } public static void main ( String [ ] args ) { double m = 2 , b1 = 4 , b2 = 3 ; System . out . println ( dist ( m , b1 , b2 ) ) ; } }
class GFG { static float normal ( float m , float n ) { float N = ( float ) ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; } public static void main ( String [ ] args ) { float m = - 5 , n = 3 ; System . out . println ( normal ( m , n ) ) ; } }
class GFG { static boolean isPossible ( int a [ ] , int n ) { int sum = 0 , maxS = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = Math . max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 4 } ; int n = a . length ; if ( isPossible ( a , n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static float findAreaShaded ( float a ) { float sqArea = a * a ; float semiCircleArea = ( float ) ( 3.14 * ( a * a ) / 8 ) ; float ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; } public static void main ( String [ ] args ) { float a = 10 ; System . out . println ( findAreaShaded ( a ) ) ; } }
class GfG { static int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } } public static void main ( String [ ] args ) { int x = 4 , y = 3 ; System . out . println ( countSteps ( x , y ) ) ; } }
import java . util . * ; class GfG { static boolean isSlopeGood ( double slope , int arr [ ] , int n ) { Set < Double > setOfLines = new HashSet < Double > ( ) ; for ( int i = 0 ; i < n ; i ++ ) setOfLines . add ( arr [ i ] - slope * ( i ) ) ; return setOfLines . size ( ) == 2 ; } static boolean checkForParallel ( int arr [ ] , int n ) { boolean slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) ; boolean slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) ; boolean slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) / 2 , arr , n ) ; return ( slope1 == true slope2 == true slope3 == true ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 6 , 3 , 8 , 5 } ; int n = arr . length ; if ( checkForParallel ( arr , n ) == true ) System . out . println ( "1" ) ; else System . out . println ( "0" ) ; } }
class GFG { static boolean pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; } public static void main ( String [ ] args ) { int m = 3 , c = 2 ; int x = 1 , y = 5 ; if ( pointIsOnLine ( m , c , x , y ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . io . * ; class GFG { static float Area ( float a , float b ) { if ( a < 0 && b < 0 ) return - 1 ; float h = ( float ) Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; float A = ( float ) ( 0.70477 * Math . pow ( h , 2 ) ) ; return A ; } public static void main ( String [ ] args ) { float a = 5 , b = 4 ; System . out . println ( Area ( a , b ) ) ; } }
class GFG { static int maxRectangles ( int L , int B , int l , int b ) { int horizontal = 0 , vertical = 0 ; if ( l <= L && b <= B ) { int columns = B / b ; int rows = L / l ; horizontal = rows * columns ; } if ( l <= B && b <= L ) { int columns = L / b ; int rows = B / l ; vertical = rows * columns ; } return Math . max ( horizontal , vertical ) ; } public static void main ( String [ ] args ) { int L = 10 , B = 7 , l = 4 , b = 3 ; System . out . print ( maxRectangles ( L , B , l , b ) ) ; } }
import java . io . * ; class GFG { static float cone ( float a ) { if ( a < 0 ) return - 1 ; float r = ( float ) ( a * Math . sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( cone ( a ) ) ; } }
import java . io . * ; class GFG { static float Area ( float a ) { if ( a < 0 ) return - 1 ; float h = ( float ) 1.268 * a ; float A = ( float ) ( 0.70477 * Math . pow ( h , 2 ) ) ; return A ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( Area ( a ) ) ; } }
import java . lang . Math ; class GFG { static float Area ( float r ) { if ( r < 0 ) return - 1 ; float x = ( 2 * r ) / ( float ) ( Math . sqrt ( 5 ) ) ; float A = 0.70477f * ( float ) ( Math . pow ( x , 2 ) ) ; return A ; } public static void main ( String [ ] args ) { float r = 5 ; System . out . println ( Area ( r ) ) ; } }
class GFG { static float Area ( float a ) { if ( a < 0 ) return - 1 ; float x = 0.464f * a ; float A = 0.70477f * ( float ) Math . pow ( x , 2 ) ; return A ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( String . format ( " % .5f " , Area ( a ) ) ) ; } }
class GFG { static double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / Math . pow ( 2 , fold ) ; } public static void main ( String [ ] args ) { double side = 4 , fold = 2 ; System . out . println ( areaSquare ( side , fold ) ) ; } }
import java . util . * ; class GFG { static double ReuleauxArea ( double r ) { if ( r < 0 ) return - 1 ; double A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; } public static void main ( String args [ ] ) { double r = 6 ; System . out . println ( ReuleauxArea ( r ) ) ; } }
import java . lang . Math ; class cfg { static float cyl ( float a ) { if ( a < 0 ) return - 1 ; float r = ( 2 * a * ( float ) ( Math . sqrt ( 2 ) ) / 3 ) ; float h = ( 2 * a ) / 3 ; float V = ( 3.14f * ( float ) ( Math . pow ( r , 2 ) * h ) ) ; return V ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( cyl ( a ) ) ; } }
import java . util . * ; import java . text . DecimalFormat ; class GFG { static double Area ( double l , double b , double h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; double x = ( l * b ) / ( l + b ) ; double A = 0.70477 * Math . pow ( x , 2 ) ; return A ; } public static void main ( String args [ ] ) { double l = 5 , b = 12 , h = 13 ; DecimalFormat df = new DecimalFormat ( " # , # # # , # #0.00000" ) ; System . out . println ( df . format ( Area ( l , b , h ) ) ) ; } }
class cfg { static float squareSide ( float a ) { if ( a < 0 ) return - 1 ; float x = ( 0.423f * a ) ; return x ; } public static void main ( String [ ] args ) { float a = 8 ; System . out . println ( squareSide ( a ) ) ; } }
import java . util . * ; class GFG { static boolean isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( Math . ceil ( a ) == 1 && Math . floor ( a ) == 1 ) return true ; return false ; } public static void main ( String args [ ] ) { float l = 0.70710678f , m = 0.5f , n = 0.5f ; if ( isPossible ( l , m , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( float ) ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; } public static void main ( String [ ] args ) { float a = 9 , n = 10 ; System . out . printf ( " % .3f " , polydiagonal ( n , a ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static double decdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.902 * a ; return d ; } public static void main ( String [ ] args ) { int a = 9 ; System . out . println ( decdiagonal ( a ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static double heptdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.802 * a ; return d ; } public static void main ( String [ ] args ) { int a = 6 ; System . out . println ( heptdiagonal ( a ) ) ; } }
public class GFG { static double hexDiagonal ( float a ) { if ( a < 0 ) return - 1 ; double d = ( double ) 1.73 * a ; return d ; } public static void main ( String [ ] args ) { float a = 9 ; System . out . println ( hexDiagonal ( a ) ) ; } }
public class GFG { static double ReuleauxArea ( float a ) { if ( a < 0 ) return - 1 ; double A = ( double ) 0.70477 * Math . pow ( a , 2 ) ; return A ; } public static void main ( String args [ ] ) { float a = 6 ; System . out . println ( ReuleauxArea ( a ) ) ; } }
class Solution { static float squareArea ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) ( Math . pow ( 1.268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; } public static void main ( String args [ ] ) { float a = 6 ; System . out . println ( squareArea ( a ) ) ; } }
public class GFG { static float CubeVolume ( float d ) { float Volume ; Volume = ( float ) ( Math . sqrt ( 3 ) * Math . pow ( d , 3 ) ) / 9 ; return Volume ; } public static void main ( String [ ] args ) { float d = 5 ; System . out . println ( " Volume ▁ of ▁ Cube : ▁ " + CubeVolume ( d ) ) ; } }
import java . lang . * ; class GFG { public static double per ( double a , double b ) { return ( a + b ) ; } public static double area ( double s ) { return ( s / 2 ) ; } public static void main ( String [ ] args ) { double a = 7 , b = 8 , s = 10 ; System . out . println ( per ( a , b ) ) ; System . out . println ( area ( s ) ) ; } }
import java . lang . * ; class GFG { static double PI = 3.14159265 ; public static double area_leaf ( double a ) { return ( a * a * ( PI / 2 - 1 ) ) ; } public static void main ( String [ ] args ) { double a = 7 ; System . out . println ( area_leaf ( a ) ) ; } }
import java . lang . * ; class GFG { static double PI = 3.14159265 ; public static double length_rope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } public static void main ( String [ ] args ) { double r = 7 ; System . out . println ( length_rope ( r ) ) ; } }
import java . lang . * ; class GFG { static double PI = 3.14159265 ; public static double area_inscribed ( double P , double B , double H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; } public static void main ( String [ ] args ) { double P = 3 , B = 4 , H = 5 ; System . out . println ( area_inscribed ( P , B , H ) ) ; } }
import java . lang . * ; class GFG { static double PI = 3.14159265 ; public static double area_cicumscribed ( double c ) { return ( c * c * ( PI / 4 ) ) ; } public static void main ( String [ ] args ) { double c = 8.0 ; System . out . println ( area_cicumscribed ( c ) ) ; } }
import java . io . * ; class GFG { static double cyl ( double r , double h ) { if ( r < 0 && h < 0 ) return - 1 ; double R = ( 2 * r ) / 3 ; double H = ( 2 * h ) / 3 ; double V = 3.14 * Math . pow ( R , 2 ) * H ; return V ; } public static void main ( String [ ] args ) { double r = 4 , h = 8 ; System . out . println ( cyl ( r , h ) ) ; } }
class Solution { static float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( float ) Math . pow ( h , 3 ) ; return a ; } public static void main ( String args [ ] ) { float h = 5 , r = 4 ; System . out . println ( cube ( h , r ) ) ; } }
import java . io . * ; class GFG { static float sph ( float r , float h ) { if ( r < 0 && h < 0 ) return - 1 ; float R = r ; return R ; } public static void main ( String [ ] args ) { float r = 4 , h = 8 ; System . out . println ( sph ( r , h ) ) ; } }
import java . io . * ; class GFG { static float cyl ( float R ) { if ( R < 0 ) return - 1 ; float V = ( float ) ( ( 2 * 3.14 * Math . pow ( R , 3 ) ) / ( 3 * Math . sqrt ( 3 ) ) ) ; return V ; } public static void main ( String [ ] args ) { float R = 4 ; System . out . print ( cyl ( R ) ) ; } }
import java . io . * ; class GFG { static float rod ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float l = ( float ) ( Math . sqrt ( Math . pow ( h , 2 ) + 4 * Math . pow ( r , 2 ) ) ) ; return l ; } public static void main ( String [ ] args ) { float h = 4 ; float r = 1.5f ; System . out . print ( rod ( h , r ) ) ; } }
import java . lang . * ; class GFG { static double PI = 3.14159265 ; public static double area_inscribed ( double a ) { return ( a * a * ( PI / 12 ) ) ; } public static double perm_inscribed ( double a ) { return ( PI * ( a / Math . sqrt ( 3 ) ) ) ; } public static void main ( String [ ] args ) { double a = 6.0 ; System . out . println ( " Area ▁ of ▁ inscribed ▁ circle ▁ is ▁ : " + area_inscribed ( a ) ) ; System . out . println ( " Perimeter of inscribed circle is : " + perm_inscribed ( a ) ) ; } }
import java . io . * ; class GFG { static float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( h * r * ( float ) Math . sqrt ( 2 ) ) / ( h + ( float ) Math . sqrt ( 2 ) * r ) ; return a ; } public static void main ( String [ ] args ) { float h = 5 , r = 6 ; System . out . println ( cube ( h , r ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static float coner ( float R ) { if ( R < 0 ) return - 1 ; float r = ( float ) ( 2 * Math . sqrt ( 2 ) * R ) / 3 ; return r ; } static float coneh ( float R ) { if ( R < 0 ) return - 1 ; float h = ( 4 * R ) / 3 ; return h ; } public static void main ( String args [ ] ) { float R = 10 ; System . out . println ( " r ▁ = ▁ " + coner ( R ) + " , ▁ " + " h ▁ = ▁ " + coneh ( R ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static float coneRadius ( float a ) { if ( a < 0 ) return - 1 ; float r = ( float ) ( a / Math . sqrt ( 2 ) ) ; return r ; } static float coneHeight ( float a ) { if ( a < 0 ) return - 1 ; float h = a ; return h ; } public static void main ( String args [ ] ) { float a = 6 ; System . out . println ( " r ▁ = ▁ " + coneRadius ( a ) + " , ▁ " + " h ▁ = ▁ " + coneHeight ( a ) ) ; } }
import java . util . * ; class Solution { static float largestCube ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 2 * r ) / ( float ) Math . sqrt ( 3 ) ; return a ; } public static void main ( String args [ ] ) { float r = 5 ; System . out . println ( largestCube ( r ) ) ; } }
class GFG { static float sphere ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; return r ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( sphere ( a ) ) ; } }
class GFG { static int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; } public static void main ( String args [ ] ) { int M = 4 , N = 4 ; int Cuts = numberOfCuts ( M , N ) ; System . out . println ( " Maximum ▁ cuts ▁ = ▁ " + Cuts ) ; } }
import java . util . * ; class Geeks { static float maxVol ( float P , float A ) { float l = ( float ) ( P - Math . sqrt ( P * P - 24 * A ) ) / 12 ; float V = ( float ) ( l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ) ; return V ; } public static void main ( String args [ ] ) { float P = 20 , A = 16 ; System . out . println ( maxVol ( P , A ) ) ; } }
import java . io . * ; class GFG { static int rhombusAreaPeri ( int d1 , int d2 ) { int area , perimeter ; area = ( d1 * d2 ) / 2 ; perimeter = ( int ) ( 2 * Math . sqrt ( Math . pow ( d1 , 2 ) + Math . pow ( d2 , 2 ) ) ) ; System . out . println ( " The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " + d1 + " ▁ and ▁ " + d2 + " ▁ is ▁ " + area + " . " ) ; System . out . println ( " The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " + d1 + " ▁ and ▁ " + d2 + " ▁ is ▁ " + perimeter + " . " ) ; return 0 ; } public static void main ( String [ ] args ) { int d1 = 2 , d2 = 4 ; rhombusAreaPeri ( d1 , d2 ) ; } }
import java . io . * ; class GFG { static int maxArea ( float perimeter ) { int length = ( int ) Math . ceil ( perimeter / 4 ) ; int breadth = ( int ) Math . floor ( perimeter / 4 ) ; return length * breadth ; } public static void main ( String [ ] args ) { float n = 38 ; System . out . println ( " Maximum ▁ Area ▁ = ▁ " + maxArea ( n ) ) ; } }
import java . util . * ; import java . text . * ; class solution { static void foot ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; DecimalFormat form = new DecimalFormat ( "0.0" ) ; System . out . print ( " ▁ x2 ▁ = ▁ " + form . format ( x2 ) ) ; System . out . print ( " ▁ y2 ▁ = ▁ " + form . format ( y2 ) ) ; System . out . print ( " ▁ z2 ▁ = ▁ " + form . format ( z2 ) ) ; } public static void main ( String arr [ ] ) { float a = 1 ; float b = - 2 ; float c = 0 ; float d = 0 ; float x1 = - 1 ; float y1 = 3 ; float z1 = 4 ; foot ( a , b , c , d , x1 , y1 , z1 ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int countRectangles ( int l , int w ) { int squareSide = __gcd ( l , w ) ; return ( l * w ) / ( squareSide * squareSide ) ; } public static void main ( String [ ] args ) { int l = 4 , w = 6 ; System . out . println ( countRectangles ( l , w ) ) ; } }
import java . util . * ; class solution { static void circle_equation ( double x1 , double y1 , double r ) { double a = - 2 * x1 ; double b = - 2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; System . out . print ( " x ^ 2 ▁ + ▁ ( " + a + " ▁ x ) ▁ + ▁ " ) ; System . out . print ( " y ^ 2 ▁ + ▁ ( " + b + " ▁ y ) ▁ = ▁ " ) ; System . out . println ( c + " . " ) ; } public static void main ( String arr [ ] ) { double x1 = 2 , y1 = - 3 , r = 8 ; circle_equation ( x1 , y1 , r ) ; } }
import java . io . * ; class GFG { static float area ( float r ) { return ( float ) ( ( 0.5 ) * ( 3.14 ) * ( r * r ) ) ; } static float perimeter ( float r ) { return ( float ) ( ( 3.14 ) * ( r ) ) ; } public static void main ( String [ ] args ) { float r = 10 ; System . out . println ( " The ▁ Area ▁ of ▁ Semicircle : ▁ " + area ( r ) ) ; System . out . println ( " The ▁ Perimeter ▁ of ▁ Semicircle : " + + perimeter ( r ) ) ; } }
public class GFG { static boolean checkEquilibrium ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int resx = x1 + x2 + x3 ; int resy = y1 + y2 + y3 ; int resz = z1 + z2 + z3 ; if ( resx == 0 & resy == 0 & resz == 0 ) return true ; else return false ; } public static void main ( String args [ ] ) { int x1 = - 2 , y1 = - 7 , z1 = - 9 , x2 = 5 , y2 = - 14 , z2 = 14 , x3 = - 3 , y3 = 21 , z3 = - 5 ; if ( checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ) System . out . println ( " The ▁ vectors ▁ are ▁ at ▁ equilibrium . " ) ; else System . out . println ( " The ▁ vectors ▁ are ▁ not ▁ at ▁ equilibrium . " ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void findTangent ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) System . out . println ( " y ▁ = ▁ " + dif + " x " + ( x * dif + y ) ) ; else if ( dif > 0 ) System . out . println ( " y ▁ = ▁ " + dif + " x + " + - x * dif + y ) ; else System . out . println ( " Not ▁ possible " ) ; } } public static void main ( String args [ ] ) { int A = 2 , x = 2 , y = 0 ; findTangent ( A , x , y ) ; } }
import java . io . * ; class GFG { static float hexadiagonal ( float a ) { if ( a < 0 ) return - 1 ; return 2 * a ; } public static void main ( String [ ] args ) { float a = 4 ; System . out . print ( hexadiagonal ( a ) ) ; } }
import java . io . * ; class GFG { static double octaside ( double a ) { if ( a < 0 ) return - 1 ; double s = a / ( Math . sqrt ( 2 ) + 1 ) ; return s ; } public static void main ( String [ ] args ) { double a = 4 ; System . out . println ( octaside ( a ) ) ; } }
import java . io . * ; public class GFG { static boolean Arrive ( int a , int b , int n ) { if ( n >= Math . abs ( a ) + Math . abs ( b ) && ( n - ( Math . abs ( a ) + Math . abs ( b ) ) ) % 2 == 0 ) return true ; return false ; } int main ( ) { return 0 ; } public static void main ( String [ ] args ) { int a = 5 , b = 5 , n = 11 ; if ( Arrive ( a , b , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static boolean Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; } public static void main ( String [ ] args ) { int a = 3 , x = 2 , b = 7 ; if ( Move ( a , x , b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static float area ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float A = a * b ; return A ; } public static void main ( String [ ] args ) { float a = 5 , b = 2 ; System . out . println ( area ( a , b ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float radius = ( float ) Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; } public static void main ( String args [ ] ) { float l = 4 , b = 3 ; System . out . println ( findRadiusOfcircumcircle ( l , b ) ) ; } }
import java . * ; class gfg { public double circlearea ( double a , double b , double c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; double p = ( a + b + c ) / 2 ; double At = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; double A = 3.14 * Math . pow ( ( ( a * b * c ) / ( 4 * At ) ) , 2 ) ; return A ; } } class geek { public static void main ( String [ ] args ) { gfg g = new gfg ( ) ; double a = 4 , b = 5 , c = 3 ; System . out . println ( g . circlearea ( a , b , c ) ) ; } }
import java . io . * ; class GFG { static float altitude ( float a , float b ) { return ( float ) ( Math . sqrt ( Math . pow ( a , 2 ) - ( Math . pow ( b , 2 ) / 4 ) ) ) ; } static float area ( float b , float h ) { return ( 1 * b * h ) / 2 ; } public static void main ( String [ ] args ) { float a = 2 , b = 3 ; float h = altitude ( a , b ) ; System . out . print ( " Altitude = ▁ " + h + " , ▁ " ) ; System . out . print ( " Area = ▁ " + area ( b , h ) ) ; } }
import java . io . * ; class GFG { static int surfaceArea ( int b , int s ) { return 2 * b * s + ( int ) Math . pow ( b , 2 ) ; } public static void main ( String [ ] args ) { int b = 3 , s = 4 ; System . out . println ( surfaceArea ( b , s ) ) ; } }
import java . util . * ; class GFG { static float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float area = ( l * b ) / 2 ; return area ; } public static void main ( String args [ ] ) { float l = 5 , b = 4 ; System . out . println ( trianglearea ( l , b ) ) ; } }
import java . io . * ; class GFG { static void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } public static void main ( String [ ] args ) { int n = 100 ; int x = 51 , y = 100 ; halfsquare ( n , x , y ) ; } }
public class GFG { static boolean check ( long a , long b , long p , long q ) { long d = p * p + q * q ; if ( d == 0 ) return a == 0 && b == 0 ; else return ( a * p + b * q ) % d == 0 && ( b * p - a * q ) % d == 0 ; } static boolean check ( int a , int b , int x , int y , int p , int q ) { if ( check ( a - x , b - y , p , q ) || check ( a + x , b + y , p , q ) || check ( a - y , b + x , p , q ) || check ( a + y , b - x , p , q ) ) return true ; else return false ; } public static void main ( String args [ ] ) { int a = - 4 , b = - 2 ; int x = 0 , y = 0 ; int p = - 2 , q = - 1 ; if ( check ( a , b , x , y , p , q ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static float trianglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = ( float ) ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / ( 4 * b ) ; return area ; } public static void main ( String [ ] args ) { float a = 4 , b = 2 ; System . out . println ( trianglearea ( a , b ) ) ; } }
import java . io . * ; class GFG { static float squarearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = 4 * ( float ) ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ; return area ; } public static void main ( String [ ] args ) { float a = 4 , b = 2 ; System . out . println ( squarearea ( a , b ) ) ; } }
import java . io . * ; class GFG { static float trianglearea ( float r ) { if ( r < 0 ) return - 1 ; return r * r ; } public static void main ( String [ ] args ) { float r = 5 ; System . out . println ( trianglearea ( r ) ) ; } }
import java . io . * ; class GFG { static float squarearea ( float r ) { if ( r < 0 ) return - 1 ; float a = 4 * ( float ) ( Math . pow ( r , 2 ) / 5 ) ; return a ; } public static void main ( String [ ] args ) { float r = 5 ; System . out . println ( squarearea ( r ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; } public static void main ( String args [ ] ) { float a = 10 , b = 8 ; System . out . println ( rectanglearea ( a , b ) ) ; } }
public class GFG { static float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; } public static void main ( String [ ] args ) { float l = 5 , b = 12 , h = 13 ; System . out . println ( squareArea ( l , b , h ) ) ; } }
class GFG { static int MAX = 50 ; static void solveQuery ( int n , int q , int qi [ ] , int qj [ ] ) { int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i <= n ; i ++ ) arr [ i ] = 0 ; for ( int k = 0 ; k < q ; k ++ ) { int flag = 0 ; if ( qj [ k ] < qi [ k ] ) { int temp = qi [ k ] ; qi [ k ] = qj [ k ] ; qj [ k ] = temp ; } if ( arr [ qi [ k ] ] != 0 arr [ qj [ k ] ] != 0 ) flag = 1 ; else if ( qi [ k ] == qj [ k ] ) flag = 1 ; else { for ( int i = 1 ; i < qi [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] < qj [ k ] && qi [ k ] < arr [ i ] ) { flag = 1 ; break ; } } if ( flag == 0 ) { for ( int i = qi [ k ] + 1 ; i < qj [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] > qj [ k ] ) { flag = 1 ; break ; } } } } if ( flag == 0 ) { System . out . println ( " YES " ) ; arr [ qi [ k ] ] = qj [ k ] ; arr [ qj [ k ] ] = qi [ k ] ; } else System . out . println ( " NO " ) ; } } public static void main ( String [ ] args ) { int n = 10 ; int q = 7 ; int qi [ ] = { 1 , 2 , 2 , 2 , 9 , 10 , 8 } ; int qj [ ] = { 5 , 7 , 3 , 4 , 9 , 9 , 6 } ; solveQuery ( n , q , qi , qj ) ; } }
class GFG { static int squares ( int l , int b , int a ) { return ( int ) ( Math . ceil ( l / ( double ) a ) * Math . ceil ( b / ( double ) a ) ) ; } public static void main ( String [ ] args ) { int l = 11 , b = 23 , a = 14 ; System . out . println ( squares ( l , b , a ) ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } static int squarearea ( int l , int b ) { if ( l < 0 b < 0 ) return - 1 ; int n = ( l * b ) / gcd ( l , b ) ; return n * n ; } public static void main ( String [ ] args ) { int l = 6 , b = 4 ; System . out . println ( squarearea ( l , b ) ) ; } }
class GFG { static double angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; double den = Math . sqrt ( Math . pow ( ( x2 - x1 ) , 2 ) + Math . pow ( ( y2 - y1 ) , 2 ) + Math . pow ( ( z2 - z1 ) , 2 ) ) * Math . sqrt ( Math . pow ( ( x3 - x1 ) , 2 ) + Math . pow ( ( y3 - y1 ) , 2 ) + Math . pow ( ( z3 - z1 ) , 2 ) ) ; double angle = Math . acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; } public static void main ( String [ ] args ) { int x1 = - 1 ; int y1 = 3 ; int z1 = 2 ; int x2 = 2 ; int y2 = 3 ; int z2 = 5 ; int x3 = 3 ; int y3 = 5 ; int z3 = - 2 ; double angle_A = angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) ; double angle_B = angle_triangle ( x2 , x3 , x1 , y2 , y3 , y1 , z2 , z3 , z1 ) ; double angle_C = angle_triangle ( x3 , x2 , x1 , y3 , y2 , y1 , z3 , z2 , z1 ) ; System . out . println ( " Angles ▁ are ▁ : " ) ; System . out . println ( " angle ▁ A ▁ = ▁ " + angle_A + " ▁ degree " ) ; System . out . println ( " angle ▁ B ▁ = ▁ " + angle_B + " ▁ degree " ) ; System . out . println ( " angle ▁ C ▁ = ▁ " + angle_C + " ▁ degree " ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int solve ( int M , int N , int s ) { if ( N % s == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( M % s == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return M * N ; } public static void main ( String args [ ] ) { int N = 12 , M = 13 , s = 4 ; System . out . println ( solve ( M , N , s ) ) ; } }
class GFG { static int solve ( double M , double N , double s ) { int ans = ( ( int ) ( Math . ceil ( M / s ) ) * ( int ) ( Math . ceil ( N / s ) ) ) ; return ans ; } public static void main ( String [ ] args ) { double N = 12 , M = 13 , s = 4 ; System . out . println ( solve ( M , N , s ) ) ; } }
import java . io . * ; class GFG { static void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; System . out . println ( " equation ▁ of ▁ plane ▁ is ▁ " + a + " ▁ x ▁ + ▁ " + b + " ▁ y ▁ + ▁ " + c + " ▁ z ▁ + ▁ " + d + " ▁ = ▁ 0 . " ) ; } public static void main ( String [ ] args ) { float x1 = - 1 ; float y1 = 2 ; float z1 = 1 ; float x2 = 0 ; float y2 = - 3 ; float z2 = 2 ; float x3 = 1 ; float y3 = 1 ; float z3 = - 4 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; } }
import java . io . * ; class GFG { static void shortest_distance ( float x1 , float y1 , float a , float b , float c ) { double d = Math . abs ( ( ( a * x1 + b * y1 + c ) ) / ( Math . sqrt ( a * a + b * b ) ) ) ; System . out . println ( " Perpendicular ▁ " + " distance ▁ is ▁ " + d ) ; return ; } public static void main ( String [ ] args ) { float x1 = 5 ; float y1 = 6 ; float a = - 2 ; float b = 3 ; float c = 4 ; shortest_distance ( x1 , y1 , a , b , c ) ; } }
import java . util . * ; class solution { static void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 1st ▁ octant " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 2nd ▁ octant " ) ; else if ( x < 0 && y < 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 3rd ▁ octant " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 4th ▁ octant " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 5th ▁ octant " ) ; else if ( x < 0 && y >= 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 6th ▁ octant " ) ; else if ( x < 0 && y < 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 7th ▁ octant " ) ; else if ( x >= 0 && y < 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 8th ▁ octant " ) ; } public static void main ( String args [ ] ) { float x = 2 , y = 3 , z = 4 ; octant ( x , y , z ) ; x = - 4 ; y = 2 ; z = - 8 ; octant ( x , y , z ) ; x = - 6 ; y = - 2 ; z = 8 ; octant ( x , y , z ) ; } }
import java . io . * ; class GFG { static int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( countNumberOfTriangles ( n ) ) ; } }
import java . io . * ; class GFG { static long centeredTridecagonalNum ( long n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; } public static void main ( String [ ] args ) { long n = 3 ; System . out . println ( centeredTridecagonalNum ( n ) ) ; n = 10 ; System . out . println ( centeredTridecagonalNum ( n ) ) ; } }
import java . io . * ; class GFG { static int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( pentagon_pyramidal ( n ) ) ; } }
import java . io . * ; class GFG { static int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( pentagon_pyramidal ( n ) ) ; } }
import java . io . * ; class GFG { static boolean checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; } public static void main ( String [ ] args ) { int a1 = 2 , b1 = - 3 , c1 = 5 ; int a2 = 3 , b2 = 4 , c2 = - 7 ; int a3 = 9 , b3 = - 5 , c3 = 8 ; if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int center_octadecagon_num ( int n ) { return 9 * n * n - 9 * n + 1 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( n + " th ▁ centered ▁ " + " octadecagonal ▁ number ▁ : ▁ " ) ; System . out . println ( center_octadecagon_num ( n ) ) ; n = 13 ; System . out . print ( n + " th ▁ centered ▁ " + " octadecagonal ▁ number ▁ : ▁ " ) ; System . out . println ( center_octadecagon_num ( n ) ) ; } }
import java . io . * ; class GFG { static int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( n + " th ▁ centered ▁ " + " decagonal ▁ number : ▁ " ) ; System . out . println ( centereddecagonalnum ( n ) ) ; n = 9 ; System . out . print ( n + " th ▁ centered ▁ " + " decagonal ▁ number : ▁ " ) ; System . out . println ( centereddecagonalnum ( n ) ) ; } }
import java . io . * ; class GFG { static int factorial ( int a , int b ) { int res = 1 ; for ( int i = 1 ; i <= ( a + b ) ; i ++ ) res = res * i ; for ( int i = 1 ; i <= a ; i ++ ) res = res / i ; for ( int i = 1 ; i <= b ; i ++ ) res = res / i ; return res ; } static void Ksmallest ( int x , int y , int k ) { if ( x == 0 && y == 0 ) return ; else if ( x == 0 ) { y -- ; System . out . print ( " V " ) ; Ksmallest ( x , y , k ) ; } else if ( y == 0 ) { x -- ; System . out . print ( " H " ) ; Ksmallest ( x , y , k ) ; } else { if ( factorial ( x - 1 , y ) > k ) { System . out . print ( " H " ) ; Ksmallest ( x - 1 , y , k ) ; } else { System . out . print ( " V " ) ; Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) ; } } } public static void main ( String [ ] args ) { int x = 2 , y = 2 , k = 2 ; Ksmallest ( x , y , k ) ; } }
import java . io . * ; class GFG { static int centered_pentagonal_Num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( n + " th ▁ Centered ▁ " + " pentagonal ▁ number : ▁ " ) ; System . out . println ( centered_pentagonal_Num ( n ) ) ; } }
import java . io . * ; class GFG { static int pivotDis ( int x0 , int y0 , int x1 , int y1 ) { return ( int ) Math . sqrt ( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) ) ; } static int minDis ( int D , int r1 , int r2 ) { return Math . max ( ( D - r1 - r2 ) , 0 ) ; } static int maxDis ( int D , int r1 , int r2 ) { return D + r1 + r2 ; } public static void main ( String [ ] args ) { int x0 = 0 , y0 = 0 , x1 = 8 , y1 = 0 , r1 = 4 , r2 = 5 ; int D = pivotDis ( x0 , y0 , x1 , y1 ) ; System . out . print ( " Distance ▁ while ▁ " + " repulsion ▁ = ▁ " + maxDis ( D , r1 , r2 ) ) ; System . out . print ( " Distance while " + " attraction ▁ = ▁ " + minDis ( D , r1 , r2 ) ) ; } }
class GFG { static void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; System . out . println ( " x2 ▁ = ▁ " + x2 + " , ▁ " + " y2 ▁ = ▁ " + y2 ) ; } public static void main ( String args [ ] ) { int x1 = - 4 , y1 = - 1 , m1 = 3 , m2 = 5 ; otherEndPoint ( x1 , y1 , m1 , m2 ) ; } }
import java . util . Arrays ; import java . util . Collections ; class GFG { static void printRect ( Integer X [ ] , Integer Y [ ] , int n ) { int Xmax = Collections . max ( Arrays . asList ( X ) ) ; int Xmin = Collections . min ( Arrays . asList ( X ) ) ; int Ymax = Collections . max ( Arrays . asList ( Y ) ) ; int Ymin = Collections . min ( Arrays . asList ( Y ) ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymin + " } " ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymax + " } " ) ; System . out . println ( " { " + Xmax + " , ▁ " + Ymax + " } " ) ; System . out . println ( " { " + Xmax + " , ▁ " + Ymin + " } " ) ; } public static void main ( String [ ] args ) { Integer X [ ] = { 4 , 3 , 6 , 1 , - 1 , 12 } ; Integer Y [ ] = { 4 , 1 , 10 , 3 , 7 , - 1 } ; int n = X . length ; printRect ( X , Y , n ) ; } }
import java . io . * ; class GFG { static boolean checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; } public static void main ( String [ ] args ) { if ( checkOrigin ( 1 , 28 , 2 , 56 ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static boolean isBetween ( int a , int b , int c ) { return ( Math . min ( a , b ) <= c && c <= Math . max ( a , b ) ) ; } static boolean canJoin ( int x [ ] , int y [ ] , int i , int j , int k ) { return ( x [ k ] == x [ i ] x [ k ] == x [ j ] ) && isBetween ( y [ i ] , y [ j ] , y [ k ] ) || ( y [ k ] == y [ i ] y [ k ] == y [ j ] ) && isBetween ( x [ i ] , x [ j ] , x [ k ] ) ; } static int countLineSegments ( int x [ ] , int y [ ] ) { if ( ( x [ 0 ] == x [ 1 ] && x [ 1 ] == x [ 2 ] ) || ( y [ 0 ] == y [ 1 ] && y [ 1 ] == y [ 2 ] ) ) return 1 ; else if ( canJoin ( x , y , 0 , 1 , 2 ) || canJoin ( x , y , 0 , 2 , 1 ) || canJoin ( x , y , 1 , 2 , 0 ) ) return 2 ; else return 3 ; } public static void main ( String [ ] args ) { int x [ ] = new int [ 3 ] , y [ ] = new int [ 3 ] ; x [ 0 ] = - 1 ; y [ 0 ] = - 1 ; x [ 1 ] = - 1 ; y [ 1 ] = 3 ; x [ 2 ] = 4 ; y [ 2 ] = 3 ; System . out . println ( countLineSegments ( x , y ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static Boolean pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 2 , d = 3 ; if ( pythagorean_quadruple ( a , b , c , d ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class demo { static float pi = 3.14159f ; public static float volume ( float r , float R , float h ) { return ( float ) 1 / 3 * pi * h * ( r * r + R * R + r * R ) ; } public static float curved_surface_area ( float r , float R , float l ) { return pi * l * ( R + r ) ; } public static float total_surface_area ( float r , float R , float l , float h ) { return pi * l * ( R + r ) + pi * ( r * r + R * R ) ; } public static void main ( String args [ ] ) { float small_radius = 3 ; float big_radius = 8 ; float slant_height = 13 ; float height = 12 ; System . out . print ( " Volume ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " ) ; System . out . println ( volume ( small_radius , big_radius , height ) ) ; System . out . print ( " Curved ▁ Surface ▁ Area ▁ Of " + " ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " ) ; System . out . println ( curved_surface_area ( small_radius , big_radius , slant_height ) ) ; System . out . print ( " Total ▁ Surface ▁ Area ▁ Of " + " ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " ) ; System . out . println ( total_surface_area ( small_radius , big_radius , slant_height , height ) ) ; } }
import java . io . * ; class GFG { int Circumference ( int a ) { return 4 * a ; } public static void main ( String args [ ] ) { GFG obj = new GFG ( ) ; int a = 5 ; System . out . println ( " Circumference ▁ of ▁ " + " a ▁ square ▁ is ▁ " + obj . Circumference ( a ) ) ; } }
import java . io . * ; class GFG { static double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; } public static void main ( String [ ] args ) { double a = 1 , b = 2 , c = 1 , d = 2 ; System . out . println ( maxArea ( a , b , c , d ) ) ; } }
import java . util . Arrays ; class GFG { static int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( dis ) ; return dis [ k - 1 ] ; } public static void main ( String [ ] args ) { int k = 3 ; int [ ] x = { 1 , - 1 , 1 } ; int [ ] y = { 1 , - 1 , - 1 } ; int n = x . length ; System . out . println ( minRadius ( k , x , y , n ) ) ; } }
import java . io . * ; class Geometry { static int areaRectangle ( int a , int b ) { int area = a * b ; return area ; } static int perimeterRectangle ( int a , int b ) { int perimeter = 2 * ( a + b ) ; return perimeter ; } public static void main ( String [ ] args ) { int a = 5 ; int b = 6 ; System . out . println ( " Area ▁ = ▁ " + areaRectangle ( a , b ) ) ; System . out . println ( " Perimeter ▁ = ▁ " + perimeterRectangle ( a , b ) ) ; } }
import java . util . * ; class GFG { static int areaSquare ( int side ) { int area = side * side ; return area ; } public static void main ( String [ ] args ) { int side = 5 ; System . out . println ( areaSquare ( 4 ) ) ; } }
import java . util . * ; class GFG { public static long minPerimeter ( int n ) { int l = ( int ) Math . sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( minPerimeter ( n ) ) ; } }
import java . util . Arrays ; class GFG { static void possibleOrNot ( long a1 , long a2 , long b1 , long b2 , long c1 , long c2 ) { long dis1 = ( long ) Math . pow ( b1 - a1 , 2 ) + ( long ) Math . pow ( b2 - a2 , 2 ) ; long dis2 = ( long ) Math . pow ( c1 - b1 , 2 ) + ( long ) Math . pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) System . out . print ( " No " ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) System . out . print ( " No " ) ; else System . out . print ( " Yes " ) ; } public static void main ( String [ ] args ) { long a1 = 1 , a2 = 0 , b1 = 2 , b2 = 0 , c1 = 3 , c2 = 0 ; possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) ; } }
import java . io . * ; class GFG { static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; } public static void main ( String [ ] args ) { int x1 = - 10 , y1 = 8 ; int x2 = 14 , y2 = - 24 ; int r1 = 30 , r2 = 10 ; int t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) System . out . println ( " Circle ▁ touch ▁ to " + " ▁ each ▁ other . " ) ; else if ( t < 0 ) System . out . println ( " Circle ▁ not ▁ touch " + " ▁ to ▁ each ▁ other . " ) ; else System . out . println ( " Circle ▁ intersect " + " ▁ to ▁ each ▁ other . " ) ; } }
class GFG { static int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; } public static void main ( String arg [ ] ) { int k = 6 , a = 1 , b = 3 ; System . out . print ( countObtuseAngles ( a , b , k ) ) ; } }
import java . util . * ; class GFG { static void findTriangle ( int a [ ] , int n ) { int b [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; int x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i + 1 ; int q = i + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = Math . max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += Math . max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += Math . max ( p - j , 0 ) ; z += q - p ; } } } System . out . println ( " Acute ▁ Triangle : ▁ " + x ) ; System . out . println ( " Right ▁ Triangle : ▁ " + y ) ; System . out . println ( " Obtuse ▁ Triangle : ▁ " + z ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 9 , 10 , 12 , 15 } ; int n = arr . length ; findTriangle ( arr , n ) ; } }
import java . io . * ; class GFG { public static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; } public static void main ( String [ ] args ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = 3 ; System . out . println ( polygonArea ( X , Y , n ) ) ; } }
class GFG { static void last_digit ( int X , int Y ) { System . out . print ( X % Y ) ; } public static void main ( String [ ] args ) { int X = 55 , Y = 3 ; last_digit ( X , Y ) ; } }
class GFG { static void printRoots ( long a , long b , long c ) { System . out . println ( 1 + " , ▁ " + c / ( a * 1.0 ) ) ; } public static void main ( String [ ] args ) { long a = 2 ; long b = 3 ; long c = - 5 ; printRoots ( a , b , c ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int MAX = 130 ; static boolean validQuadruple ( int arr [ ] , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; } public static void main ( String [ ] args ) throws java . lang . Exception { int arr [ ] = { 1 , 0 , 2 , 3 , 7 } ; int n = arr . length ; if ( validQuadruple ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static boolean solve ( int n , int k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int n = 12 , k = 4 ; if ( solve ( n , k ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . io . * ; class GFG { static int closetAND ( int arr [ ] , int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 7 , 10 } ; int n = arr . length ; int k = 2 ; System . out . println ( closetAND ( arr , n , k ) ) ; } }
class GFG { static int Rate ( int N1 , int N2 ) { float rate = ( N2 - N1 ) * 100 / N1 ; return ( int ) rate ; } public static void main ( String [ ] args ) { int N1 = 100 , N2 = 120 ; System . out . println ( Rate ( N1 , N2 ) + " ▁ % " ) ; } }
import java . util . * ; class GFG { static int getPrime ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; Vector < Boolean > prime = new Vector < > ( max_val + 1 ) ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) prime . add ( i , Boolean . TRUE ) ; prime . add ( 1 , Boolean . FALSE ) ; prime . add ( 2 , Boolean . FALSE ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime . get ( p ) == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime . add ( i , Boolean . FALSE ) ; } } int maximum = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime . get ( arr [ i ] ) ) { maximum = Math . max ( maximum , arr [ i ] ) ; } } return maximum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 10 , 15 , 7 , 6 , 8 , 13 } ; int n = arr . length ; System . out . println ( getPrime ( arr , n ) ) ; } }
class GFG { static long getMinNum ( int N ) { int lcm = 1 ; for ( int i = 2 ; i <= N ; i ++ ) lcm = ( ( i * lcm ) / ( __gcd ( i , lcm ) ) ) ; return ( lcm + 1 ) ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void main ( String args [ ] ) { int N = 5 ; System . out . println ( getMinNum ( N ) ) ; } }
class GFG { public static double maxEdges ( double N ) { double edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; } public static void main ( String [ ] args ) { double N = 5 ; System . out . println ( maxEdges ( N ) ) ; } }
class GFG { static void Permutation ( int n , int k ) { int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( p [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; Permutation ( n , k ) ; } }
class GFG { static int validPosition ( int arr [ ] , int N , int K ) { int count = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 6 , 7 } , K = 4 ; int N = arr . length ; System . out . println ( validPosition ( arr , N , K ) ) ; } }
class GFG { static int maxBitElement ( int arr [ ] , int n ) { int num = 0 , max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = Integer . bitCount ( arr [ i ] ) ; if ( cnt > max ) { max = cnt ; num = arr [ i ] ; } } return num ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 4 , 7 , 1 , 10 , 5 , 8 , 9 , 6 } ; int n = arr . length ; System . out . print ( maxBitElement ( arr , n ) ) ; } }
class GFG { static int smallestSum ( int n ) { if ( n == 1 ) return 0 ; return ( 2 * ( int ) Math . pow ( 10 , n - 1 ) ) ; } static int largestSum ( int n ) { return ( 2 * ( ( int ) Math . pow ( 10 , n ) - 1 ) ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( " Largest ▁ = ▁ " + largestSum ( n ) ) ; System . out . print ( " Smallest ▁ = ▁ " + smallestSum ( n ) ) ; } }
class GFG { static int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd1 ++ ; } else { even1 ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) { odd2 ++ ; } else { even2 ++ ; } } int pairs = Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) ; return pairs ; } public static void main ( String [ ] args ) { int a [ ] = { 9 , 14 , 6 , 2 , 11 } ; int b [ ] = { 8 , 4 , 7 , 20 } ; int n = a . length ; int m = b . length ; System . out . println ( count_pairs ( a , b , n , m ) ) ; } }
class GFG { static int find_leftmost_unsetbit ( int n ) { int ind = - 1 ; int i = 1 ; while ( n > 0 ) { if ( ( n % 2 ) != 1 ) { ind = i ; } i ++ ; n >>= 1 ; } return ind ; } static void perform_steps ( int n ) { int left = find_leftmost_unsetbit ( n ) ; if ( left == - 1 ) { System . out . print ( " No ▁ steps ▁ required " ) ; return ; } int step = 1 ; while ( find_leftmost_unsetbit ( n ) != - 1 ) { if ( step % 2 == 0 ) { n += 1 ; System . out . println ( " Step " + step + " : ▁ Increase ▁ by ▁ 1" ) ; } else { int m = find_leftmost_unsetbit ( n ) ; int num = ( int ) ( Math . pow ( 2 , m ) - 1 ) ; n = n ^ num ; System . out . println ( " Step " + step + " : ▁ Xor ▁ with ▁ " + num ) ; } step += 1 ; } } public static void main ( String [ ] args ) { int n = 39 ; perform_steps ( n ) ; } }
class GFG { static int vertices ( int N , int A , int B ) { int position = 0 ; int minisum = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { int x = Math . abs ( i - A ) ; int y = Math . abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; } public static void main ( String [ ] args ) { int N = 3 , A = 1 , B = 2 ; System . out . println ( " Vertex ▁ = ▁ " + vertices ( N , A , B ) ) ; } }
class GFG { static int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; } static int sumFactorial ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += factorial ( arr [ i ] ) ; } return s ; } public static void main ( String [ ] args ) { int [ ] arr = { 7 , 3 , 5 , 4 , 8 } ; int n = arr . length ; System . out . println ( sumFactorial ( arr , n ) ) ; } }
class GFG { static int highestPower ( String str , int len ) { int ans = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '0' ) ans ++ ; else break ; } return ans ; } public static void main ( String [ ] args ) { String str = "100100" ; int len = str . length ( ) ; System . out . println ( highestPower ( str , len ) ) ; } }
class GFG { static long mod = ( long ) ( 1e9 + 7 ) ; static long factorial ( long n , long p ) { for ( int i = 2 ; i <= n ; i ++ ) res = ( res * i ) % p ; return res ; } static long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long modInverse ( long n , long p ) { return power ( n , p - 2 , p ) ; } static long nCrModP ( long n , long r , long p ) { if ( r == 0 ) return 1 ; long fac [ ] = new long [ ( int ) n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ ( int ) n ] * modInverse ( fac [ ( int ) r ] , p ) % p * modInverse ( fac [ ( int ) n - ( int ) r ] , p ) % p ) % p ; } static long countArrangements ( long n , long k , long p ) { return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p ; } public static void main ( String [ ] args ) { long N = 5 , K = 8 ; System . out . println ( countArrangements ( N , K , mod ) ) ; } }
import java . io . * ; class GFG { static int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; } public static void main ( String [ ] args ) { int N = 390 ; System . out . println ( maxProd ( N ) ) ; } }
import java . io . * ; class GFG { static int N = 2 ; static int M = 3 ; static boolean check ( int mat [ ] [ ] ) { int xorr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xorr ^= mat [ i ] [ 0 ] ; } if ( xorr != 0 ) return true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ 0 ] ) return true ; } } return false ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 7 , 7 , 7 } , { 10 , 10 , 7 } } ; if ( check ( mat ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int sumodd ( int n ) { return ( n * n ) ; } static int sumeven ( int n ) { return ( n * ( n + 1 ) ) ; } static int findSum ( int num ) { int sumo = 0 ; int sume = 0 ; int x = 1 ; int cur = 0 ; int ans = 0 ; while ( num > 0 ) { int inc = Math . min ( x , num ) ; num -= inc ; if ( cur == 0 ) { ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) ; sumo += inc ; } else { ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) ; sume += inc ; } x *= 2 ; cur ^= 1 ; } return ans ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( findSum ( n ) ) ; } }
class GFG { static int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( oddTriangularNumber ( N ) ) ; } }
class GFG { static void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) System . out . println ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ identical " ) ; else System . out . println ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ not ▁ identical " ) ; } public static void main ( String [ ] args ) { double a1 = - 2 , b1 = 4 , c1 = 3 , a2 = - 6 , b2 = 12 , c2 = 9 ; idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) ; } }
class GFG { static void line ( double x0 , double y0 ) { double c = ( int ) ( 2 * y0 * x0 ) ; System . out . println ( y0 + " x " + " ▁ + ▁ " + x0 + " y ▁ = ▁ " + c ) ; } public static void main ( String [ ] args ) { double x0 = 4 , y0 = 3 ; line ( x0 , y0 ) ; } }
class GFG { static int N = 3 ; static int M = 7 ; static void printOriginalMatrix ( int a [ ] , int b [ ] , int [ ] [ ] mat ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) System . out . print ( Math . min ( a [ i ] , b [ j ] ) + " ▁ " ) ; else System . out . print ( "0" + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 2 , 1 , 3 } ; int b [ ] = { 2 , 3 , 0 , 0 , 2 , 0 , 1 } ; int [ ] [ ] mat = { { 1 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { 1 , 1 , 0 , 0 , 0 , 0 , 0 } } ; printOriginalMatrix ( a , b , mat ) ; } }
class GFG { static float percent ( int n , int x ) { float p = n * x ; p /= 100 ; return p ; } static float getLoss ( int price [ ] , int quantity [ ] , int X [ ] , int n ) { float loss = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float originalPrice = price [ i ] ; float sellingPrice = originalPrice + percent ( ( int ) originalPrice , X [ i ] ) ; float afterDiscount = sellingPrice - percent ( ( int ) sellingPrice , X [ i ] ) ; loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; } return loss ; } public static void main ( String args [ ] ) { int price [ ] = { 20 , 48 , 200 , 100 } ; int quantity [ ] = { 20 , 48 , 1 , 1 } ; int X [ ] = { 0 , 48 , 200 , 5 } ; int n = X . length ; System . out . print ( getLoss ( price , quantity , X , n ) ) ; } }
class GFG { static int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 5 , 3 } ; int n = arr . length ; System . out . print ( maxAbsDiff ( arr , n ) ) ; } }
class GFG { static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } static int maximizeSum ( int a [ ] , int n ) { int cnt = 0 ; int mini = Integer . MAX_VALUE ; int minSubarray = Integer . MAX_VALUE ; int sum = maxSubArraySum ( a , n ) ; int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; cnt ++ ; minSubarray = Math . min ( a [ i ] , minSubarray ) ; if ( sum == max_ending_here ) { if ( cnt == 1 ) mini = Math . min ( mini , 0 ) ; else mini = Math . min ( mini , minSubarray ) ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; cnt = 0 ; minSubarray = Integer . MAX_VALUE ; } } return sum - mini ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , - 2 , 3 } ; int n = a . length ; System . out . println ( maximizeSum ( a , n ) ) ; } }
class GFG { static boolean isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; } public static void main ( String args [ ] ) { int n = 132 ; if ( isOsiris ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . lang . Math ; class GFG { static boolean isDudeney ( int n ) { int cube_rt = ( int ) ( Math . round ( ( Math . pow ( n , 1.0 / 3.0 ) ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; int dig_sum = 0 ; int temp = n ; while ( temp > 0 ) { int rem = temp % 10 ; dig_sum += rem ; temp /= 10 ; } if ( cube_rt != dig_sum ) return false ; return true ; } public static void main ( String [ ] args ) { int n = 17576 ; if ( isDudeney ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int countTriangles ( int a [ ] , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 2 , 2 , 2 } ; int n = a . length ; System . out . println ( countTriangles ( a , n ) ) ; } }
class GFG { static int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . pow ( 10 , n - 1 ) ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( smallestMultiple ( n ) ) ; } }
class GFG { static int getHCF ( int x , int y ) { int minimum = Math . min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( int i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; } public static void main ( String [ ] args ) { int x = 16 , y = 32 ; System . out . println ( getHCF ( x , y ) ) ; } }
class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean isDivisible ( int n ) { if ( isPrime ( n + 1 ) ) return false ; return true ; } public static void main ( String [ ] args ) { int n = 6 ; if ( isDivisible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int R = 5 ; static int C = 5 ; static int findMaxCock ( int ar [ ] [ ] ) { if ( R < 3 C < 3 ) return - 1 ; int max_sum = Integer . MIN_VALUE ; for ( int i = 0 ; i < R - 2 ; i ++ ) { for ( int j = 0 ; j < C - 2 ; j ++ ) { int sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ; max_sum = Math . max ( max_sum , sum ) ; } } return max_sum ; } public static void main ( String [ ] args ) { int ar [ ] [ ] = { { 0 , 3 , 0 , 6 , 0 } , { 0 , 1 , 1 , 0 , 0 } , { 1 , 1 , 1 , 0 , 0 } , { 0 , 0 , 2 , 0 , 1 } , { 0 , 2 , 0 , 1 , 3 } } ; System . out . println ( findMaxCock ( ar ) ) ; } }
import java . util . HashMap ; class GFG { public static int segments ( int n , int [ ] p , int m ) { HashMap < Integer , Integer > c = new HashMap < > ( ) ; c . put ( 0 , 1 ) ; boolean has = false ; int sum = 0 ; int ans = 0 ; for ( int r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) has = true ; if ( has ) ans += ( c . get ( sum ) == null ? 0 : c . get ( sum ) ) + ( c . get ( sum - 1 ) == null ? 0 : c . get ( sum - 1 ) ) ; else c . put ( sum , c . get ( sum ) == null ? 1 : c . get ( sum ) + 1 ) ; } return ans ; } public static void main ( String [ ] args ) { int [ ] a = { 2 , 4 , 5 , 3 , 1 } ; int n = a . length ; int m = 4 ; System . out . println ( segments ( n , a , m ) ) ; } }
class GFG { static int oddDays ( int N ) { int hund1 = N / 100 ; int hund4 = N / 400 ; int leap = N >> 2 ; int ord = N - leap ; if ( hund1 > 0 ) { ord += hund1 ; leap -= hund1 ; } if ( hund4 > 0 ) { ord -= hund4 ; leap += hund4 ; } int days = ord + leap * 2 ; int odd = days % 7 ; return odd ; } public static void main ( String args [ ] ) { int N = 100 ; System . out . print ( oddDays ( N ) ) ; } }
class GFG { static float ellipsearea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( float ) ( ( 3.14f * r * r ) / 4 ) ; return a ; } public static void main ( String [ ] args ) { float r = 5 ; System . out . println ( ellipsearea ( r ) ) ; } }
class GfG { static int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int n = arr . length ; int x = 2 ; System . out . println ( CntDivbyX ( arr , n , x ) ) ; } }
public class GfG { static int countCon ( int ar [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; } public static void main ( String [ ] args ) { int ar [ ] = { 1 , 2 , 2 , 3 , 4 , 4 , 5 , 5 , 5 , 5 } ; int n = ar . length ; System . out . println ( countCon ( ar , n ) ) ; } }
class GFG { static void reduceFraction ( int x , int y ) { int d ; d = __gcd ( x , y ) ; x = x / d ; y = y / d ; System . out . println ( " x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int x = 16 ; int y = 10 ; reduceFraction ( x , y ) ; } }
class GFG { static float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; } public static void main ( String [ ] args ) { int T1 = 3 , N1 = 5 , T2 = 6 ; System . out . println ( noOfYears ( T1 , N1 , T2 ) ) ; } }
class GFG { static boolean isPossible ( int n ) { int fac [ ] = new int [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 19 ; if ( isPossible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static void findSubsequence ( int [ ] arr , int n , int k ) { HashMap < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( M . containsKey ( arr [ i ] ) ) M . put ( arr [ i ] , M . get ( arr [ i ] ) + 1 ) ; else M . put ( arr [ i ] , 1 ) ; } int [ ] numCount = new int [ k + 1 ] ; for ( int i = 0 ; i <= k ; ++ i ) numCount [ i ] = 0 ; Iterator < HashMap . Entry < Integer , Integer > > itr = M . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { HashMap . Entry < Integer , Integer > entry = itr . next ( ) ; if ( entry . getKey ( ) <= k ) { for ( int i = 1 ; ; ++ i ) { if ( entry . getKey ( ) * i > k ) break ; numCount [ entry . getKey ( ) * i ] += entry . getValue ( ) ; } } else break ; } int lcm = 0 , length = 0 ; for ( int i = 1 ; i <= k ; ++ i ) { if ( numCount [ i ] > length ) { length = numCount [ i ] ; lcm = i ; } } if ( lcm == 0 ) System . out . println ( - 1 ) ; else { System . out . println ( " LCM ▁ = ▁ " + lcm + " ▁ Length ▁ = ▁ " + length ) ; System . out . print ( " Indexes ▁ = ▁ " ) ; for ( int i = 0 ; i < n ; ++ i ) if ( lcm % arr [ i ] == 0 ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int k = 14 ; int arr [ ] = { 2 , 3 , 4 , 5 } ; int n = arr . length ; findSubsequence ( arr , n , k ) ; } }
import java . util . * ; class GFG { static int mod = ( int ) ( 1e9 + 7 ) ; static int power ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static int findCount ( int N ) { int count = power ( 2 , N , mod ) ; return count ; } public static void main ( String [ ] args ) { int N = 25 ; System . out . println ( findCount ( N ) ) ; } }
class GFG { static int msb ( int x ) { int ret = 0 ; while ( ( x >> ( ret + 1 ) ) != 0 ) ret ++ ; return ret ; } static int xorRange ( int l , int r ) { int max_bit = msb ( r ) ; int mul = 2 ; int ans = 0 ; for ( int i = 1 ; i <= max_bit ; i ++ ) { if ( ( l / mul ) * mul == ( r / mul ) * mul ) { if ( ( ( l & ( 1 << i ) ) != 0 ) && ( r - l + 1 ) % 2 == 1 ) ans += mul ; mul *= 2 ; continue ; } int odd_c = 0 ; if ( ( ( l & ( 1 << i ) ) != 0 ) && l % 2 == 1 ) odd_c = ( odd_c ^ 1 ) ; if ( ( ( r & ( 1 << i ) ) != 0 ) && r % 2 == 0 ) odd_c = ( odd_c ^ 1 ) ; if ( odd_c != 0 ) ans += mul ; mul *= 2 ; } int zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) / 2 ; if ( l % 2 == 1 && r % 2 == 1 ) zero_bit_cnt ++ ; if ( zero_bit_cnt % 2 == 1 ) ans ++ ; return ans ; } public static void main ( String args [ ] ) { int l = 1 , r = 4 ; System . out . print ( xorRange ( l , r ) ) ; } }
class GFG { static long computeXOR ( int n ) { int x = n & 3 ; switch ( x ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } return 0 ; } public static void main ( String args [ ] ) { int l = 1 , r = 4 ; System . out . println ( computeXOR ( r ) ^ computeXOR ( l - 1 ) ) ; } }
class GFG { static int countNumbers ( int x , int n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; } public static void main ( String [ ] args ) { int n = 120 ; System . out . println ( countNumbers ( 1 , n ) ) ; } }
class GfG { static boolean checkfact ( int N , int countprime , int prime ) { int countfact = 0 ; if ( prime == 2 prime == 3 ) countfact ++ ; int divide = prime ; while ( N / divide != 0 ) { countfact += N / divide ; divide = divide * divide ; } if ( countfact >= countprime ) return true ; else return false ; } static boolean check ( int N ) { int sumsquares = ( N + 1 ) * ( 2 * N + 1 ) ; int countprime = 0 ; for ( int i = 2 ; i <= Math . sqrt ( sumsquares ) ; i ++ ) { int flag = 0 ; while ( sumsquares % i == 0 ) { flag = 1 ; countprime ++ ; sumsquares /= i ; } if ( flag == 1 ) { if ( ! checkfact ( N - 1 , countprime , i ) ) return false ; countprime = 0 ; } } if ( sumsquares != 1 ) if ( ! checkfact ( N - 1 , 1 , sumsquares ) ) return false ; return true ; } public static void main ( String [ ] args ) { int N = 5 ; if ( check ( N ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 7 , 1 , 1 } ; int n = arr . length ; System . out . println ( countNonIncreasing ( arr , n ) ) ; } }
class GFG { static int printPermutation ( int n ) { if ( n % 2 != 0 ) { System . out . println ( " - 1" ) ; } else for ( int i = 1 ; i <= n / 2 ; i ++ ) { System . out . print ( 2 * i + " ▁ " + ( ( 2 * i ) - 1 ) + " ▁ " ) ; } return n ; } public static void main ( String [ ] args ) { int n = 4 ; printPermutation ( n ) ; } }
class GFG { static int MAXN = 10000000 ; static int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; } public static void main ( String [ ] args ) { int n = 120 , m = 51840 ; int a = 2 , b = 3 ; System . out . println ( minimumSteps ( n , m , a , b ) ) ; } }
class GfG { static int minOperations ( int n , int m ) { if ( m % n != 0 ) return - 1 ; int minOperations = 0 ; int q = m / n ; while ( q % 2 == 0 ) { q = q / 2 ; minOperations ++ ; } while ( q % 3 == 0 ) { q = q / 3 ; minOperations ++ ; } if ( q == 1 ) return minOperations ; return - 1 ; } public static void main ( String [ ] args ) { int n = 120 , m = 51840 ; System . out . println ( minOperations ( n , m ) ) ; } }
import java . lang . Math ; class GFG { static int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } static int calculateSum ( int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += fib ( i ) ; return sum ; } public static void main ( String [ ] args ) { int l = 4 , r = 8 ; System . out . println ( calculateSum ( l , r ) ) ; } }
import java . lang . Math ; class GFG { static float sphereSide ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float R = ( float ) ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) / 2 ; return R ; } public static void main ( String [ ] args ) { float h = 5 , r = 6 ; System . out . println ( sphereSide ( h , r ) ) ; } }
class GFG { static int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( possibleways ( n ) ) ; } }
import java . util . * ; class GFG { static int countSubarrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { long product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 2 , 8 } ; int n = arr . length ; int K = 4 ; System . out . println ( countSubarrays ( arr , n , K ) ) ; } }
import java . util . * ; class GFG { static void printMaxValPair ( Vector < Long > v , int n ) { Collections . sort ( v ) ; long N = v . get ( ( int ) n - 1 ) ; if ( N % 2 == 1 ) { long first_maxima = N / 2 ; long second_maxima = first_maxima + 1 ; long ans1 = ( long ) 3e18 , ans2 = ( long ) 3e18 ; long from_left = - 1 , from_right = - 1 ; long from = - 1 ; for ( long i = 0 ; i < n ; ++ i ) { if ( v . get ( ( int ) i ) > first_maxima ) { from = i ; break ; } else { long diff = first_maxima - v . get ( ( int ) i ) ; if ( diff < ans1 ) { ans1 = diff ; from_left = v . get ( ( int ) i ) ; } } } from_right = v . get ( ( int ) from ) ; long diff1 = first_maxima - from_left ; long diff2 = from_right - second_maxima ; if ( diff1 < diff2 ) System . out . println ( N + " ▁ " + from_left ) ; else System . out . println ( N + " ▁ " + from_right ) ; } else { long maxima = N / 2 ; long ans1 = ( int ) 3e18 ; long R = - 1 ; for ( long i = 0 ; i < n - 1 ; ++ i ) { long diff = Math . abs ( v . get ( ( int ) i ) - maxima ) ; if ( diff < ans1 ) { ans1 = diff ; R = v . get ( ( int ) i ) ; } } System . out . println ( N + " ▁ " + R ) ; } } public static void main ( String args [ ] ) { long arr [ ] = { 1 , 1 , 2 , 3 , 6 , 1 } ; Vector < Long > v = new Vector < Long > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) v . add ( arr [ i ] ) ; int n = v . size ( ) ; printMaxValPair ( v , n ) ; } }
class GFG { static int Permutations ( int n , int k ) { int ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; System . out . println ( Permutations ( n , k ) ) ; } }
class GFG { static long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) ; p = p * p ; if ( n % 2 == 1 ) p = p * a ; return p ; } static int countIntegers ( long l , long r ) { long ans = 0 , i = 1 ; long v = power ( 2 , i ) ; while ( v <= r ) { while ( v <= r ) { if ( v >= l ) ans ++ ; v = v * 3 ; } i ++ ; v = power ( 2 , i ) ; } if ( l == 1 ) ans ++ ; return ( int ) ans ; } public static void main ( String [ ] args ) { long l = 12 , r = 21 ; System . out . println ( countIntegers ( l , r ) ) ; } }
class GfG { static int findPairCount ( int N , int K ) { int count = 0 ; int rem [ ] = new int [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; } public static void main ( String [ ] args ) { int N = 10 , K = 4 ; System . out . println ( findPairCount ( N , K ) ) ; } }
import java . util . * ; class GFG { static final int N = 1000005 ; static boolean prime [ ] = new boolean [ N ] ; static void sieve ( ) { Arrays . fill ( prime , true ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int i = 2 ; i < N ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * 2 ; j < N ; j += i ) { prime [ j ] = false ; } } } } static int sumTruncatablePrimes ( int n ) { int sum = 0 ; for ( int i = 2 ; i < n ; i ++ ) { int num = i ; boolean flag = true ; while ( num > 0 ) { if ( ! prime [ num ] ) { flag = false ; break ; } num /= 10 ; } num = i ; int power = 10 ; while ( num / power > 0 ) { if ( ! prime [ num % power ] ) { flag = false ; break ; } power *= 10 ; } if ( flag ) { sum += i ; } } return sum ; } public static void main ( String [ ] args ) { int n = 25 ; sieve ( ) ; System . out . println ( sumTruncatablePrimes ( n ) ) ; } }
class GFG { static void nDigitPerfectSquares ( int n ) { int smallest = ( int ) Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) ; System . out . print ( smallest + " ▁ " ) ; int largest = ( int ) Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ; System . out . print ( largest ) ; } public static void main ( String args [ ] ) { int n = 4 ; nDigitPerfectSquares ( n ) ; } }
class GFG { static int N = 3 ; static int MaxTraceSub ( int mat [ ] [ ] ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . max ( trace , max_trace ) ; } } } return max_trace ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 10 , 2 , 5 } , { 6 , 10 , 4 } , { 2 , 7 , - 10 } } ; System . out . println ( MaxTraceSub ( mat ) ) ; } }
import java . util . * ; class GFG { static final int n = 3 ; static final int m = 3 ; static boolean check ( int a [ ] [ ] , int b [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { Vector < Integer > v1 = new Vector < Integer > ( ) ; Vector < Integer > v2 = new Vector < Integer > ( ) ; int r = i ; int col = 0 ; while ( r >= 0 && col < m ) { v1 . add ( a [ r ] [ col ] ) ; v2 . add ( b [ r ] [ col ] ) ; r -- ; col ++ ; } Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; for ( int j = 0 ; j < v1 . size ( ) ; j ++ ) { if ( v1 . get ( j ) != v2 . get ( j ) ) { return false ; } } } for ( int j = 1 ; j < m ; j ++ ) { Vector < Integer > v1 = new Vector < Integer > ( ) ; Vector < Integer > v2 = new Vector < Integer > ( ) ; int r = n - 1 ; int col = j ; while ( r >= 0 && col < m ) { v1 . add ( a [ r ] [ col ] ) ; v2 . add ( b [ r ] [ col ] ) ; r -- ; col ++ ; } Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) { if ( v1 . get ( i ) != v2 . get ( i ) ) { return false ; } } } return true ; } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int b [ ] [ ] = { { 1 , 4 , 7 } , { 2 , 5 , 6 } , { 3 , 8 , 9 } } ; if ( check ( a , b ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class Solution { public static void lastDigit ( String a , String b ) { int lastDig = ( a . charAt ( a . length ( ) - 1 ) - '0' ) * ( b . charAt ( b . length ( ) - 1 ) - '0' ) ; System . out . println ( lastDig % 10 ) ; } public static void main ( String [ ] args ) { String a = "1234567891233" , b = "1234567891233156" ; lastDigit ( a , b ) ; } }
class GfG { static void printPalindrome ( int n ) { if ( n == 1 ) { System . out . println ( " Smallest ▁ Palindrome : ▁ 0" ) ; System . out . println ( " Largest ▁ Palindrome : ▁ 9" ) ; } else { System . out . println ( " Smallest ▁ Palindrome : ▁ " + ( int ) ( Math . pow ( 10 , n - 1 ) ) + 1 ) ; System . out . println ( " Largest ▁ Palindrome : ▁ " + ( ( int ) ( Math . pow ( 10 , n ) ) - 1 ) ) ; } } public static void main ( String [ ] args ) { int n = 4 ; printPalindrome ( n ) ; } }
class GFG { static int printSum ( int a , int b ) { int res = 0 ; int temp1 = 0 , temp2 = 0 ; while ( a != 0 ) { temp1 = temp1 * 10 + ( a % 10 ) ; a /= 10 ; } a = temp1 ; while ( b != 0 ) { temp2 = temp2 * 10 + ( b % 10 ) ; b /= 10 ; } b = temp2 ; while ( a != 0 ) { int sum = ( a % 10 + b % 10 ) ; if ( sum / 10 == 0 ) { res = res * 10 + sum ; } else { temp1 = 0 ; while ( sum != 0 ) { temp1 = temp1 * 10 + ( sum % 10 ) ; sum /= 10 ; } sum = temp1 ; while ( sum != 0 ) { res = res * 10 + ( sum % 10 ) ; sum /= 10 ; } } a /= 10 ; b /= 10 ; } return res ; } public static void main ( String [ ] args ) { int a = 7752 , b = 8834 ; System . out . println ( printSum ( a , b ) ) ; } }
class GFG { static int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; } public static void main ( String args [ ] ) { int a = 100 ; int b = 10 ; System . out . print ( countDigits ( a , b ) ) ; } }
class GFG { public static int countDigits ( int a , int b ) { double digits = Math . log10 ( Math . abs ( a ) ) - Math . log10 ( Math . abs ( b ) ) + 1 ; return ( int ) Math . floor ( digits ) ; } public static void main ( String [ ] args ) { int a = 100 ; int b = 10 ; System . out . print ( countDigits ( a , b ) ) ; } }
class Solution { static int smallestOdd ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) + 1 ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( smallestOdd ( n ) ) ; } }
class GFG { static void findNumbers ( int n ) { int odd = ( int ) Math . pow ( 10 , n ) - 1 ; int even = odd - 1 ; System . out . println ( " Even ▁ = ▁ " + even ) ; System . out . print ( " Odd ▁ = ▁ " + odd ) ; } public static void main ( String args [ ] ) { int n = 4 ; findNumbers ( n ) ; } }
class GFG { static int longestSubArray ( int arr [ ] , int n ) { boolean isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 0 , 1 , 2 , 0 } ; int n = arr . length ; System . out . print ( longestSubArray ( arr , n ) ) ; } }
class Solution { static int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( smallestEven ( n ) ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int maxProfit ( int n , int a , int b , int x , int y ) { int res = x * ( n / a ) ; res += y * ( n / b ) ; res -= Math . min ( x , y ) * ( n / ( ( a * b ) / __gcd ( a , b ) ) ) ; return res ; } public static void main ( String [ ] args ) { int n = 6 , a = 6 , b = 2 , x = 8 , y = 2 ; System . out . println ( maxProfit ( n , a , b , x , y ) ) ; } }
class GFG { public static final int MOD = 1000000007 ; static int sumOfSeries ( int n ) { int ans = ( int ) Math . pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( sumOfSeries ( n ) ) ; } }
public class GFG { static int kthOdd ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int k = 2 ; System . out . print ( kthOdd ( arr , n , k ) ) ; } }
class GfG { static void lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int n = 12345 ; lastFiveDigits ( n ) ; } }
import java . util . * ; class GFG { static int mod = 1000000007 ; static long power ( long a , long n ) { if ( n == 0 ) { return 1 ; } long p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n == 1 ) { p = ( p * a ) % mod ; } return p ; } static long computeSum ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long maxs = ( power ( 2 , i ) - 1 + mod ) % mod ; maxs = ( maxs * arr [ i ] ) % mod ; long mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod ; mins = ( mins * arr [ i ] ) % mod ; long V = ( maxs - mins + mod ) % mod ; sum = ( sum + V ) % mod ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 3 , 1 } ; int n = arr . length ; System . out . println ( computeSum ( arr , n ) ) ; } }
class GFG { static int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * ( int ) Math . pow ( 10 , n / 2 - 1 ) ) ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . print ( countNumbers ( n ) ) ; } }
class GFG { static int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; } public static void main ( String args [ ] ) { int n = 7 ; System . out . print ( count ( n ) ) ; } }
import java . util . * ; class GFG1 { static int KthMinValAfterMconcatenate ( int [ ] A , int N , int M , int K ) { Arrays . sort ( A ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; } public static void main ( String [ ] args ) { int [ ] A = { 3 , 1 , 2 } ; int M = 3 , K = 4 ; int N = A . length ; System . out . println ( KthMinValAfterMconcatenate ( A , N , M , K ) ) ; } }
class GFG { static int sum ( int n ) { n = ( n + 1 ) / 2 ; return ( n * n ) ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . println ( sum ( n ) ) ; } }
class GFG { static int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( countNumbers ( n ) ) ; } }
class GFG { static int maxPrimes ( int n ) { return n / 2 ; } public static void main ( String [ ] args ) { int n = 17 ; System . out . println ( maxPrimes ( n ) ) ; } }
class GFG { static int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( sum ( n ) ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int findMinimum ( int n , int m ) { int mini = m ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int sec = n / i ; if ( __gcd ( m , i ) > 1 ) { return i ; } else if ( __gcd ( sec , m ) > 1 ) { mini = Math . min ( sec , mini ) ; } } } if ( mini == m ) return - 1 ; else return mini ; } public static void main ( String [ ] args ) { int n = 8 , m = 10 ; System . out . println ( findMinimum ( n , m ) ) ; } }
import java . lang . Math ; class GFG { public static int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( nthTerm ( N ) ) ; } }
class GFG { static int kthSmallest ( int n , int k ) { return ( 2 * k ) ; } public static void main ( String args [ ] ) { int n = 8 , k = 4 ; System . out . print ( kthSmallest ( n , k ) ) ; } }
class GFG { static boolean isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; } public static void main ( String args [ ] ) { int n = 10 ; if ( isSumOfPowersOfTwo ( n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static int findMinRemoval ( int arr [ ] , int n ) { int temp , value = 0 ; int maximum = 0 ; if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) + Math . abs ( arr [ i ] - arr [ i - 1 ] ) - Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = Math . max ( maximum , temp ) ; } return ( value - maximum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 3 , 2 , 10 } ; int n = arr . length ; System . out . print ( findMinRemoval ( arr , n ) + "NEW_LINE"); } }
class GFG { static double getTime ( int u , int v , int x ) { double speed = u + v ; double time = x / speed ; return time ; } public static void main ( String [ ] args ) { int u = 3 , v = 3 , x = 3 ; System . out . println ( getTime ( u , v , x ) ) ; } }
import java . io . * ; class GFG { static int number_of_teams ( int M ) { int N1 , N2 , sqr ; sqr = ( int ) Math . sqrt ( 1 + ( 8 * M ) ) ; N1 = ( 1 + sqr ) / 2 ; N2 = ( 1 - sqr ) / 2 ; if ( N1 > 0 ) return N1 ; return N2 ; } public static void main ( String [ ] args ) { int M = 45 ; System . out . println ( number_of_teams ( M ) ) ; } }
class GFG { static int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; c = a + b ; a = b ; b = c ; } return sum ; } public static void main ( String [ ] args ) { int N = 20 ; System . out . println ( LucasSum ( N ) ) ; } }
class GFG { static int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; } public static void main ( String [ ] args ) { int l = 1000 , r = 6000 ; System . out . println ( countNumbers ( l , r ) ) ; } }
class GfG { static int findMinSum ( int arr [ ] , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * ( int ) Math . pow ( 2 , occ ) ; occ -- ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int n = arr . length ; System . out . println ( findMinSum ( arr , n ) ) ; } }
class GFG { static int countNumbers ( int X , int Y , int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ( i % X == 0 ) && ( i % Y != 0 ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int X = 2 , Y = 3 , N = 10 ; System . out . println ( countNumbers ( X , Y , N ) ) ; } }
class Sol { static int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; } public static void main ( String args [ ] ) { int n = 8 , m = 5 ; System . out . println ( getPosition ( n , m ) ) ; } }
class GFG { static int parity ( int a ) { return a % 3 ; } static int solve ( int [ ] array , int size ) { int operations = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) { int pari1 = parity ( array [ i ] ) ; int pari2 = parity ( array [ i + 2 ] ) ; if ( pari1 == pari2 ) { if ( pari1 == 0 ) array [ i + 1 ] = 1 ; else if ( pari1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( pari1 == 0 && pari2 == 1 ) || ( pari1 == 1 && pari2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( pari1 == 1 && pari2 == 2 ) || ( pari1 == 2 && pari2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( pari1 == 2 && pari2 == 0 ) || ( pari1 == 0 && pari2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; } public static void main ( String arg [ ] ) { int [ ] array = { 2 , 1 , 3 , 0 } ; int size = array . length ; System . out . println ( solve ( array , size ) ) ; } }
class GFG { static int submatrixXor ( int [ ] [ ] arr ) { int n = 3 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] [ ] arr = { { 6 , 7 , 13 } , { 8 , 3 , 4 } , { 9 , 7 , 6 } } ; System . out . println ( submatrixXor ( arr ) ) ; } }
class GFG { static int findDigitalRoot ( int num ) { int sum = Integer . MAX_VALUE , tempNum = num ; while ( sum >= 10 ) { sum = 0 ; while ( tempNum > 0 ) { sum += tempNum % 10 ; tempNum /= 10 ; } tempNum = sum ; } return sum ; } static void findAnswer ( int X , int N ) { int counter = 0 ; for ( int i = 1 ; counter < N ; ++ i ) { int digitalRoot = findDigitalRoot ( i ) ; if ( digitalRoot == X ) { ++ counter ; } if ( counter == N ) { System . out . print ( i ) ; break ; } } } public static void main ( String args [ ] ) { int X = 1 , N = 3 ; findAnswer ( X , N ) ; } }
class GfG { static int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; } public static void main ( String [ ] args ) { int X = 7 , N = 43 ; System . out . println ( findAnswer ( X , N ) ) ; } }
class GfG { static long count ( int N , int K , int R ) { long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; } public static void main ( String [ ] args ) { int N = 20 , K = 4 , R = 3 ; System . out . println ( count ( N , K , R ) ) ; } }
class GfG { static int getCount ( int a , int b , int c ) { int count = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) { int cr = b * ( int ) Math . pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp /= 10 ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int a = 3 , b = 2 , c = 8 ; System . out . println ( getCount ( a , b , c ) ) ; } }
class GFG { static boolean isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 3 ; int a [ ] = { 1 , 1 , 2 } ; if ( isSpiltPossible ( n , a ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static final int n = 3 ; static int matrixSum ( int arr [ ] [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; System . out . println ( matrixSum ( arr ) ) ; } }
class GFG { static int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; } public static void main ( String [ ] args ) { int L = 1 , R = 632 ; System . out . println ( maxAND ( L , R ) ) ; } }
class GFG { static int checkArray ( int [ ] arr , int n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( checkArray ( arr , n ) ) ; } }
class GfG { static int findCount ( int arr [ ] , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 5 , 1 } ; int n = arr . length ; System . out . println ( findCount ( arr , n ) ) ; } }
class GFG { static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static boolean isSunnyNum ( int n ) { if ( isPerfectSquare ( n + 1 ) ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 3 ; if ( isSunnyNum ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GfG { static int N = 100005 ; static boolean isprime [ ] = new boolean [ N ] ; static boolean can [ ] = new boolean [ N ] ; static ArrayList < Integer > SieveOfEratosthenes ( ) { for ( int a = 0 ; a < isprime . length ; a ++ ) { isprime [ a ] = true ; } for ( int p = 2 ; p * p < N ; p ++ ) { if ( isprime [ p ] == true ) { for ( int i = p * p ; i < N ; i += p ) isprime [ i ] = false ; } } ArrayList < Integer > primes = new ArrayList < Integer > ( ) ; for ( int i = 2 ; i < N ; i ++ ) if ( isprime [ i ] ) primes . add ( i ) ; return primes ; } static int Prime_Numbers ( int n ) { ArrayList < Integer > primes = SieveOfEratosthenes ( ) ; for ( int i = 0 ; i < ( int ) ( primes . size ( ) ) - 1 ; i ++ ) if ( primes . get ( i ) + primes . get ( i + 1 ) + 1 < N ) can [ primes . get ( i ) + primes . get ( i + 1 ) + 1 ] = true ; int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( can [ i ] && isprime [ i ] == true ) { ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int n = 50 ; System . out . println ( Prime_Numbers ( n ) ) ; } }
class GFG { static int findAndSum ( int [ ] arr , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { boolean count_on = false ; int l = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) if ( count_on ) l ++ ; else { count_on = true ; l ++ ; } else if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } } if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } mul *= 2 ; } return sum ; } public static void main ( String [ ] args ) { int [ ] arr = { 7 , 1 , 1 , 5 } ; int n = arr . length ; System . out . println ( findAndSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static boolean isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( Math . abs ( Sx - Dx ) % x == 0 && Math . abs ( Sy - Dy ) % y == 0 && ( Math . abs ( Sx - Dx ) / x ) % 2 == ( Math . abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; } public static void main ( String [ ] args ) { int Sx = 0 , Sy = 0 , Dx = 0 , Dy = 0 ; int x = 3 , y = 4 ; if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int getPairs ( int a [ ] ) { int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < a . length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 4 , 3 , 1 } ; System . out . println ( getPairs ( a ) ) ; } }
public class GFG { static boolean isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } static boolean isDigitSumOne ( int nm ) { while ( nm > 9 ) { int sum_digit = 0 ; while ( nm > 0 ) { int digit = nm % 10 ; sum_digit = sum_digit + digit ; nm = nm / 10 ; } nm = sum_digit ; } if ( nm == 1 ) return true ; else return false ; } static void printValidNums ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( isComposite ( i ) && isDigitSumOne ( i ) ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String arg [ ] ) { int l = 10 , r = 100 ; printValidNums ( l , r ) ; } }
class GfG { static int calcNodes ( int N , int I ) { int result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; } public static void main ( String [ ] args ) { int N = 5 , I = 2 ; System . out . println ( " Leaf ▁ nodes ▁ = ▁ " + calcNodes ( N , I ) ) ; } }
class GFG { static long mod = 1000000007 ; static long [ ] arr = new long [ 1000001 ] ; static void cal_factorial ( ) { arr [ 0 ] = 1 ; for ( int i = 1 ; i <= 1000000 ; i ++ ) { arr [ i ] = ( ( arr [ i - 1 ] * i ) % mod ) ; } } static long mod_exponent ( long num , long p ) { if ( p == 0 ) return 1 ; if ( ( p & 1 ) != 0 ) { return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ) % mod ; } else return ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ; } static long getCount ( long x , long y ) { long ans = arr [ ( int ) x + ( int ) y - 1 ] ; ans *= mod_exponent ( arr [ ( int ) x ] , mod - 2 ) ; ans %= mod ; ans *= mod_exponent ( arr [ ( int ) y ] , mod - 2 ) ; ans %= mod ; ans *= ( x - y ) ; ans %= mod ; return ans ; } public static void main ( String [ ] args ) { cal_factorial ( ) ; long x = 3 , y = 1 ; System . out . println ( getCount ( x , y ) ) ; } }
import java . io . * ; class GFG { static void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { System . out . println ( " - 1" ) ; return ; } System . out . println ( ( ( a - b ) / 2 ) + " ▁ " + ( ( a + b ) / 2 ) ) ; } public static void main ( String [ ] args ) { int a = 12 , b = 8 ; findValues ( a , b ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int countTriplets ( int n , Vector < pair > points ) { Set < pair > pts = new HashSet < pair > ( ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) pts . add ( points . get ( i ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int x = points . get ( i ) . first + points . get ( j ) . first ; int y = points . get ( i ) . second + points . get ( j ) . second ; if ( x % 2 == 0 && y % 2 == 0 ) if ( ! pts . contains ( new pair ( x / 2 , y / 2 ) ) ) ct ++ ; } return ct ; } public static void main ( String args [ ] ) { Vector < pair > points = new Vector < > ( ) ; points . add ( new pair ( 1 , 1 ) ) ; points . add ( new pair ( 2 , 2 ) ) ; points . add ( new pair ( 3 , 3 ) ) ; int n = points . size ( ) ; System . out . println ( countTriplets ( n , points ) ) ; } }
class GFG { static double mixtureConcentration ( int n , int [ ] p ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 20 , 20 } ; int n = arr . length ; System . out . println ( String . format ( " % .4f " , mixtureConcentration ( n , arr ) ) ) ; } }
import java . io . * ; class GFG { static int countOddSquares ( int n , int m ) { return ( int ) Math . pow ( m , 0.5 ) - ( int ) Math . pow ( n - 1 , 0.5 ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 100 ; System . out . println ( " Count ▁ is ▁ " + ( ( m - n + 1 ) - countOddSquares ( n , m ) ) ) ; } }
class GFG { static int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; } public static void main ( String [ ] args ) { int R = 4 , C = 5 , M = 2 ; System . out . println ( Square ( R , C , M ) ) ; } }
class GFG { static int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; } public static void main ( String args [ ] ) { int n = 2 , m = 5 ; System . out . print ( findNumber ( n , m ) ) ; } }
import java . util . * ; class GFG { static boolean checkTriangularSumRepresentation ( int n ) { HashSet < Integer > tri = new HashSet < > ( ) ; int i = 1 ; while ( true ) { int x = i * ( i + 1 ) / 2 ; if ( x >= n ) { break ; } tri . add ( x ) ; i ++ ; } for ( Integer tm : tri ) { if ( tri . contains ( n - tm ) && ( n - tm ) != ( int ) tri . toArray ( ) [ tri . size ( ) - 1 ] ) { return true ; } } return false ; } public static void main ( String [ ] args ) { int n = 24 ; if ( checkTriangularSumRepresentation ( n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; class GFG { static int digitsCount ( int n ) { int len = 0 ; while ( n > 0 ) { len ++ ; n /= 10 ; } return len ; } static int absoluteFirstLast ( int n , int x ) { int i = 0 , mod = 1 ; while ( i < x ) { mod *= 10 ; i ++ ; } int last = n % mod ; int len = digitsCount ( n ) ; while ( len != x ) { n /= 10 ; len -- ; } int first = n ; return Math . abs ( first - last ) ; } public static void main ( String args [ ] ) { int n = 21546 , x = 2 ; System . out . println ( absoluteFirstLast ( n , x ) ) ; } }
class GFG { static void make_sequence ( int N ) { int [ ] arr = new int [ N + 1 ] ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int N = 9 ; make_sequence ( N ) ; } }
class GFG { static int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) N ++ ; return N ; } public static void main ( String [ ] args ) { int L = 3 , R = 7 ; int odds = countOdd ( L , R ) ; int evens = ( R - L + 1 ) - odds ; System . out . println ( " Count ▁ of ▁ odd ▁ numbers ▁ is ▁ " + odds ) ; System . out . println ( " Count ▁ of ▁ even ▁ numbers ▁ is ▁ " + evens ) ; } }
class gfg { static int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; } public static void main ( String [ ] args ) { int n = 4 , m = 5 ; System . out . println ( getMinCost ( n , m ) ) ; } }
import java . io . * ; class GFG { static void minOperation ( int n , int k , int a [ ] ) { for ( int i = k ; i < n ; i ++ ) { if ( a [ i ] != a [ k - 1 ] ) System . out . println ( - 1 ) ; } for ( int i = k - 2 ; i > - 1 ; i -- ) { if ( a [ i ] != a [ k - 1 ] ) System . out . println ( i + 1 ) ; } } public static void main ( String [ ] args ) { int n = 5 ; int k = 3 ; int a [ ] = { 2 , 1 , 1 , 1 , 1 } ; minOperation ( n , k , a ) ; } }
class GFG { static int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static void main ( String [ ] args ) { int N = 5 , M = 1 ; int P = ( N * ( N - 1 ) ) / 2 ; System . out . println ( binomialCoeff ( P , M ) ) ; } }
class GFG { static void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( i * g + " ▁ " ) ; ; } public static void main ( String [ ] args ) { int n = 6 , g = 5 ; generateSequence ( n , g ) ; } }
import java . util . * ; class GFG { static int MAX = 1000 ; static int [ ] f = new int [ MAX ] ; static int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] != 0 ) return f [ n ] ; int k = 0 ; if ( ( n & 1 ) != 0 ) k = ( n + 1 ) / 2 ; else k = n / 2 ; if ( ( n & 1 ) != 0 ) f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; else f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; } static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findLCMFibonacci ( int a , int b ) { return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) ; } public static void main ( String args [ ] ) { int a = 3 , b = 12 ; System . out . println ( findLCMFibonacci ( a , b ) ) ; } }
class GFG { static String isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; } public static void main ( String [ ] args ) { int L = 5 , R = 15 ; System . out . println ( isEvenOrOdd ( L , R ) ) ; } }
class GFG { static int trailing_zeros ( int N ) { int count_of_two = 0 , count_of_five = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int val = i ; while ( val % 2 == 0 && val > 0 ) { val /= 2 ; count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val /= 5 ; count_of_five += i ; } } int ans = Math . min ( count_of_two , count_of_five ) ; return ans ; } public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( trailing_zeros ( N ) ) ; } }
import java . util . * ; import java . text . DecimalFormat ; class GFG { static void midptellipse ( float rx , float ry , float xc , float yc ) { float dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ; d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25f * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ; DecimalFormat df = new DecimalFormat ( " # , # # # , # #0.00000" ) ; while ( dx < dy ) { System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } } d2 = ( ( ry * ry ) * ( ( x + 0.5f ) * ( x + 0.5f ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ; while ( y >= 0 ) { System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } } public static void main ( String args [ ] ) { midptellipse ( 10 , 15 , 50 , 50 ) ; } }
class GFG { static String isDivisible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int k = ( int ) n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return " YES " ; return " NO " ; } public static void main ( String [ ] args ) { long n = 123 ; System . out . println ( isDivisible ( n ) ) ; } }
import java . io . * ; class GFG { static void alter ( long x , long y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } System . out . println ( " X ▁ = ▁ " + x + " , ▁ " + " Y ▁ = ▁ " + y ) ; } public static void main ( String [ ] args ) { long x = 12 , y = 5 ; alter ( x , y ) ; } }
import java . io . * ; class GFG { static int digitProduct ( int n ) { int prod = 1 ; while ( n > 0 ) { prod = prod * ( n % 10 ) ; n = n / 10 ; } return prod ; } static void printMultiplicativePrimes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] && prime [ digitProduct ( i ) ] ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 10 ; printMultiplicativePrimes ( n ) ; } }
import java . util . * ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static boolean coPrime ( int n1 , int n2 ) { if ( gcd ( n1 , n2 ) == 1 ) return true ; else return false ; } static int largestCoprime ( int N ) { int half = ( int ) ( N / 2 ) ; while ( coPrime ( N , half ) == false ) half -- ; return half ; } public static void main ( String args [ ] ) { int n = 50 ; System . out . println ( largestCoprime ( n ) ) ; } }
class GfG { static int largestCoprime ( int N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int n = 50 ; System . out . println ( largestCoprime ( n ) ) ; } }
class GFG { static void printSafePrimes ( int n ) { int prime [ ] = new int [ n + 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = 0 ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] != 0 ) { int temp = ( 2 * i ) + 1 ; if ( temp <= n && prime [ temp ] != 0 ) prime [ temp ] = 2 ; } } for ( int i = 5 ; i <= n ; i ++ ) if ( prime [ i ] == 2 ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 20 ; printSafePrimes ( n ) ; } }
import java . util . Vector ; class GFG { static Vector < Integer > Divisors ( int x ) { int c = 0 ; Vector < Integer > v = new Vector < Integer > ( ) ; while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . add ( c ) ; c = 0 ; while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . add ( c ) ; c = 0 ; while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . add ( c ) ; v . add ( x ) ; return v ; } static int MinOperations ( int a , int b ) { Vector < Integer > va = Divisors ( a ) ; Vector < Integer > vb = Divisors ( b ) ; if ( va . get ( 3 ) != vb . get ( 3 ) ) { return - 1 ; } int minOperations = Math . abs ( va . get ( 0 ) - vb . get ( 0 ) ) + Math . abs ( va . get ( 1 ) - vb . get ( 1 ) ) + Math . abs ( va . get ( 2 ) - vb . get ( 2 ) ) ; return minOperations ; } public static void main ( String [ ] args ) { int a = 14 , b = 28 ; System . out . println ( MinOperations ( a , b ) ) ; } }
class GFG { static int largestOddDigit ( int n ) { int maxOdd = - 1 ; while ( n > 0 ) { int digit = n % 10 ; if ( digit % 2 == 1 && digit > maxOdd ) maxOdd = digit ; n = n / 10 ; } return maxOdd ; } static int getProduct ( int n ) { int maxOdd = largestOddDigit ( n ) ; if ( maxOdd == - 1 ) return - 1 ; return ( n * maxOdd ) ; } public static void main ( String [ ] args ) { int n = 12345 ; System . out . println ( getProduct ( n ) ) ; } }
class GFG { static int n = 1000002 ; static int [ ] phi = new int [ n + 2 ] ; static int [ ] ans = new int [ n + 2 ] ; static void ETF ( ) { for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] = i ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( phi [ i ] == i ) { phi [ i ] = i - 1 ; for ( int j = 2 * i ; j <= n ; j += i ) { phi [ j ] = ( phi [ j ] * ( i - 1 ) ) / i ; } } } } static int LcmSum ( int m ) { ETF ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j += i ) { ans [ j ] += ( i * phi [ i ] ) ; } } int answer = ans [ m ] ; answer = ( answer + 1 ) * m ; answer = answer / 2 ; return answer ; } public static void main ( String [ ] args ) { int m = 5 ; System . out . println ( LcmSum ( m ) ) ; } }
class GFG { static int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } static int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } static int countWays ( String str ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { freq [ i ] = 0 ; } int nvowels = 0 , nconsonants = 0 ; int vplaces , cways , vways ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ freq [ str . charAt ( i ) - ' a ' ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) nvowels += freq [ i ] ; else nconsonants += freq [ i ] ; } vplaces = nconsonants + 1 ; cways = factorial ( nconsonants ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { cways = cways / factorial ( freq [ i ] ) ; } } vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { vways = vways / factorial ( freq [ i ] ) ; } } return cways * vways ; } public static void main ( String [ ] args ) { String str = " permutation " ; System . out . println ( countWays ( str ) ) ; } }
import java . io . * ; class GFG { static int setBits ( int n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; } static int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int setbits_x = setBits ( a [ i ] ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int setbits_y = setBits ( a [ j ] ) ; int setbits_xor_xy = setBits ( a [ i ] ^ a [ j ] ) ; if ( setbits_x + setbits_y == setbits_xor_xy ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int [ ] a = { 2 , 3 , 4 , 5 , 6 } ; int n = a . length ; System . out . println ( countPairs ( a , n ) ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findPossibleDerivables ( int arr [ ] , int n , int D , int A , int B ) { int gcdAB = gcd ( A , B ) ; int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( Math . abs ( arr [ i ] - D ) % gcdAB ) == 0 ) { counter ++ ; } } return counter ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 7 , 13 } ; int n = arr . length ; int D = 5 , A = 4 , B = 2 ; System . out . println ( findPossibleDerivables ( arr , n , D , A , B ) ) ; int a [ ] = { 1 , 2 , 3 } ; n = a . length ; D = 6 ; A = 3 ; B = 2 ; System . out . println ( findPossibleDerivables ( a , n , D , A , B ) ) ; } }
class GFG { static int calSum ( int n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . println ( calSum ( n ) ) ; } }
import java . io . * ; class GFG { static void getElements ( int a , int arr [ ] , int n ) { int elements [ ] = new int [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) System . out . print ( elements [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 13 , 2 , 6 , 1 } ; int n = arr . length ; int a = 5 ; getElements ( a , arr , n ) ; } }
public class HelloWorld { static int distinctDigitSum ( int n ) { boolean used [ ] = new boolean [ 10 ] ; int sum = 0 ; while ( n > 0 ) { int digit = n % 10 ; if ( ! used [ digit ] ) { used [ digit ] = true ; sum += digit ; } n = n / 10 ; } return sum ; } static String checkSum ( int m , int n ) { int sumM = distinctDigitSum ( m ) ; int sumN = distinctDigitSum ( n ) ; if ( sumM == sumN ) return " YES " ; return " NO " ; } public static void main ( String [ ] args ) { int m = 2452 , n = 9222 ; System . out . println ( checkSum ( m , n ) ) ; } }
import java . util . * ; class GFG { static int doubleFactorial ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { fact = fact * i ; } return fact ; } static int hermiteNumber ( int n ) { if ( n % 2 == 1 ) return 0 ; else { int number = ( int ) ( Math . pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ; if ( ( n / 2 ) % 2 == 1 ) number = number * - 1 ; return number ; } } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( hermiteNumber ( n ) ) ; } }
import java . util . * ; class solution { static long getSum ( int n , int d ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 10 == d ) sum += i ; } return sum ; } public static void main ( String args [ ] ) { int n = 30 , d = 3 ; System . out . println ( getSum ( n , d ) ) ; } }
import java . util . * ; class solution { static void printThreeParts ( int N ) { if ( N % 3 == 0 ) System . out . println ( " x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " + ( N - 2 ) ) ; else System . out . println ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " + ( N - 3 ) ) ; } public static void main ( String args [ ] ) { int N = 10 ; printThreeParts ( N ) ; } }
class GFG { static boolean isPrime ( int N ) { for ( int i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; } static int getDifference ( int N ) { if ( N == 0 ) return 2 ; else if ( N == 1 ) return 1 ; else if ( isPrime ( N ) ) return 0 ; int aboveN = - 1 , belowN = - 1 ; int n1 ; n1 = N + 1 ; while ( true ) { if ( isPrime ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPrime ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } int diff1 = aboveN - N ; int diff2 = N - belowN ; return Math . min ( diff1 , diff2 ) ; } public static void main ( String args [ ] ) { int N = 25 ; System . out . println ( getDifference ( N ) ) ; } }
public class GFG { static boolean check ( int arr [ ] , int x , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double y = Math . sqrt ( arr [ i ] ) ; if ( Math . floor ( y ) == Math . ceil ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 9 , 10 } ; int n = arr . length ; int x = 13 ; if ( check ( arr , x , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . io . * ; class GFG { static void MinimumMaximumPairs ( int n , int m ) { int max_pairs = ( ( n - m + 1 ) * ( n - m ) ) / 2 ; int min_pairs = m * ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 + ( int ) Math . ceil ( ( double ) ( ( n - m ) / ( double ) ( m ) ) ) * ( ( n - m ) % m ) ; System . out . println ( " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " + min_pairs ) ; System . out . println ( " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " + max_pairs ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 2 ; MinimumMaximumPairs ( n , m ) ; } }
public class GFG { static void findGreater ( int a , int b ) { double x = ( double ) a * ( double ) ( Math . log ( ( double ) ( b ) ) ) ; double y = ( double ) b * ( double ) ( Math . log ( ( double ) ( a ) ) ) ; if ( y > x ) { System . out . println ( " a ^ b ▁ is ▁ greater " ) ; } else if ( y < x ) { System . out . println ( " b ^ a ▁ is ▁ greater " ) ; } else { System . out . println ( " Both ▁ are ▁ equal " ) ; } } public static void main ( String [ ] args ) { int a = 3 , b = 5 , c = 2 , d = 4 ; findGreater ( a , b ) ; findGreater ( c , d ) ; } }
import java . io . * ; class GFG { static long m = 1000000007 ; static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long modexp ( long x , long n ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 ) % m ) ; } } static long getFractionModulo ( long a , long b ) { long c = gcd ( a , b ) ; a = a / c ; b = b / c ; long d = modexp ( b , m - 2 ) ; long ans = ( ( a % m ) * ( d % m ) ) % m ; return ans ; } public static void main ( String [ ] args ) { long a = 2 , b = 6 ; System . out . println ( getFractionModulo ( a , b ) ) ; } }
import java . io . * ; class GFG { static int maxPrimeFactors ( int n ) { int num = n ; int maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n /= 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) { maxPrime = n ; } int sum = maxPrime + num ; return sum ; } public static void main ( String [ ] args ) { int n = 19 ; System . out . println ( maxPrimeFactors ( n ) ) ; } }
import java . io . * ; class GFG { static int sumOfDigits ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; } static int findNumber ( int n ) { int i = n - 1 ; while ( i > 0 ) { if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) return i ; i -- ; } return - 1 ; } public static void main ( String [ ] args ) { int n = 824 ; System . out . println ( findNumber ( n ) ) ; } }
import java . io . * ; class GFG { static int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . print ( findNth ( N ) ) ; } }
public class GFG { final static int N = 4 ; static void predictMatrix ( int arr [ ] [ ] , int range1a , int range1b , int range0a , int range0b , int K , int b [ ] [ ] ) { int c = 0 ; while ( K != 0 ) { K -- ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { c = 0 ; if ( i > 0 && arr [ i - 1 ] [ j ] == 1 ) c ++ ; if ( j > 0 && arr [ i ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j > 0 && arr [ i - 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i < N - 1 && arr [ i + 1 ] [ j ] == 1 ) c ++ ; if ( j < N - 1 && arr [ i ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j < N - 1 && arr [ i + 1 ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j > 0 && arr [ i + 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j < N - 1 && arr [ i - 1 ] [ j + 1 ] == 1 ) c ++ ; if ( arr [ i ] [ j ] == 1 ) { if ( c >= range1a && c <= range1b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } if ( arr [ i ] [ j ] == 0 ) { if ( c >= range0a && c <= range0b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } } } for ( int k = 0 ; k < N ; k ++ ) for ( int m = 0 ; m < N ; m ++ ) arr [ k ] [ m ] = b [ k ] [ m ] ; } } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 0 , 0 , 0 , 0 } , { 0 , 1 , 1 , 0 } , { 0 , 0 , 1 , 0 } , { 0 , 1 , 0 , 1 } } ; int range1a = 2 , range1b = 2 ; int range0a = 2 , range0b = 3 ; int K = 3 ; int b [ ] [ ] = new int [ N ] [ N ] ; predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) ; for ( int i = 0 ; i < N ; i ++ ) { System . out . println ( ) ; for ( int j = 0 ; j < N ; j ++ ) System . out . print ( b [ i ] [ j ] + " ▁ " ) ; } } }
import java . io . * ; class GFG { static int countMoves ( int n ) { int ct = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countMoves ( n ) ) ; } }
import java . lang . * ; import java . util . * ; class GFG { static double countNumbers ( int N ) { return ( Math . pow ( 10 , N ) - 1 ) - ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; } static public void main ( String args [ ] ) { int n = 2 ; System . out . println ( countNumbers ( n ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static int N = 3 ; static double calcDeterminant ( int arr [ ] ) { double determinant = 0 ; for ( int i = 0 ; i < N ; i ++ ) { determinant += Math . pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; } static public void main ( String args [ ] ) { int [ ] arr = { 4 , 5 , 3 } ; System . out . println ( calcDeterminant ( arr ) ) ; } }
import java . io . * ; class GFG { static int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; } public static void main ( String [ ] args ) { int k = 3 , l = 10 , r = 10 ; System . out . print ( minimumMoves ( k , l , r ) ) ; } }
import java . io . * ; class GFG { static int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) ; return sum ; } static int sumEven ( int l , int r ) { return sumNatural ( r / 2 ) - sumNatural ( ( l - 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int l = 2 , r = 5 ; System . out . println ( " Sum ▁ of ▁ Natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " + sumEven ( l , r ) ) ; } }
import java . util . * ; class solution { static boolean isDivisibleRec ( int x , int a , int b , int n ) { if ( x > n ) return false ; if ( n % x == 0 ) return true ; return ( isDivisibleRec ( x * 10 + a , a , b , n ) || isDivisibleRec ( x * 10 + b , a , b , n ) ) ; } static boolean isDivisible ( int a , int b , int n ) { return isDivisibleRec ( a , a , b , n ) || isDivisibleRec ( b , a , b , n ) ; } public static void main ( String args [ ] ) { int a = 3 , b = 5 , n = 53 ; if ( isDivisible ( a , b , n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . io . * ; class GFG { static void MinSteps ( int SourceX , int SourceY , int DestX , int DestY ) { System . out . println ( Math . max ( Math . abs ( SourceX - DestX ) , Math . abs ( SourceY - DestY ) ) ) ; while ( ( SourceX != DestX ) || ( SourceY != DestY ) ) { if ( SourceX < DestX ) { System . out . print ( ' U ' ) ; SourceX ++ ; } if ( SourceX > DestX ) { System . out . println ( ' D ' ) ; SourceX -- ; } if ( SourceY > DestY ) { System . out . print ( ' L ' ) ; SourceY -- ; } if ( SourceY < DestY ) { System . out . print ( ' R ' ) ; SourceY ++ ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int sourceX = 4 , sourceY = 4 ; int destinationX = 7 , destinationY = 0 ; MinSteps ( sourceX , sourceY , destinationX , destinationY ) ; } }
import java . util . * ; public class GFG { public static ArrayList < Integer > getPerfectSquares ( int n ) { ArrayList < Integer > perfectSquares = new ArrayList < > ( ) ; int current = 1 , i = 1 ; while ( current <= n ) { perfectSquares . add ( current ) ; current = ( int ) Math . pow ( ++ i , 2 ) ; } return perfectSquares ; } public static int maxPairSum ( int arr [ ] ) { int n = arr . length ; int max , secondMax ; if ( arr [ 0 ] > arr [ 1 ] ) { max = arr [ 0 ] ; secondMax = arr [ 1 ] ; } else { max = arr [ 1 ] ; secondMax = arr [ 0 ] ; } for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return ( max + secondMax ) ; } public static int countPairsWith ( int n , ArrayList < Integer > perfectSquares , HashSet < Integer > nums ) { int count = 0 ; for ( int i = 0 ; i < perfectSquares . size ( ) ; i ++ ) { int temp = perfectSquares . get ( i ) - n ; if ( temp > n && nums . contains ( temp ) ) count ++ ; } return count ; } public static int countPairs ( int arr [ ] ) { int i , n = arr . length ; int max = maxPairSum ( arr ) ; ArrayList < Integer > perfectSquares = getPerfectSquares ( max ) ; HashSet < Integer > nums = new HashSet < > ( ) ; for ( i = 0 ; i < n ; i ++ ) nums . add ( arr [ i ] ) ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) { count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 6 , 9 , 10 , 20 } ; System . out . println ( countPairs ( arr ) ) ; } }
import java . io . * ; class GFG { static int findEle ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 6 } ; int n = arr . length ; System . out . print ( findEle ( arr , n ) ) ; } }
class GFG { static int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; } static int suminRange ( int l , int r ) { return sumNatural ( r ) - sumNatural ( l - 1 ) ; } public static void main ( String [ ] args ) { int l = 2 , r = 5 ; System . out . println ( " Sum ▁ of ▁ Natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " + suminRange ( l , r ) ) ; } }
import java . io . * ; class GFG { static boolean divisibleBy3 ( String number ) { int sumOfDigit = 0 ; for ( int i = 0 ; i < number . length ( ) ; i ++ ) sumOfDigit += number . charAt ( i ) - '0' ; if ( sumOfDigit % 3 == 0 ) return true ; return false ; } static boolean divisibleBy25 ( String number ) { if ( number . length ( ) < 2 ) return false ; int length = number . length ( ) ; int lastTwo = ( number . charAt ( length - 2 ) - '0' ) * 10 + ( number . charAt ( length - 1 ) - '0' ) ; if ( lastTwo % 25 == 0 ) return true ; return false ; } static boolean divisibleBy75 ( String number ) { if ( divisibleBy3 ( number ) && divisibleBy25 ( number ) ) return true ; return false ; } public static void main ( String [ ] args ) { String number = "754586672150" ; boolean divisible = divisibleBy75 ( number ) ; if ( divisible ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; } public static void main ( String args [ ] ) { int A = 8 , Lcm = 8 , Hcf = 1 ; int result = otherNumber ( A , Lcm , Hcf ) ; System . out . println ( " B ▁ = ▁ " + result ) ; } }
import java . io . * ; class GFG { static float successiveChange ( int arr [ ] , int N ) { float var1 , var2 , result = 0 ; var1 = arr [ 0 ] ; var2 = arr [ 1 ] ; result = var1 + var2 + ( ( var1 * var2 ) / 100 ) ; for ( int i = 2 ; i < N ; i ++ ) result = result + arr [ i ] + ( ( result * arr [ i ] ) / 100 ) ; return result ; } public static void main ( String [ ] args ) { int [ ] arr = { 10 , 20 , 30 , 10 } ; int N = arr . length ; float result = successiveChange ( arr , N ) ; System . out . println ( " Percentage ▁ change ▁ is ▁ = ▁ " + result + " ▁ % " ) ; } }
import java . io . * ; class GFG { static int minimumNumbers ( int n , int s ) { if ( ( s % n ) > 0 ) return s / n + 1 ; else return s / n ; } public static void main ( String [ ] args ) { int n = 5 ; int s = 11 ; System . out . println ( minimumNumbers ( n , s ) ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int sumAP ( int n , int d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; } static int sumMultiples ( int A , int B , int n ) { n -- ; int common = ( A * B ) / __gcd ( A , B ) ; return sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ; } public static void main ( String [ ] args ) { int n = 100 , A = 5 , B = 10 ; System . out . println ( " Sum ▁ = ▁ " + sumMultiples ( A , B , n ) ) ; } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static boolean isPossible ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 13 ; if ( isPossible ( n ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int contiguousPerfectSquare ( int [ ] arr , int n ) { int a ; float b ; int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b = ( float ) Math . sqrt ( arr [ i ] ) ; a = ( int ) b ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 75 , 4 , 64 , 121 , 25 } ; int n = arr . length ; System . out . print ( contiguousPerfectSquare ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( countPairs ( n ) ) ; } }
import java . io . * ; class GFG { static int getIndex ( int a [ ] , int n ) { if ( n == 1 ) return 0 ; int ptrL = 0 , ptrR = n - 1 , sumL = a [ 0 ] , sumR = a [ n - 1 ] ; while ( ptrR - ptrL > 1 ) { if ( sumL < sumR ) { ptrL ++ ; sumL += a [ ptrL ] ; } else if ( sumL > sumR ) { ptrR -- ; sumR += a [ ptrR ] ; } else { break ; } } return ptrL ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 7 , 9 , 8 , 7 } ; int n = a . length ; System . out . println ( getIndex ( a , n ) ) ; } }
import java . util . * ; class solution { static int getPosition ( int a [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m ) ) ; } int ans = - 1 , max = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } } return ans + 1 ; } public static void main ( String args [ ] ) { int a [ ] = { 2 , 5 , 4 } ; int n = a . length ; int m = 2 ; System . out . println ( getPosition ( a , n , m ) ) ; } }
class GFG { static int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) Math . pow ( i , i ) ; int numerator = ( int ) Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; } public static void main ( String [ ] args ) { int n = 6 , r = 2 ; System . out . println ( "1 / " + calcFunction ( n , r ) ) ; } }
public class GFG { static int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; } public static void main ( String [ ] args ) { int div [ ] = { 8 , 3 } ; int rem [ ] = { 2 , 2 } ; int N = div . length ; System . out . println ( findNum ( div , rem , N ) ) ; } }
public class GFG { static void profitLoss ( int N , int M ) { if ( N == M ) System . out . print ( " No ▁ Profit ▁ nor ▁ Loss " ) ; else { float result = 0 ; result = ( float ) ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) System . out . print ( " Loss ▁ = ▁ - " + result * 100 + " % " ) ; else System . out . print ( " Profit ▁ = ▁ " + result * 100 + " % " ) ; } } public static void main ( String [ ] args ) { int N = 8 , M = 9 ; profitLoss ( N , M ) ; } }
import java . util . * ; class solution { static int countPieces ( int N ) { return 2 * N ; } public static void main ( String args [ ] ) { int N = 100 ; System . out . println ( countPieces ( N ) ) ; } }
import java . util . * ; class solution { static long sumAP ( long n , long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; } static long sumMultiples ( long n ) { n -- ; return sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ; } public static void main ( String args [ ] ) { long n = 24 ; System . out . println ( sumMultiples ( n ) ) ; } }
class GFG { static boolean productSumDivisible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int n = 1234 ; int len = 4 ; if ( productSumDivisible ( n , len ) ) { System . out . println ( " TRUE " ) ; } else { System . out . println ( " FALSE " ) ; } } }
import java . io . * ; class GFG { static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long powGCD ( long a , long n , long b ) { for ( int i = 0 ; i < n ; i ++ ) a = a * a ; return gcd ( a , b ) ; } public static void main ( String [ ] args ) { long a = 10 , b = 5 , n = 2 ; System . out . println ( powGCD ( a , n , b ) ) ; } }
import java . util . * ; class solution { static int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; } public static void main ( String args [ ] ) { int n = 3 , a = 5 , b = 2 ; System . out . println ( lastCoordinate ( n , a , b ) ) ; } }
public class GFG { static int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; } public static void main ( String [ ] args ) { int N = 45 , K = 6 ; System . out . println ( " Smallest ▁ number ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ " + N + " that is divisible by " ▁ + ▁ K ▁ + ▁ " is " + findNum(N, K)); } }
import java . lang . * ; import java . util . * ; class GFG { static void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } System . out . print ( " Sum ▁ = ▁ " + sum ) ; System . out . print ( " Product = " + product); } public static void main ( String args [ ] ) { int n = 1012 ; countDigit ( n ) ; } }
import java . lang . * ; import java . util . * ; class GFG { static int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; } public static void main ( String args [ ] ) { int N = 45 , K = 6 ; System . out . print ( " Largest ▁ number ▁ smaller ▁ " + " than ▁ or ▁ equal ▁ to ▁ " + N + " that is divisible by " + K + " ▁ is ▁ " + findNum ( N , K ) ) ; } }
public class GFG { static boolean isDivisiblePalindrome ( int n ) { int hash [ ] = new int [ 10 ] ; int digitSum = 0 ; while ( n != 0 ) { digitSum += n % 10 ; hash [ n % 10 ] ++ ; n /= 10 ; } if ( digitSum % 3 != 0 ) return false ; int oddCount = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( hash [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount > 1 ) return false ; else return true ; } public static void main ( String [ ] args ) { int n = 34734 ; System . out . print ( isDivisiblePalindrome ( n ) ) ; } }
class GFG { static boolean productDivisible ( int n , int k ) { int product = 1 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 0 ) { product *= n % 10 ; } n = n / 10 ; position ++ ; } if ( product % k == 0 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int n = 321922 ; int k = 3 ; if ( productDivisible ( n , k ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
class GFG { static int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } static int npr ( int n , int r ) { int pnr = factorial ( n ) / factorial ( n - r ) ; return pnr ; } static int countPermutations ( int n , int r , int k ) { return factorial ( k ) * ( r - k + 1 ) * npr ( n - k , r - k ) ; } public static void main ( String [ ] args ) { int n = 8 ; int r = 5 ; int k = 2 ; System . out . println ( countPermutations ( n , r , k ) ) ; } }
class GFG { static int GIF ( double n ) { return ( int ) Math . floor ( n ) ; } public static void main ( String [ ] args ) { double n = 2.3 ; System . out . println ( GIF ( n ) ) ; } }
import java . io . * ; class GFG { static int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } static int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } public static void main ( String [ ] args ) { int m = 3 , n = 4 , k = 5 ; int totalTriangles = ncr ( m + n + k , 3 ) - ncr ( m , 3 ) - ncr ( n , 3 ) - ncr ( k , 3 ) ; System . out . println ( totalTriangles ) ; } }
import java . util . * ; class solution { static boolean SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; } public static void main ( String arr [ ] ) { int n = 592452 ; int k = 3 ; if ( SumDivisible ( n , k ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static String isTriangleExists ( int a , int b , int c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " YES " ; else return " NO " ; else return " NO " ; } public static void main ( String [ ] args ) { int a = 50 , b = 60 , c = 70 ; System . out . println ( isTriangleExists ( a , b , c ) ) ; } }
import java . util . * ; public class GfG { private static int findX ( int n , int k ) { int r = n , v , u ; int m = ( int ) Math . sqrt ( k ) + 1 ; for ( int i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) { i = k ; } for ( u = v = 0 ; k % i == 0 ; v ++ ) { k /= i ; } if ( v > 0 ) { int t = n ; while ( t > 0 ) { t /= i ; u += t ; } r = Math . min ( r , u / v ) ; } } return r ; } public static void main ( String args [ ] ) { int n = 5 ; int k = 2 ; System . out . println ( findX ( n , k ) ) ; } }
import java . io . * ; class GFG { static int fact ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact *= i ; return fact ; } static int ncr ( int n , int r ) { int ncr = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; return ncr ; } static int ways ( int m , int w , int n , int k ) { int ans = 0 ; while ( m >= k ) { ans += ncr ( m , k ) * ncr ( w , n - k ) ; k += 1 ; } return ans ; } public static void main ( String [ ] args ) { int m , w , n , k ; m = 7 ; w = 6 ; n = 5 ; k = 3 ; System . out . println ( ways ( m , w , n , k ) ) ; } }
class gfg { static int square ( int n ) { return n * n ; } static int sum ( int n ) { if ( n == 0 ) return 0 ; if ( n % 2 == 1 ) { return square ( ( n + 1 ) / 2 ) + sum ( n / 2 ) ; } else { return square ( n / 2 ) + sum ( n / 2 ) ; } } static int oddDivSum ( int a , int b ) { return sum ( b ) - sum ( a - 1 ) ; } public static void main ( String [ ] args ) { int a = 3 , b = 9 ; System . out . println ( oddDivSum ( a , b ) ) ; } }
import java . io . * ; class GFG { static int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; } public static void main ( String [ ] args ) { int n = 32 ; System . out . println ( " Minimum ▁ value ▁ of ▁ K ▁ is ▁ = ▁ " + countBits ( n ) ) ; } }
class GFG { static boolean isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } static boolean isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = Math . log ( a ) / Math . log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; } static boolean isAchillesNumber ( int n ) { if ( isPowerful ( n ) && ! isPower ( n ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 72 ; if ( isAchillesNumber ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; n = 36 ; if ( isAchillesNumber ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; class GFG { static int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; ++ j ) { if ( i % j == 0 ) { ++ divCount ; } } if ( ( divCount % 2 ) != 0 ) { ++ res ; } } return res ; } public static void main ( String [ ] args ) { int a = 1 , b = 10 ; System . out . println ( OddDivCount ( a , b ) ) ; } }
class GFG { static int largestSquareFactor ( int num ) { int answer = 1 ; for ( int i = 2 ; i < Math . sqrt ( num ) ; ++ i ) { int cnt = 0 ; int j = i ; while ( num % j == 0 ) { cnt ++ ; j *= i ; } if ( ( cnt & 1 ) != 0 ) { cnt -- ; answer *= Math . pow ( i , cnt ) ; } else { answer *= Math . pow ( i , cnt ) ; } } return answer ; } public static void main ( String args [ ] ) { int N = 420 ; System . out . println ( largestSquareFactor ( N ) ) ; } }
import java . io . * ; class GFG { static int Nth_Term ( int n ) { return ( int ) ( 3 * Math . pow ( n , 2 ) - n + 2 ) / ( 2 ) ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( Nth_Term ( N ) ) ; } }
class GFG { static void countPermutations ( int N , int B ) { int x = ( int ) Math . pow ( B , N ) ; int y = ( int ) Math . pow ( B , N - 1 ) ; System . out . println ( x - y ) ; } public static void main ( String [ ] args ) { int N = 6 ; int B = 4 ; countPermutations ( N , B ) ; } }
import java . util . * ; import java . util . Arrays ; import java . util . Collections ; class GFG { public static int calculateDifference ( int [ ] arr , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; boolean [ ] prime = new boolean [ max_val + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int P1 = 1 , P2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { P1 *= arr [ i ] ; } else if ( arr [ i ] != 1 ) { P2 *= arr [ i ] ; } } return Math . abs ( P2 - P1 ) ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 3 , 5 , 10 , 15 , 7 } ; int n = arr . length ; System . out . println ( calculateDifference ( arr , n ) ) ; System . exit ( 0 ) ; } }
public class GFG { static int EqualNumbers ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n != 0 ) return n - 1 ; return n ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 4 , 1 } ; int n = a . length ; System . out . println ( EqualNumbers ( a , n ) ) ; } }
class GFG { static int count_odd_pair ( int n , int a [ ] ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } int ans = odd * even * 2 ; return ans ; } static int count_even_pair ( int odd_sum_pairs , int n ) { int total_pairs = ( n * ( n - 1 ) ) ; int ans = total_pairs - odd_sum_pairs ; return ans ; } public static void main ( String [ ] args ) { int n = 6 ; int [ ] a = { 2 , 4 , 5 , 9 , 1 , 8 } ; int odd_sum_pairs = count_odd_pair ( n , a ) ; int even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) ; System . out . println ( " Even ▁ Sum ▁ Pairs ▁ = ▁ " + even_sum_pairs ) ; System . out . println ( " Odd ▁ Sum ▁ Pairs = ▁ " + odd_sum_pairs ) ; } }
class GFG { static int findSteps ( int n , int m , int a [ ] ) { int cur = 1 ; int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; } public static void main ( String [ ] args ) { int n = 3 , m = 3 ; int a [ ] = { 2 , 1 , 2 } ; System . out . println ( findSteps ( n , m , a ) ) ; } }
public class Improve { static void HexToBin ( char hexdec [ ] ) { int i = 0 ; while ( hexdec [ i ] != ' \u0000' ) { switch ( hexdec [ i ] ) { case '0' : System . out . print ( "0000" ) ; break ; case '1' : System . out . print ( "0001" ) ; break ; case '2' : System . out . print ( "0010" ) ; break ; case '3' : System . out . print ( "0011" ) ; break ; case '4' : System . out . print ( "0100" ) ; break ; case '5' : System . out . print ( "0101" ) ; break ; case '6' : System . out . print ( "0110" ) ; break ; case '7' : System . out . print ( "0111" ) ; break ; case '8' : System . out . print ( "1000" ) ; break ; case '9' : System . out . print ( "1001" ) ; break ; case ' A ' : case ' a ' : System . out . print ( "1010" ) ; break ; case ' B ' : case ' b ' : System . out . print ( "1011" ) ; break ; case ' C ' : case ' c ' : System . out . print ( "1100" ) ; break ; case ' D ' : case ' d ' : System . out . print ( "1101" ) ; break ; case ' E ' : case ' e ' : System . out . print ( "1110" ) ; break ; case ' F ' : case ' f ' : System . out . print ( "1111" ) ; break ; default : System . out . print ( " Invalid hexadecimal digit " + hexdec[i]); } i ++ ; } } public static void main ( String args [ ] ) { String s = "1AC5" ; char hexdec [ ] = new char [ 100 ] ; hexdec = s . toCharArray ( ) ; System . out . print ( " Equivalent Binary value is : "); try { HexToBin ( hexdec ) ; } catch ( ArrayIndexOutOfBoundsException e ) { System . out . print ( " " ) ; } } }
import java . io . * ; class GFG { static boolean isPowerOfTwo ( int x ) { return ( x > 0 && ( ! ( ( x & ( x - 1 ) ) > 0 ) ) ) ; } static void Count_pairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) ) count ++ ; } int ans = ( count * ( count - 1 ) ) / 2 ; System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 5 , 8 , 16 , 128 } ; int n = a . length ; Count_pairs ( a , n ) ; } }
import java . io . * ; class GFG { static int factorial ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = result * i ; return result ; } static int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } static int calculate_result ( int n ) { int result = 2 * nCr ( ( n - 2 ) , ( n / 2 - 1 ) ) ; return result ; } public static void main ( String [ ] args ) { int a = 2 , b = 4 ; System . out . println ( calculate_result ( 2 * a ) ) ; System . out . print ( calculate_result ( 2 * b ) ) ; } }
import java . io . * ; class GFG { static void PossibleValues ( int b , int x , int n ) { int leastdivisible = ( b / x + 1 ) * x ; int flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { System . out . print ( leastdivisible - b + " ▁ " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) System . out . println ( - 1 ) ; } public static void main ( String [ ] args ) { int b = 10 , x = 6 , n = 40 ; PossibleValues ( b , x , n ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int digitProduct ( int [ ] digits , int start , int end ) { int pro = 1 ; for ( int i = start ; i <= end ; i ++ ) { pro *= digits [ i ] ; } return pro ; } static boolean isDistinct ( int N ) { String s = " " + N ; int len = s . length ( ) ; int [ ] digits = new int [ len ] ; ArrayList < Integer > products = new ArrayList < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { digits [ i ] = Integer . parseInt ( " " + s . charAt ( i ) ) ; } for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i ; j < len ; j ++ ) { int val = digitProduct ( digits , i , j ) ; if ( products . contains ( val ) ) return false ; else products . add ( val ) ; } } return true ; } public static void main ( String args [ ] ) { int N = 324 ; if ( isDistinct ( N ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static long nthKyneaNumber ( int n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( nthKyneaNumber ( n ) ) ; } }
class GFG { static long nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( nthKyneaNumber ( n ) ) ; } }
class GFG { static boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static boolean isProthNumber ( int n ) { int k = 1 ; while ( k < ( n / k ) ) { if ( n % k == 0 ) { if ( isPowerOfTwo ( n / k ) ) return true ; } k = k + 2 ; } return false ; } public static void main ( String [ ] args ) { int n = 25 ; if ( isProthNumber ( n - 1 ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public class AAA { static int get_last_two_digit ( long N ) { if ( N <= 10 ) { long ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ( int ) ans % 100 ; } return 13 ; } public static void main ( String [ ] args ) { long N = 1 ; for ( N = 1 ; N <= 10 ; N ++ ) System . out . println ( " For ▁ N ▁ = ▁ " + N + " ▁ : ▁ " + get_last_two_digit ( N ) ) ; } }
public class GFG { static boolean isProductEven ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 4 , 3 , 5 } ; int n = arr . length ; if ( isProductEven ( arr , n ) ) System . out . println ( " Even " ) ; else System . out . println ( " Odd " ) ; } }
public class Improve { static int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; } public static void main ( String args [ ] ) { int n = 6 ; System . out . println ( " Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " + calculateSquareSum ( n ) ) ; } }
import java . io . * ; class GFG { static int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . print ( fnMod ( n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int MinimumMoves ( int a [ ] , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 3 , 2 } ; int x = 2 ; int n = arr . length ; System . out . println ( MinimumMoves ( arr , n , x ) ) ; } }
class GFG { static int SumOfDigits ( String str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( str . charAt ( i ) - '0' ) ; return sum ; } static boolean Divisible ( String str , int n ) { if ( SumOfDigits ( str , n ) % 3 == 0 && str . charAt ( n - 1 ) == '0' ) return true ; return false ; } public static void main ( String [ ] args ) { String str = "263730746028908374890" ; int n = str . length ( ) ; if ( Divisible ( str , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public class GFG { static boolean isPrime ( int k ) { if ( k <= 1 ) return false ; for ( int i = 2 ; i < k ; i ++ ) if ( k % i == 0 ) return false ; return true ; } static int check ( int num , int k ) { int flag = 1 ; for ( int i = 2 ; i < k ; i ++ ) { if ( num % i == 0 ) flag = 0 ; } if ( flag == 1 ) { if ( num % k == 0 ) return 1 ; else return 0 ; } else return 0 ; } static int findCount ( int a , int b , int k ) { int count = 0 ; if ( ! isPrime ( k ) ) return 0 ; else { int ans ; for ( int i = a ; i <= b ; i ++ ) { ans = check ( i , k ) ; if ( ans == 1 ) count ++ ; else continue ; } } return count ; } public static void main ( String args [ ] ) { int a = 2020 , b = 6300 , k = 29 ; System . out . println ( findCount ( a , b , k ) ) ; } }
import java . io . * ; class GFG { static int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , c = 3 , d = 4 ; System . out . println ( NumberOfSolutions ( a , b , c , d ) ) ; } }
import java . io . * ; class GFG { static long findF_N ( long n ) { long ans = 0 ; for ( long i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; } public static void main ( String [ ] args ) { long n = 3 ; System . out . println ( findF_N ( n ) ) ; } }
import java . io . * ; class GFG { static String findNumber ( int n , int d ) { String ans = " " ; if ( d != 10 ) { ans += Integer . toString ( d ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += " Impossible " ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; } public static void main ( String [ ] args ) { int n = 12 , d = 3 ; System . out . println ( findNumber ( n , d ) ) ; } }
import java . io . * ; class GFG { static int MAX = 1000000 ; static int sieve_Prime [ ] = new int [ MAX + 4 ] ; static int sieve_count [ ] = new int [ MAX + 4 ] ; static void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } } public static void main ( String [ ] args ) { form_sieve ( ) ; int n = 2 ; System . out . println ( " Count ▁ = ▁ " + ( sieve_count [ n ] + 1 ) ) ; n = 3 ; System . out . println ( " Count ▁ = ▁ " + ( sieve_count [ n ] + 1 ) ) ; } }
import java . util . * ; class GFG { static Vector < Integer > PrimeFactors ( int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; int x = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( x % i == 0 ) { v . add ( i ) ; while ( x % i == 0 ) x /= i ; } } if ( x > 1 ) v . add ( x ) ; return v ; } static int GoodNumber ( int n ) { Vector < Integer > v = new Vector < Integer > ( PrimeFactors ( n ) ) ; int ans = 1 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) ans *= v . get ( i ) ; return ans ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( GoodNumber ( n ) ) ; } }
class GFG { static boolean checkSpecialPrime ( boolean [ ] sieve , int num ) { while ( num != 0 ) { if ( ! sieve [ num ] ) { return false ; } num /= 10 ; } return true ; } static void findSpecialPrime ( int N ) { boolean [ ] sieve = new boolean [ N + 10 ] ; sieve [ 0 ] = sieve [ 1 ] = false ; for ( int i = 0 ; i < N + 10 ; i ++ ) sieve [ i ] = true ; for ( int i = 2 ; i <= N ; i ++ ) { if ( sieve [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { sieve [ j ] = false ; } } } while ( true ) { if ( checkSpecialPrime ( sieve , N ) ) { System . out . println ( N ) ; break ; } else N -- ; } } public static void main ( String [ ] args ) { findSpecialPrime ( 379 ) ; findSpecialPrime ( 100 ) ; } }
class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 13 ; if ( isPrime ( n ) && ( n % 4 == 1 ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; class GFG { static float heightCalculate ( int H , int n , int m ) { float N = ( float ) ( n * 1.0 ) ; float M = ( float ) ( m * 1.0 ) ; float h = H * ( float ) Math . sqrt ( N / ( N + M ) ) ; return h ; } public static void main ( String [ ] args ) { int H = 10 , n = 3 , m = 4 ; System . out . print ( heightCalculate ( H , n , m ) ) ; } }
class GFG { static boolean isprime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; } static boolean isNSqMinusnMSqPrime ( int m , int n ) { if ( n - m == 1 && isprime ( m + n ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int m = 13 , n = 16 ; if ( isNSqMinusnMSqPrime ( m , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; class GFG { static void findsolution ( long n , long x , long y ) { if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x y < n ) { System . out . println ( " No ▁ solution " ) ; return ; } System . out . println ( y - n + 1 ) ; while ( n -- > 1 ) System . out . println ( "1" ) ; } public static void main ( String [ ] args ) { long n , x , y ; n = 5 ; x = 15 ; y = 15 ; findsolution ( n , x , y ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int findPosition ( int n , int f , int b ) { return n - Math . max ( f + 1 , n - b ) + 1 ; } public static void main ( String args [ ] ) { int n = 5 , f = 2 , b = 3 ; System . out . print ( findPosition ( n , f , b ) ) ; } }
class GFG { static int nthOdd ( int n ) { return ( 2 * n - 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( nthOdd ( n ) ) ; } }
class GFG { static int nthEven ( int n ) { return ( 2 * n ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( nthEven ( n ) ) ; } }
import java . io . * ; class GFG { static double nthHarmonic ( int N ) { float harmonic = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; } public static void main ( String [ ] args ) { int N = 8 ; System . out . print ( nthHarmonic ( N ) ) ; } }
import java . io . * ; class GFG { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + n - 3 ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 5 * ( int ) Math . pow ( n , 2 ) - 5 * n ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + n - 2 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 4 * n - 2 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . io . * ; class GFG { static int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + 2 * n - 5 ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
public class GFG { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 3 * n - 5 ; } public static void main ( String args [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
public class GFG { static int nthTerm ( int n ) { return 4 * ( int ) Math . pow ( n , 2 ) - 3 * n + 2 ; } public static void main ( String args [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . io . * ; class GFG { static double PI = 3.1415926535 ; static double findAnglesA ( double a , double b , double c ) { double A = Math . acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) ; return A * 180 / PI ; } static double findAnglesB ( double a , double b , double c ) { double B = Math . acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) ; return B * 180 / PI ; } static void printAngles ( int a , int b , int c ) { double x = ( double ) a ; double y = ( double ) b ; double z = ( double ) c ; double A = findAnglesA ( x , y , z ) ; double B = findAnglesB ( x , y , z ) ; System . out . println ( " Angles ▁ are ▁ A ▁ = ▁ " + A + " , ▁ B ▁ = ▁ " + B + " , ▁ C ▁ = ▁ " + 90 ) ; } static void printOtherSides ( int n ) { int b = 0 , c = 0 ; if ( ( n & 1 ) > 0 ) { if ( n == 1 ) System . out . println ( - 1 ) ; else { b = ( n * n - 1 ) / 2 ; c = ( n * n + 1 ) / 2 ; System . out . println ( " Side ▁ b ▁ = ▁ " + b + " , ▁ Side ▁ c ▁ = ▁ " + c ) ; } } else { if ( n == 2 ) System . out . println ( - 1 ) ; else { b = n * n / 4 - 1 ; c = n * n / 4 + 1 ; System . out . println ( " Side ▁ b ▁ = ▁ " + b + " , ▁ Side ▁ c ▁ = ▁ " + c ) ; } } printAngles ( n , b , c ) ; } public static void main ( String [ ] args ) { int a = 12 ; printOtherSides ( a ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . print ( " Sum ▁ = ▁ " + calculateSum ( n ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) - n - 1 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int nthTerm ( int n ) { return 4 * ( int ) Math . pow ( n , 2 ) - 7 * n + 3 ; } public static void main ( String args [ ] ) { int N = 4 ; System . out . print ( nthTerm ( N ) ) ; } }
class GFG { static void checkIfPowerIsolated ( int num ) { int input = num ; int count = 0 ; int [ ] factor = new int [ num + 1 ] ; if ( num % 2 == 0 ) { while ( num % 2 == 0 ) { ++ count ; num /= 2 ; } factor [ 2 ] = count ; } for ( int i = 3 ; i * i <= num ; i += 2 ) { count = 0 ; while ( num % i == 0 ) { ++ count ; num /= i ; } if ( count > 0 ) factor [ i ] = count ; } if ( num > 1 ) factor [ num ] = 1 ; int product = 1 ; for ( int i = 0 ; i < num + 1 ; i ++ ) { if ( factor [ i ] > 0 ) product = product * factor [ i ] * i ; } if ( product == input ) System . out . print ( "Power-isolated IntegerNEW_LINE"); else System . out . print ( "Not a Power-isolated IntegerNEW_LINE"); } public static void main ( String [ ] args ) { checkIfPowerIsolated ( 12 ) ; checkIfPowerIsolated ( 18 ) ; checkIfPowerIsolated ( 35 ) ; } }
import java . util . * ; class solution { static long getNthTerm ( long N ) { return ( ( int ) Math . pow ( N , 2 ) + N + 1 ) ; } public static void main ( String arr [ ] ) { long N = 11 ; System . out . println ( getNthTerm ( N ) ) ; } }
import java . lang . * ; import java . util . * ; class GFG { static long findSum ( int n ) { long sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; class Nth { static float CalculateRatio ( float m , float n ) { return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; } } class GFG { public static void main ( String [ ] args ) { float m = 6 , n = 2 ; Nth a = new Nth ( ) ; System . out . println ( a . CalculateRatio ( m , n ) ) ; } }
import java . io . * ; class GFG { static int calculateSum ( int n ) { return ( int ) Math . pow ( n * ( n + 1 ) / 2 , 2 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( calculateSum ( n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } static int powerDigitSum ( int a , int n ) { int res = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { res = res * digSum ( a ) ; res = digSum ( res ) ; } a = digSum ( digSum ( a ) * digSum ( a ) ) ; n /= 2 ; } return res ; } public static void main ( String args [ ] ) { int a = 9 , n = 4 ; System . out . print ( powerDigitSum ( a , n ) ) ; } }
class GFG { static int totEdge ( int n ) { int result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( totEdge ( n ) ) ; } }
import java . io . * ; class GFG { static int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2 ) ; twentyfive = ( ( Z * 1 ) / 4 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return ( int ) result ; } public static void main ( String [ ] args ) { int totalRupees = 1800 ; int X = 1 , Y = 2 , Z = 4 ; int Rupees = coin ( totalRupees , X , Y , Z ) ; System . out . println ( "1 ▁ rupess ▁ coins ▁ = ▁ " + Rupees * 1 ) ; System . out . println ( "50 ▁ paisa ▁ coins ▁ = ▁ " + Rupees * 2 ) ; System . out . println ( "25 ▁ paisa ▁ coins ▁ = ▁ " + Rupees * 4 ) ; } }
public class GFG { static float sumOfSeries ( int x , int k ) { float y = ( float ) ( ( ( float ) ( x ) / 81 ) * ( 9 * k - 1 + Math . pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; } public static void main ( String args [ ] ) { int x = 9 ; int k = 20 ; System . out . println ( sumOfSeries ( x , k ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static int modExp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b == 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; } static int check ( int num ) { if ( num == 1 num < 3 ) return - 1 ; else if ( num % 4 == 0 ) return modExp ( num / 4 , 4 ) ; else if ( num % 6 == 0 ) return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) ; else if ( num % 10 == 0 ) return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ; else return - 1 ; } public static void main ( String [ ] args ) { int num = 10 ; System . out . print ( check ( num ) ) ; } }
import java . io . * ; class GFG { static boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; } public static void main ( String [ ] args ) { long n = 19877658 ; if ( isDivisible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n != 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } static int removeElement ( int n ) { if ( n == 1 n == 2 ) return 0 ; int a = nextPowerOf2 ( n ) ; if ( n == a n == a - 1 ) return 1 ; else if ( n == a - 2 ) return 0 ; else if ( n % 2 == 0 ) return 1 ; else return 2 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( removeElement ( n ) ) ; } }
public class GFG { static int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; } public static void main ( String [ ] args ) { int trainLength = 120 ; int Speed = 30 ; int Time = 18 ; System . out . print ( " Length ▁ of ▁ bridge ▁ = ▁ " + bridge_length ( trainLength , Speed , Time ) + " ▁ meters " ) ; } }
class GFG { static long MOD = 1000000007 ; static long modInv ( long x ) { long n = MOD - 2 ; long result = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) { result = result * x % MOD ; } x = x * x % MOD ; n = n / 2 ; } return result ; } static long getSum ( long n , long k ) { long ans = 1 ; for ( long i = n + 1 ; i > n - k ; i -- ) { ans = ans * i % MOD ; } ans = ans * modInv ( k + 1 ) % MOD ; return ans ; } public static void main ( String [ ] args ) { long n = 3 , k = 2 ; System . out . println ( getSum ( n , k ) ) ; } }
class GFG { static void printCombination ( int n ) { System . out . print ( 1 + " ▁ " ) ; if ( ( n - 2 ) % 3 == 0 ) System . out . print ( 2 + " ▁ " + ( n - 3 ) ) ; else System . out . print ( 1 + " ▁ " + ( n - 2 ) ) ; } public static void main ( String [ ] args ) { int n = 233 ; printCombination ( n ) ; } }
class GFG { static boolean checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; } public static void main ( String [ ] args ) { int l = 1 , r = 8 ; if ( checkPairs ( l , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static boolean isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; } public static void main ( String [ ] args ) { System . out . println ( isPalindrome ( 123321 ) ? " Palindrome " : " Not ▁ Palindrome " ) ; } }
class GFG { public static void main ( String [ ] args ) { int target = 93 ; int [ ] arr = { 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 } ; int length = arr . length ; int totalCount = 0 ; for ( int i = 0 ; i < length - 2 ; i ++ ) { if ( target % arr [ i ] == 0 ) { for ( int j = i + 1 ; j < length - 1 ; j ++ ) { if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) { int toFind = target / ( arr [ i ] * arr [ j ] ) ; for ( int k = j + 1 ; k < length ; k ++ ) { if ( arr [ k ] == toFind ) { totalCount ++ ; } } } } } } System . out . println ( " Total ▁ number ▁ of ▁ triplets ▁ found ▁ : ▁ " + totalCount ) ; } }
import java . io . * ; class GFG { static long binomialCoeff ( long n , long k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( long n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( catalan ( n ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { public static boolean isFascinating ( int num ) { int [ ] freq = new int [ 10 ] ; String val = " " + num + num * 2 + num * 3 ; for ( int i = 0 ; i < val . length ( ) ; i ++ ) { int digit = val . charAt ( i ) - '0' ; if ( freq [ digit ] > 0 && digit != 0 ) return false ; else freq [ digit ] ++ ; } for ( int i = 1 ; i < freq . length ; i ++ ) { if ( freq [ i ] == 0 ) return false ; } return true ; } public static void main ( String args [ ] ) { int num = 192 ; if ( num < 100 ) System . out . println ( " No " ) ; else { boolean ans = isFascinating ( num ) ; if ( ans ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } } }
import java . util . * ; class GFG { public static int binomial_coefficient ( int n , int m ) { int res = 1 ; if ( m > n - m ) m = n - m ; for ( int i = 0 ; i < m ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static int calculate_ways ( int m , int n ) { if ( m < n ) { return 0 ; } int ways = binomial_coefficient ( n + m - 1 , n - 1 ) ; return ways ; } public static void main ( String [ ] args ) { int m = 7 , n = 5 ; int result = calculate_ways ( m , n ) ; System . out . println ( Integer . toString ( result ) ) ; System . exit ( 0 ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static final int N = 100005 ; static int [ ] phi ; static int [ ] S ; static void computeTotient ( ) { for ( int i = 1 ; i < N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } } static void CoPrimes ( ) { computeTotient ( ) ; for ( int i = 1 ; i < N ; i ++ ) S [ i ] = S [ i - 1 ] + phi [ i ] ; } public static void main ( String args [ ] ) { phi = new int [ N ] ; S = new int [ N ] ; CoPrimes ( ) ; int q [ ] = { 3 , 4 } ; int n = q . length ; for ( int i = 0 ; i < n ; i ++ ) System . out . println ( "Number of unordered coprime " ▁ + ▁ " pairs of integers from 1 to " ▁ + ▁ q [ i ] ▁ + ▁ " are " + S[q[i]] ); } }
import java . util . * ; class GFG { static int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; } static int numberSequence ( int n ) { if ( n == 1 ) return 1 ; String s = " " ; for ( int i = 1 ; i < n ; i ++ ) s += '1' ; s += '0' ; for ( int i = 1 ; i <= n ; i ++ ) s += '1' ; int num = binaryToDecimal ( s ) ; return num ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( numberSequence ( n ) ) ; } }
class GFG { static int numberSequence ( int n ) { int num = ( int ) ( Math . pow ( 4 , n ) - Math . pow ( 2 , n ) ) - 1 ; return num ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( numberSequence ( n ) ) ; } }
class GFG { static int prime ( int num ) { int i , flag = 0 ; for ( i = 2 ; i <= num / 2 ; i ++ ) { if ( num % i == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) return 1 ; else return 0 ; } static void print_alternate_prime ( int n ) { int counter = 0 ; for ( int num = 2 ; num < n ; num ++ ) { if ( prime ( num ) == 1 ) { if ( counter % 2 == 0 ) System . out . print ( num + " ▁ " ) ; counter ++ ; } } } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( " Following ▁ are ▁ the ▁ alternate ▁ " + " prime ▁ number ▁ smaller ▁ than ▁ " + " or ▁ equal ▁ to ▁ " + n ) ; print_alternate_prime ( n ) ; } }
class GFG { static void SieveOfEratosthenes ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } boolean flag = true ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { if ( flag ) { System . out . print ( p + " ▁ " ) ; flag = false ; } else { flag = true ; } } } } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( " Following ▁ are ▁ the ▁ alternate " + " ▁ prime ▁ numbers ▁ smaller ▁ " + " than ▁ or ▁ equal ▁ to ▁ " + n ) ; SieveOfEratosthenes ( n ) ; } }
import java . io . * ; class GFG { static boolean findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } } public static void main ( String [ ] args ) { int x = 4 ; int y = 9 ; if ( findGreater ( x , y ) ) System . out . println ( "1" ) ; else System . out . println ( "2" ) ; } }
import java . util . * ; class solution { static int max_profit ( int a [ ] , int b [ ] , int n , int fee ) { int i , j , profit ; int l , r , diff_day = 1 , sum = 0 ; b [ 0 ] = 0 ; b [ 1 ] = diff_day ; for ( i = 1 ; i < n ; i ++ ) { l = 0 ; r = diff_day ; sum = 0 ; for ( j = n - 1 ; j >= i ; j -- ) { profit = ( a [ r ] - a [ l ] ) - fee ; if ( profit > 0 ) { sum = sum + profit ; } l ++ ; r ++ ; } if ( b [ 0 ] < sum ) { b [ 0 ] = sum ; b [ 1 ] = diff_day ; } diff_day ++ ; } return 0 ; } public static void main ( String args [ ] ) { int arr [ ] = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = arr . length ; int [ ] b = new int [ 2 ] ; int tranFee = 2 ; max_profit ( arr , b , n , tranFee ) ; System . out . println ( b [ 0 ] + " , ▁ " + b [ 1 ] ) ; } }
class Geeks { static int binomialCoeff ( int x , int n , int k ) { int sum = 0 , term = 1 ; for ( int i = 1 ; i <= n && sum < k ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; } return sum ; } static int minTrials ( int n , int k ) { int low = 1 , high = k ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( binomialCoeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; } public static void main ( String args [ ] ) { System . out . println ( minTrials ( 2 , 10 ) ) ; } }
import java . lang . * ; class Geeks { static boolean isPrime ( int num ) { if ( num < 2 num % 2 == 0 ) return num == 2 ; for ( int i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; } static int primePalindrome ( int N ) { if ( 8 <= N && N <= 11 ) return 11 ; for ( int x = 1 ; x < 100000 ; ++ x ) { String s = Integer . toString ( x ) ; StringBuffer buffer = new StringBuffer ( s ) ; buffer . reverse ( ) ; int y = Integer . parseInt ( s + buffer . substring ( 1 ) . toString ( ) ) ; if ( y >= N && isPrime ( y ) == true ) return y ; } return - 1 ; } public static void main ( String args [ ] ) { System . out . print ( primePalindrome ( 112 ) ) ; } }
import java . util . Vector ; class GFG { static int getsum ( int a ) { int r = 0 , sum = 0 ; while ( a > 0 ) { r = a % 10 ; sum = sum + r ; a = a / 10 ; } return sum ; } static void value ( int a , int b , int c ) { int co = 0 , p = 0 ; int no , r = 0 , x = 0 , q = 0 , w = 0 ; Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 1 ; i < 82 ; i ++ ) { no = ( int ) Math . pow ( i , a ) ; no = b * no + c ; if ( no > 0 && no < 1000000000 ) { x = getsum ( no ) ; if ( x == i ) { q ++ ; v . add ( no ) ; w ++ ; } } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { System . out . print ( v . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int a = 2 , b = 2 , c = - 1 ; value ( a , b , c ) ; } }
class GFG { static void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( true ) { flag = 1 ; x = ( int ) ( Math . pow ( 2 , i ) ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; System . out . print ( p1 + " ▁ " ) ; i ++ ; } } public static void main ( String [ ] args ) { int p0 = 19 ; print ( p0 ) ; } }
class solution_1 { static int findOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; } public static void main ( String args [ ] ) { int a [ ] = { 5 , 1 , 3 , 2 } ; int n = a . length ; System . out . println ( findOddPair ( a , n ) ) ; } }
class GFG { static boolean isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; } public static void main ( String args [ ] ) { int n = 15 ; if ( isSurd ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class Geeks { static long LastTwoDigit ( long num ) { long one = num % 10 ; num /= 10 ; long tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; } public static void main ( String args [ ] ) { int n = 10 ; long num = 1 ; num = ( long ) Math . pow ( 2 , n ) ; System . out . println ( " Last ▁ 2 ▁ digits ▁ of ▁ 2 ^ 10 ▁ = ▁ " + LastTwoDigit ( num ) ) ; } }
class GFG { static int power ( long x , long y , long p ) { while ( y > 0 ) { long r = y & 1 ; if ( r == 1 ) res = ( res * ( int ) x ) % ( int ) p ; x = ( x * x ) % p ; } return res ; } static int numberOfDigits ( int x ) { int i = 0 ; while ( x != 0 ) { x /= 10 ; i ++ ; } return i ; } static void LastTwoDigit ( int n ) { System . out . print ( " Last ▁ " + 2 + " ▁ digits ▁ of ▁ " + 2 + " ^ " ) ; System . out . print ( n + " ▁ = ▁ " ) ; int temp = 1 ; for ( int i = 1 ; i <= 2 ; i ++ ) temp *= 10 ; temp = power ( 2 , n , temp ) ; for ( int i = 0 ; i < ( 2 - numberOfDigits ( temp ) ) ; i ++ ) System . out . print ( 0 + " ▁ " ) ; if ( temp != 0 ) System . out . println ( temp ) ; } public static void main ( String [ ] args ) { int n = 72 ; LastTwoDigit ( n ) ; } }
class GFG { static long modPower ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static long gcdPow ( long a , long n , long c ) { if ( a % c == 0 ) return c ; long modexpo = modPower ( a , n , c ) ; return gcd ( modexpo , c ) ; } public static void main ( String [ ] args ) { long a = 10248585 , n = 1000000 , c = 12564 ; System . out . println ( gcdPow ( a , n , c ) ) ; } }
import java . io . * ; class GFG { static int countOddSum ( int ar [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; } public static void main ( String [ ] args ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = ar . length ; System . out . print ( " The ▁ Number ▁ of ▁ Subarrays " + " ▁ with ▁ odd ▁ sum ▁ is ▁ " ) ; System . out . println ( countOddSum ( ar , n ) ) ; } }
import java . io . * ; class GFG { static int countOddSum ( int ar [ ] , int n ) { int temp [ ] = { 1 , 0 } ; int result = 0 , val = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ; temp [ val ] ++ ; } result = temp [ 0 ] * temp [ 1 ] ; return ( result ) ; } public static void main ( String [ ] args ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = ar . length ; System . out . println ( " The ▁ Number ▁ of ▁ Subarrays " + " ▁ with ▁ odd ▁ sum ▁ is ▁ " + countOddSum ( ar , n ) ) ; } }
public class GEE { static void printPFsInPairs ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) System . out . println ( i + " * " + n / i ) ; } public static void main ( String [ ] args ) { int n = 24 ; printPFsInPairs ( n ) ; } }
import java . io . * ; public class GFG { static int rangesum ( int n , int l , int r ) { int [ ] arr = new int [ n ] ; int c = 1 , i = 0 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } c = 2 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } int sum = 0 ; for ( i = l - 1 ; i < r ; i ++ ) { sum += arr [ i ] ; } return sum ; } public static void main ( String [ ] args ) { int n = 12 ; int l = 1 , r = 11 ; System . out . println ( rangesum ( n , l , r ) ) ; } }
import java . io . * ; class GFG { static void findAngle ( int n ) { int interiorAngle , exteriorAngle ; interiorAngle = ( n - 2 ) * 180 / n ; exteriorAngle = 360 / n ; System . out . println ( " Interior ▁ angle : ▁ " + interiorAngle ) ; System . out . println ( " Exterior ▁ angle : ▁ " + exteriorAngle ) ; } public static void main ( String [ ] args ) { int n = 10 ; findAngle ( n ) ; } }
import java . io . * ; import java . lang . Math ; class GFG { static void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { double d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; System . out . println ( " Distance ▁ is ▁ " + d ) ; return ; } public static void main ( String [ ] args ) { float x1 = 2 ; float y1 = - 5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ; distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; } }
import java . io . * ; class GFG { static boolean DivisibleBy41 ( int first , int second , int c , int n ) { int digit [ ] = new int [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int first = 1 , second = 2 , c = 1 , n = 3 ; if ( DivisibleBy41 ( first , second , c , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; class GFG { static int findTetrahedralNumber ( int n ) { return ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) ; } static void printSeries ( int n ) { int prev = 0 ; int curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTetrahedralNumber ( i ) ; curr = curr + prev ; System . out . print ( curr + " ▁ " ) ; prev = curr ; } } public static void main ( String [ ] args ) { int n = 10 ; printSeries ( n ) ; } }
import java . io . * ; class GFG { static void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; System . out . print ( num + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 10 ; printSeries ( n ) ; } }
import java . io . * ; class GFG { static int No_Of_Pairs ( int N ) { int i = 1 ; while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) i ++ ; return ( i - 1 ) ; } static void print_pairs ( int pairs ) { int i = 1 , mul ; for ( i = 1 ; i <= pairs ; i ++ ) { mul = i * ( i + 1 ) ; System . out . println ( " Pair ▁ no . ▁ " + i + " ▁ - - > ▁ ( " + ( mul * i ) + " , ▁ " + mul * ( i + 1 ) + " ) " ) ; } } public static void main ( String [ ] args ) { int N = 500 , pairs , mul , i = 1 ; pairs = No_Of_Pairs ( N ) ; System . out . println ( " No . ▁ of ▁ pairs ▁ = ▁ " + pairs ) ; print_pairs ( pairs ) ; } }
import java . io . * ; class GFG { static long findTriangularNumber ( int n ) { return ( n * ( n + 1 ) ) / 2 ; } static void printSeries ( int n ) { long prev = 0 ; long curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTriangularNumber ( i ) ; curr = curr + prev ; System . out . print ( curr + " ▁ " ) ; prev = curr ; } } public static void main ( String [ ] args ) { int n = 10 ; printSeries ( n ) ; } }
import java . io . * ; class GFG { static void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; System . out . print ( num + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 10 ; printSeries ( n ) ; } }
import java . io . * ; class GFG { static void count_even_odd ( int min , int max , int steps [ ] [ ] ) { int a , b , even , odd ; boolean beven = true , aeven = false ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { a = steps [ i ] [ 0 ] ; b = steps [ i ] [ 1 ] ; if ( ! ( aeven || ( a & 1 ) > 0 ) ) aeven = true ; if ( beven ) { if ( ( b & 1 ) > 0 ) beven = false ; } else if ( ! ( ( a & 1 ) > 0 ) ) { if ( ! ( ( b & 1 ) > 0 ) ) beven = true ; } else { if ( ( b & 1 ) > 0 ) beven = true ; } } if ( beven ) { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } else { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } if ( ! ( beven ^ aeven ) ) even += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; else odd += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; System . out . print ( " even ▁ = ▁ " + even + " , ▁ odd ▁ = ▁ " + odd ) ; } public static void main ( String [ ] args ) { int min = 1 , max = 4 ; int steps [ ] [ ] = { { 1 , 2 } , { 3 , 4 } } ; count_even_odd ( min , max , steps ) ; } }
import java . io . * ; class GFG { static int getMaxOnes ( int n , int x ) { int zeroes = ( n / x ) ; zeroes = zeroes * zeroes ; int total = n * n ; int ans = total - zeroes ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; int x = 2 ; System . out . println ( getMaxOnes ( n , x ) ) ; } }
import java . io . * ; class GFG { static void check ( int n , int m ) { if ( n == 2 m == 2 n % m == 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { int m = 3 , n = 9 ; check ( n , m ) ; } }
import java . io . * ; class GFG { static void findSurfaceArea ( float a , float h ) { float Area ; Area = 6 * a * h + 3 * ( float ) ( Math . sqrt ( 3 ) ) * a * a ; System . out . println ( " Surface ▁ Area : ▁ " + Area ) ; } static void findVolume ( float a , float h ) { float Volume ; Volume = 3 * ( float ) ( Math . sqrt ( 3 ) ) * a * a * h / 2 ; System . out . println ( " Volume : ▁ " + Volume ) ; } public static void main ( String [ ] args ) { float a = 5 , h = 10 ; findSurfaceArea ( a , h ) ; findVolume ( a , h ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static double MinimumMail ( int n , int k , int x ) { double m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; } public static void main ( String [ ] args ) { int N = 4 ; int K = 9 ; int X = 2 ; System . out . print ( ( int ) MinimumMail ( N , K , X ) + "NEW_LINE"); } }
class GFG { static void findArea ( float a , float b ) { float Area ; Area = ( float ) 3.142 * a * b ; System . out . println ( " Area : ▁ " + Area ) ; } public static void main ( String [ ] args ) { float a = 5 , b = 4 ; findArea ( a , b ) ; } }
class GFG { static int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- > 0 ) { result = ( int ) Math . pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; } public static void main ( String args [ ] ) { int x = 5 , k = 2 , m = 3 ; System . out . println ( calculate ( x , k , m ) ) ; } }
import java . io . * ; class GFG { static int rev ( int n , int temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; } public static void main ( String [ ] args ) { int n = 121 ; int temp = rev ( n , 0 ) ; if ( temp == n ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; } }
import java . io . * ; class GFG { static void findGreater ( int a , int b , int n ) { if ( ! ( ( n & 1 ) > 0 ) ) { a = Math . abs ( a ) ; b = Math . abs ( b ) ; } if ( a == b ) System . out . println ( " a ^ n ▁ is ▁ " + " equal ▁ to ▁ b ^ n " ) ; else if ( a > b ) System . out . println ( " a ^ n ▁ is ▁ greater ▁ " + " than ▁ b ^ n " ) ; else System . out . println ( " b ^ n ▁ is ▁ greater ▁ " + " than ▁ a ^ n " ) ; } public static void main ( String [ ] args ) { int a = 12 , b = 24 , n = 5 ; findGreater ( a , b , n ) ; } }
class GFG { static void fibonacci ( double n ) { double fib ; for ( double i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; System . out . print ( ( int ) fib + " ▁ " ) ; } } public static void main ( String [ ] args ) { double n = 8 ; fibonacci ( n ) ; } }
import java . io . * ; class GFG { static int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . print ( n + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " ) ; System . out . println ( center_hexadecagonal_num ( n ) ) ; n = 12 ; System . out . print ( n + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " ) ; System . out . println ( center_hexadecagonal_num ( n ) ) ; } }
class GFG { public static int findNature ( int a , int b , int n ) { int [ ] seq = new int [ 100 ] ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; if ( ( seq [ n ] & 1 ) != 0 ) return 1 ; else return 0 ; } public static void main ( String [ ] args ) { int a = 2 , b = 4 ; int n = 3 ; if ( findNature ( a , b , n ) == 1 ) System . out . println ( " Odd ▁ " ) ; else System . out . println ( " Even ▁ " ) ; } }
import java . io . * ; class GFG { static void check ( long m , long n ) { double RHS = m * ( double ) Math . log ( n ) ; double LHS = n * ( double ) Math . log ( m ) ; if ( LHS > RHS ) System . out . print ( " m ^ n ▁ > ▁ n ^ m " ) ; else if ( LHS < RHS ) System . out . print ( " m ^ n ▁ < ▁ n ^ m " ) ; else System . out . print ( " m ^ n ▁ = ▁ n ^ m " ) ; } static public void main ( String [ ] args ) { long m = 987654321 , n = 123456987 ; check ( m , n ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int maxDivisorRange ( int a , int b , int l , int h ) { int g = gcd ( a , b ) ; int res = - 1 ; for ( int i = l ; i * i <= g && i <= h ; i ++ ) if ( g % i == 0 ) res = Math . max ( res , Math . max ( i , g / i ) ) ; return res ; } public static void main ( String [ ] args ) { int a = 3 , b = 27 , l = 1 , h = 5 ; System . out . println ( maxDivisorRange ( a , b , l , h ) ) ; } }
import java . io . * ; class GFG { static void checksum ( int n ) { if ( n == 0 ) { System . out . println ( " - 2 ▁ - 1 ▁ 0 ▁ 1 ▁ 2" ) ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( int i = 0 ; i <= n - 4 ; i += inc ) { if ( i + i + 1 + i + 2 + i + 3 + i + 4 == n ) { System . out . print ( ( i ) + " ▁ " + ( i + 1 ) + " ▁ " + ( i + 2 ) + " ▁ " + ( i + 3 ) + " ▁ " + ( i + 4 ) ) ; return ; } } System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { int n = 15 ; checksum ( n ) ; } }
import java . io . * ; class GFG { static void checksum ( int n ) { if ( n % 5 == 0 ) System . out . println ( ( n / 5 - 2 ) + " ▁ " + ( n / 5 - 1 ) + " ▁ " + ( n / 5 ) + " ▁ " + ( n / 5 + 1 ) + " ▁ " + ( n / 5 + 2 ) ) ; else System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { int n = 15 ; checksum ( n ) ; } }
import java . io . * ; class GFG { static int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( sumOfSeries ( n ) ) ; } }
import java . io . * ; class GFG { static int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( " Number ▁ of ▁ unmarked ▁ " + " elements : ▁ " + countUnmarked ( N ) ) ; } }
import java . io . * ; class GFG { static int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int calculateSeries ( int n ) { return factorial ( n + 1 ) - 1 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( calculateSeries ( n ) ) ; } }
import java . io . * ; class GFG { static int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int calculateSeries ( int n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( calculateSeries ( n ) ) ; } }
import java . io . * ; class GFG { static int minimumLength ( int x , int y , int z ) { return 1 + Math . abs ( x - y ) + Math . abs ( y - z ) ; } public static void main ( String [ ] args ) { int x = 3 , y = 1 , z = 2 ; System . out . println ( minimumLength ( x , y , z ) ) ; } }
import java . io . * ; class GFG { static void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) { System . out . print ( " x2 ▁ = ▁ " + ( 2 * c1 - x1 ) + " ▁ " ) ; System . out . print ( " y2 ▁ = ▁ " + ( 2 * c2 - y1 ) ) ; } public static void main ( String [ ] args ) { int x1 = - 4 , y1 = - 1 ; int c1 = 3 , c2 = 5 ; endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) ; } }
import java . text . * ; import java . math . * ; class GFG { static float proterm ( int i , float value , float x [ ] ) { float pro = 1 ; for ( int j = 0 ; j < i ; j ++ ) { pro = pro * ( value - x [ j ] ) ; } return pro ; } static void dividedDiffTable ( float x [ ] , float y [ ] [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) { y [ j ] [ i ] = ( y [ j ] [ i - 1 ] - y [ j + 1 ] [ i - 1 ] ) / ( x [ j ] - x [ i + j ] ) ; } } } static float applyFormula ( float value , float x [ ] , float y [ ] [ ] , int n ) { float sum = y [ 0 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum = sum + ( proterm ( i , value , x ) * y [ 0 ] [ i ] ) ; } return sum ; } static void printDiffTable ( float y [ ] [ ] , int n ) { DecimalFormat df = new DecimalFormat ( " # . # # # # " ) ; df . setRoundingMode ( RoundingMode . HALF_UP ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) { String str1 = df . format ( y [ i ] [ j ] ) ; System . out . print ( str1 + " TABSYMBOL ▁ " ) ; } System . out . println ( " " ) ; } } public static void main ( String [ ] args ) { int n = 4 ; float value , sum ; float y [ ] [ ] = new float [ 10 ] [ 10 ] ; float x [ ] = { 5 , 6 , 9 , 11 } ; y [ 0 ] [ 0 ] = 12 ; y [ 1 ] [ 0 ] = 13 ; y [ 2 ] [ 0 ] = 14 ; y [ 3 ] [ 0 ] = 16 ; dividedDiffTable ( x , y , n ) ; printDiffTable ( y , n ) ; value = 7 ; DecimalFormat df = new DecimalFormat ( " # . # # " ) ; df . setRoundingMode ( RoundingMode . HALF_UP ) ; System . out . println ( " Value at " + df . format ( value ) + " is " + df . format ( applyFormula ( value , x , y , n ) ) ) ; } }
import java . io . * ; class GFG { static long centered_heptagonal_num ( long n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; } public static void main ( String [ ] args ) { long n = 5 ; System . out . println ( n + " th ▁ Centered ▁ " + " heptagonal ▁ number ▁ : ▁ " + centered_heptagonal_num ( n ) ) ; } }
class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static boolean checkHankelMatrix ( int n , int m [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; } public static void main ( String args [ ] ) { int n = 4 ; int m [ ] [ ] = { { 1 , 2 , 3 , 5 } , { 2 , 3 , 5 , 8 } , { 3 , 5 , 8 , 0 } , { 5 , 8 , 0 , 9 } } ; if ( checkHankelMatrix ( n , m ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static boolean isPower ( int n ) { for ( int x = 2 ; x <= ( int ) Math . sqrt ( n ) ; x ++ ) { float f = ( float ) Math . log ( n ) / ( float ) Math . log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; } public static void main ( String args [ ] ) { for ( int i = 2 ; i < 100 ; i ++ ) if ( isPower ( i ) ) System . out . print ( i + " ▁ " ) ; } }
class GFG { static int N = 1000005 ; static void sumOddDigit ( int digitSum [ ] ) { for ( int i = 1 ; i < N ; i ++ ) { digitSum [ i ] = digitSum [ i / 10 ] + ( i & 1 ) * ( i % 10 ) ; } } static void sumFactor ( int digitSum [ ] , int factorDigitSum [ ] ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j += i ) { factorDigitSum [ j ] += digitSum [ i ] ; } } } static void wrapper ( int q , int n [ ] ) { int digitSum [ ] = new int [ N ] ; int factorDigitSum [ ] = new int [ N ] ; sumOddDigit ( digitSum ) ; sumFactor ( digitSum , factorDigitSum ) ; for ( int i = 0 ; i < q ; i ++ ) System . out . print ( factorDigitSum [ n [ i ] ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int q = 2 ; int n [ ] = new int [ ] { 10 , 36 } ; wrapper ( q , n ) ; } }
import java . io . * ; class GFG { static int number_of_digits ( int n ) { int i ; int res ; int sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; } public static void main ( String [ ] args ) { int n = 21 ; System . out . println ( number_of_digits ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void reverseorder ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = n ; i >= 2 ; i -- ) if ( prime [ i ] == true ) System . out . print ( i + " ▁ " ) ; } public static void main ( String args [ ] ) { int N = 25 ; System . out . println ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) ; if ( N == 1 ) System . out . println ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) ; else } }
class GFG { public static int magicOfSequence ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; } public static void main ( String args [ ] ) { int N = 4 ; System . out . println ( magicOfSequence ( N ) ) ; } }
import java . io . * ; class GFG { static int countOddFactors ( long n ) { int odd_factors = 0 ; for ( int i = 1 ; 1 * i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( 1 * i * i == n ) { if ( ( i & 1 ) == 1 ) odd_factors ++ ; } else { if ( ( i & 1 ) == 1 ) odd_factors ++ ; int factor = ( int ) n / i ; if ( ( factor & 1 ) == 1 ) odd_factors ++ ; } } } return odd_factors - 1 ; } public static void main ( String args [ ] ) { long N = 15 ; System . out . println ( countOddFactors ( N ) ) ; N = 10 ; System . out . println ( countOddFactors ( N ) ) ; } }
import java . io . * ; class GFG { static boolean isPossibleToZero ( int a [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 1 , 0 } ; int n = arr . length ; if ( isPossibleToZero ( arr , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . lang . Math . * ; class GFG { static final double PI = 3.142 ; static double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; } public static void main ( String [ ] args ) { float x = 50 ; int n = 5 ; System . out . println ( ( float ) ( cosXSertiesSum ( x , 5 ) * 1000000 ) / 1000000.00 ) ; } }
class GFG { static int solve ( int n , int base ) { int result = 0 ; while ( n > 0 ) { int remainder = n % base ; result = result + remainder ; n = n / base ; } return result ; } static void printSumsOfDigits ( int n ) { for ( int base = 2 ; base < n ; ++ base ) System . out . print ( solve ( n , base ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 8 ; printSumsOfDigits ( n ) ; } }
class GFG { static boolean check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; } static public void main ( String args [ ] ) { int N = 5 ; int M = 7 ; if ( check ( N , M ) ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; } }
import java . io . * ; import java . lang . * ; public class GFG { static int perfectSquare ( String s ) { int n = s . length ( ) ; int ans = - 1 ; String num = " " ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { String str = " " ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) { str += s . charAt ( j ) ; } } if ( str . charAt ( 0 ) != '0' ) { int temp = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) temp = temp * 10 + ( int ) ( str . charAt ( j ) - '0' ) ; int k = ( int ) Math . sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < ( int ) str . length ( ) ) { ans = ( int ) str . length ( ) ; num = str ; } } } } if ( ans == - 1 ) return ans ; else { System . out . print ( num + " ▁ " ) ; return n - ans ; } } public static void main ( String args [ ] ) { System . out . println ( perfectSquare ( "8314" ) ) ; System . out . println ( perfectSquare ( "753" ) ) ; } }
class GFG { static void printFourSquares ( int a ) { for ( int i = 0 ; i * i <= a ; i ++ ) { for ( int j = i ; j * j <= a ; j ++ ) { for ( int k = j ; k * k <= a ; k ++ ) { for ( int l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { System . out . print ( a + " ▁ = ▁ " + i + " * " + i + " ▁ + ▁ " + j + " * " + j + " ▁ + ▁ " ) ; System . out . println ( k + " * " + k + " ▁ + ▁ " + l + " * " + l ) ; } } } } } } public static void main ( String [ ] args ) { int a = 74 ; printFourSquares ( a ) ; } }
import java . io . * ; class GFG { static int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; } public static void main ( String [ ] args ) { int n = 51242183 ; System . out . println ( " The ▁ number ▁ of ▁ distinct ▁ " + " prime ▁ factors ▁ is / are ▁ " + exactPrimeFactorCount ( n ) ) ; System . out . println ( " The ▁ value ▁ of ▁ log ( log ( n ) ) " + " ▁ is ▁ " + Math . log ( Math . log ( n ) ) ) ; } }
class GFG { static int no_of_digit ( int a , int b ) { return ( ( int ) ( b * Math . log10 ( a ) ) + 1 ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 100 ; System . out . print ( " no . ▁ of ▁ digits ▁ = ▁ " + no_of_digit ( a , b ) ) ; } }
import java . io . * ; class GFG { static boolean checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; } static boolean isEmirpimes ( int n ) { if ( checkSemiprime ( n ) == false ) return false ; int r = 0 ; for ( int t = n ; t != 0 ; t = t / n ) r = r * 10 + t % 10 ; if ( r == n ) return false ; return ( checkSemiprime ( r ) ) ; } public static void main ( String [ ] args ) { int n = 15 ; if ( isEmirpimes ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static long factorial ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res *= i ; } return res ; } static void printNComposite ( int n ) { long fact = factorial ( n + 1 ) ; for ( int i = 2 ; i <= n + 1 ; ++ i ) { System . out . print ( fact + i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 4 ; printNComposite ( n ) ; } }
import java . io . * ; import java . util . * ; class GFG { static ArrayList < Long > primes ( long n ) { boolean [ ] prime = new boolean [ ( int ) n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } ArrayList < Long > arr = new ArrayList < Long > ( ) ; for ( int i = 2 ; i < n ; i ++ ) if ( prime [ i ] ) arr . add ( ( long ) i ) ; return arr ; } static int countDigits ( long n ) { long temp = n ; int c = 0 ; while ( temp != 0 ) { temp = temp / 10 ; c ++ ; } return c ; } static boolean frugal ( long n ) { ArrayList < Long > r = primes ( n ) ; long t = n ; long s = 0 ; for ( int i = 0 ; i < r . size ( ) ; i ++ ) { if ( t % r . get ( i ) == 0 ) { long k = 0 ; while ( t % r . get ( i ) == 0 ) { t = t / r . get ( i ) ; k ++ ; } if ( k == 1 ) s = s + countDigits ( r . get ( i ) ) ; else if ( k != 1 ) s = s + countDigits ( r . get ( i ) ) + countDigits ( k ) ; } } return ( countDigits ( n ) > s && s != 0 ) ; } public static void main ( String [ ] args ) { long n = 343 ; if ( frugal ( n ) ) System . out . print ( "A Frugal numberNEW_LINE"); else System . out . print ( "Not a frugal numberNEW_LINE"); } }
class GFG { static int nthSquareCube ( int n ) { return n * n * n * n * n * n ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( nthSquareCube ( n ) ) ; } }
class GFG { static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; } public static void main ( String [ ] args ) { int s = 9 ; int n = findS ( s ) ; if ( n == - 1 ) System . out . println ( " - 1" ) ; else System . out . println ( n ) ; } }
class GFG { static int findKthGoodNo ( int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( findKthGoodNo ( n ) ) ; } }
import java . io . * ; class GFG { static void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int n = 5 ; NicomachuTheorum_sum ( n ) ; } }
import java . io . * ; public class GFG { static int checkDigits ( int n ) { while ( n > 0 ) { if ( ( ( n % 10 ) % 2 ) > 0 ) return 0 ; n /= 10 ; } return 1 ; } static int largestNumber ( int n ) { for ( int i = n ; ; i -- ) if ( checkDigits ( i ) > 0 ) return i ; } static public void main ( String [ ] args ) { int N = 23 ; System . out . println ( largestNumber ( N ) ) ; } }
class GFG { static int largestNumber ( int n ) { String s = " " ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( ( ( int ) ( s . charAt ( i ) - '0' ) % 2 ) & 1 ) > 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( int ) ( s . charAt ( i ) - '0' ) ; num = num * 10 + ( ( int ) s . charAt ( index ) - ( int ) ( '0' ) - 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 + 8 ; return num ; } public static void main ( String [ ] args ) { int N = 24578 ; System . out . println ( largestNumber ( N ) ) ; } }
import java . util . * ; class Gfg { static int countDigits ( int n ) { return ( int ) ( n * Math . log10 ( 2 ) + 1 ) ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( countDigits ( n ) ) ; } }
class GFG { static int check_digits ( int n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 != 0 ) return 0 ; n /= 10 ; } return 1 ; } static int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) != 0 ) return i ; } public static void main ( String [ ] args ) { int N = 2397 ; System . out . println ( smallest_number ( N ) ) ; } }
import java . lang . System . * ; class GFG { static int findBucketNo ( int p ) { return ( int ) Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int p = 10 ; System . out . println ( findBucketNo ( p ) ) ; } }
import java . io . * ; class GFG { static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } static int LCMOfNeighbourFact ( int n ) { return factorial ( n + 1 ) ; } public static void main ( String args [ ] ) { int N = 5 ; System . out . println ( LCMOfNeighbourFact ( N ) ) ; } }
class GFG { static int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static boolean checkFriendly ( int n , int m ) { int sumFactors_n = sumofFactors ( n ) ; int sumFactors_m = sumofFactors ( m ) ; int gcd_n = gcd ( n , sumFactors_n ) ; int gcd_m = gcd ( m , sumFactors_m ) ; if ( n / gcd_n == m / gcd_m && sumFactors_n / gcd_n == sumFactors_m / gcd_m ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 6 , m = 28 ; if ( checkFriendly ( n , m ) ) System . out . print ( "YesNEW_LINE"); else System . out . print ( "NoNEW_LINE"); } }
import java . lang . * ; import java . util . * ; class GFG { public static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } public static int primorial ( int n ) { int p = 2 ; n -- ; for ( int i = 3 ; n != 0 ; i ++ ) { if ( isPrime ( i ) == true ) { p = p * i ; n -- ; } i ++ ; } return p ; } public static int findNextPrime ( int n ) { int nextPrime = n + 2 ; while ( true ) { if ( isPrime ( nextPrime ) == true ) break ; nextPrime ++ ; } return nextPrime ; } public static int fortunateNumber ( int n ) { int p = primorial ( n ) ; return findNextPrime ( p ) - p ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( fortunateNumber ( n ) ) ; } }
class GFG { static double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; } public static void main ( String arg [ ] ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = a . length ; System . out . print ( Math . round ( procal ( n ) * 1000000.0 ) / 1000000.0 ) ; } }
import java . io . * ; class GFG { static void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = ( int ) ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; double c = Math . pow ( pow_sum , 1.0 / n ) ; int c_pow = ( int ) Math . pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { System . out . println ( " Count ▁ example ▁ found " ) ; return ; } } System . out . println ( " No ▁ counter ▁ example ▁ within ▁ given " + " ▁ range ▁ and ▁ data " ) ; } public static void main ( String [ ] args ) { testSomeNumbers ( 12 , 5 ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void productReduce ( int n , int num [ ] , int den [ ] ) { int new_num = 1 , new_den = 1 ; for ( int i = 0 ; i < n ; i ++ ) { new_num *= num [ i ] ; new_den *= den [ i ] ; } int GCD = gcd ( new_num , new_den ) ; new_num /= GCD ; new_den /= GCD ; System . out . println ( new_num + " / " + new_den ) ; } public static void main ( String [ ] args ) { int n = 3 ; int num [ ] = { 1 , 2 , 5 } ; int den [ ] = { 2 , 1 , 6 } ; productReduce ( n , num , den ) ; } }
import java . io . * ; class GFG { static int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( fnMod ( n ) ) ; n = 11 ; System . out . println ( fnMod ( n ) ) ; } }
class GFG { static int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } static int repeatedNumberSum ( int n , int x ) { int sum = x * digSum ( n ) ; return digSum ( sum ) ; } public static void main ( String [ ] args ) { int n = 24 , x = 3 ; System . out . println ( repeatedNumberSum ( n , x ) ) ; } }
import java . io . * ; class GFG { static int totalSumDivisibleByNum ( int n , int number ) { int firstnum = ( int ) Math . pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; } public static void main ( String [ ] args ) { int n = 3 , num = 7 ; System . out . println ( totalSumDivisibleByNum ( n , num ) ) ; } }
import java . io . * ; class GFG { static int numberofterm ( int n , int number ) { int firstnum = ( int ) Math . pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; } public static void main ( String [ ] args ) { int n = 3 , num = 7 ; System . out . println ( numberofterm ( n , num ) ) ; } }
import java . io . * ; class GFG { static void georgeCantor ( int n ) { int i = 1 ; int j = 1 ; int k = 1 ; while ( k < n ) { j ++ ; k ++ ; if ( k == n ) break ; while ( j > 1 && k < n ) { i ++ ; j -- ; k ++ ; } if ( k == n ) break ; i ++ ; k ++ ; if ( k == n ) break ; while ( i > 1 && k < n ) { i -- ; j ++ ; k ++ ; } } System . out . println ( " N - th ▁ term ▁ : ▁ " + i + " / " + j ) ; } public static void main ( String [ ] args ) { int n = 15 ; georgeCantor ( n ) ; } }
import java . io . * ; class GFG { static boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { int last_digit = ( int ) n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; } public static void main ( String [ ] args ) { long n = 348 ; if ( isDivisible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static String solveEquation ( String equation ) { int n = equation . length ( ) , sign = 1 , coeff = 0 ; int total = 0 , i = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( equation . charAt ( j ) == ' + ' || equation . charAt ( j ) == ' - ' ) { if ( j > i ) total += sign * Integer . parseInt ( equation . substring ( i , j ) ) ; i = j ; } else if ( equation . charAt ( j ) == ' x ' ) { if ( ( i == j ) || equation . charAt ( j - 1 ) == ' + ' ) coeff += sign ; else if ( equation . charAt ( j - 1 ) == ' - ' ) coeff -= sign ; else coeff += sign * Integer . parseInt ( equation . substring ( i , j ) ) ; i = j + 1 ; } else if ( equation . charAt ( j ) == ' = ' ) { if ( j > i ) total += sign * Integer . parseInt ( equation . substring ( i , j ) ) ; sign = - 1 ; i = j + 1 ; } } if ( i < n ) total = total + sign * Integer . parseInt ( equation . substring ( i ) ) ; if ( coeff == 0 && total == 0 ) return " Infinite ▁ solutions " ; if ( coeff == 0 && total != 0 ) return " No ▁ solution " ; int ans = - total / coeff ; return ( Integer . toString ( ans ) ) ; } public static void main ( String args [ ] ) { String equation = new String ( " x + 5-3 + x = 6 + x - 2" ) ; System . out . print ( " x ▁ = ▁ " + solveEquation ( equation ) ) ; } }
import java . io . * ; import java . util . * ; import java . math . * ; class GFG { static boolean pronic_check ( int n ) { int x = ( int ) ( Math . sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 56 ; if ( pronic_check ( n ) == true ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static final int MAX = 100000 ; static int multiply ( int x , int res [ ] , int res_size ) { int carry = 0 ; for ( int i = 0 ; i < res_size ; i ++ ) { int prod = res [ i ] * x + carry ; res [ i ] = prod % 10 ; carry = prod / 10 ; } while ( carry > 0 ) { res [ res_size ] = carry % 10 ; carry = carry / 10 ; res_size ++ ; } return res_size ; } static void power ( int x , int n ) { if ( n == 0 ) { System . out . print ( "1" ) ; return ; } int res [ ] = new int [ MAX ] ; int res_size = 0 ; int temp = x ; while ( temp != 0 ) { res [ res_size ++ ] = temp % 10 ; temp = temp / 10 ; } for ( int i = 2 ; i <= n ; i ++ ) res_size = multiply ( x , res , res_size ) ; System . out . print ( x + " ^ " + n + " ▁ = ▁ " ) ; for ( int i = res_size - 1 ; i >= 0 ; i -- ) System . out . print ( res [ i ] ) ; } public static void main ( String [ ] args ) { int exponent = 100 ; int base = 2 ; power ( base , exponent ) ; } }
import java . lang . * ; class GFG { static boolean check ( int n , int p ) { int maximum = - 1 ; while ( ( n % 2 ) == 0 ) { maximum = Math . max ( maximum , 2 ) ; n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maximum = Math . max ( maximum , i ) ; n = n / i ; } } if ( n > 2 ) maximum = Math . max ( maximum , n ) ; return ( maximum <= p ) ; } public static void main ( String [ ] args ) { int n = 24 , p = 7 ; if ( check ( n , p ) ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; } }
import java . io . * ; class GFG { static int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( sum_series ( n ) ) ; } }
import java . io . * ; class GFG { static boolean isPrime ( int n ) { if ( n == 0 n == 1 ) return false ; int root = ( int ) Math . sqrt ( n ) ; for ( int i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static boolean isSandwitched ( int n ) { return ( isPrime ( n - 1 ) && isPrime ( n + 1 ) ) ; } public static void main ( String [ ] args ) { int n = 642 ; System . out . print ( n + " ▁ : ▁ " ) ; if ( isSandwitched ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; n = 9 ; System . out . print ( n + " ▁ : ▁ " ) ; if ( isSandwitched ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class tomohiko_sakamoto { public static int day_of_the_week ( int y , int m , int d ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; } public static void main ( String args [ ] ) { int day = 13 , month = 7 , year = 2017 ; System . out . println ( day_of_the_week ( year , month , day ) ) ; } }
import java . util . * ; class GFG { static boolean isPrime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; } public static void main ( String [ ] args ) { int n = 15 ; if ( isPrime ( n , 2 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static boolean isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 10 ; if ( isSquareFree ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static double findArea ( double d ) { return ( d * d ) / 2 ; } public static void main ( String [ ] args ) { double d = 10 ; System . out . println ( findArea ( d ) ) ; } }
import java . io . * ; class GFG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( sumOfSeries ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( sumOfSeries ( n ) ) ; } }
class GFG { static float mean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; } static float SSD ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; return ( float ) Math . sqrt ( sum / ( n - 1 ) ) ; } static float sampleError ( float arr [ ] , int n ) { return SSD ( arr , n ) / ( float ) Math . sqrt ( n ) ; } public static void main ( String [ ] args ) { float arr [ ] = { 78.53f , 79.62f , 80.25f , 81.05f , 83.21f , 83.46f } ; int n = arr . length ; System . out . println ( sampleError ( arr , n ) ) ; } }
import java . lang . * ; class GFG { static int StepstoReachTarget ( int target ) { target = Math . abs ( target ) ; int n = ( int ) Math . ceil ( ( - 1.0 + ( int ) Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; } public static void main ( String [ ] arg ) { int target = 5 ; System . out . println ( StepstoReachTarget ( target ) ) ; } }
import java . io . * ; class GFG { static double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( seriesSum ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int countSymmetric ( int n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countSymmetric ( n ) ) ; } }
import java . io . * ; class GFG { static int centeredNonagonal ( int n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( centeredNonagonal ( n ) ) ; } }
import java . io . * ; class GFG { static float Mean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; } static float meanAbsDevtion ( float arr [ ] , int n ) { float absSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) absSum = absSum + Math . abs ( arr [ i ] - Mean ( arr , n ) ) ; return absSum / n ; } public static void main ( String [ ] args ) { float arr [ ] = { 10 , 15 , 15 , 17 , 18 , 21 } ; int n = arr . length ; System . out . println ( meanAbsDevtion ( arr , n ) ) ; } }
import java . io . * ; class Ratio { static boolean isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; } public static void main ( String args [ ] ) { int lowCost = 14 , upCost = 30 , lowQuant = 5 , upQuant = 12 , r = 9 ; if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static void findNumbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( "1" + " ▁ " ) ; System . out . print ( "2" + " ▁ " ) ; System . out . println ( n + d ) ; } public static void main ( String args [ ] ) { int N = 3 , D = 5 ; findNumbers ( N , D ) ; } }
class GFG { static long oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( oddNumSum ( n ) ) ; } }
import java . io . * ; class GFG { static int trailingZero ( int x ) { int i = 5 , count = 0 ; while ( x > i ) { count = count + x / i ; i = i * 5 ; } return count ; } static int countProductTrailing ( int M , int N ) { return trailingZero ( N ) + trailingZero ( M ) ; } public static void main ( String args [ ] ) { int N = 67 , M = 98 ; System . out . println ( countProductTrailing ( N , M ) ) ; } }
class GFG { static boolean isTrimorphic ( int N ) { int cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N /= 10 ; cube /= 10 ; } return true ; } public static void main ( String [ ] args ) { int N = 24 ; if ( isTrimorphic ( N ) == true ) System . out . println ( " trimorphic " ) ; else System . out . println ( " not ▁ trimorphic " ) ; } }
class GFG { static int INT_MAX = 2147483647 ; static boolean checkTrimorphic ( int num ) { int cube = num * num * num ; while ( num > 0 ) { if ( num % 10 != cube % 10 ) return false ; num /= 10 ; cube /= 10 ; } return true ; } static int nthTrimorphic ( int n ) { int count = 0 ; for ( int i = 0 ; i < INT_MAX ; i ++ ) { if ( checkTrimorphic ( i ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . println ( nthTrimorphic ( n ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int reachTarget ( int target ) { target = Math . abs ( target ) ; int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; } public static void main ( String args [ ] ) { int target = 5 ; System . out . println ( reachTarget ( target ) ) ; } }
import java . io . * ; class GFG { static long fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( fifthPowerSum ( n ) ) ; } }
import java . io . * ; class GFG { static int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; } public static void main ( String args [ ] ) throws IOException { System . out . println ( unitDigitXRaisedY ( 4 , 2 ) ) ; } }
import java . io . * ; class GFG { static int findDivisor ( int x , int y ) { if ( x == y ) return y ; return 2 ; } public static void main ( String [ ] args ) { int x = 3 , y = 16 ; System . out . println ( findDivisor ( x , y ) ) ; } }
import java . io . * ; public class GFG { static float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } static public void main ( String [ ] args ) { int n = 2 ; System . out . println ( AvgofSquareN ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } public static void main ( String argc [ ] ) { int n = 18 ; System . out . println ( sumofFactors ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static float focal_length_concave ( float R ) { return R / 2 ; } public static float focal_length_convex ( float R ) { return - ( R / 2 ) ; } public static void main ( String argc [ ] ) { float R = 30 ; System . out . print ( " Focal ▁ length ▁ of " + " spherical ▁ concave " + " mirror ▁ is ▁ : ▁ " + focal_length_concave ( R ) + " unitsNEW_LINE"); System . out . println ( " Focal ▁ length ▁ of " + " spherical ▁ convex " + " mirror ▁ is ▁ : ▁ " + focal_length_convex ( R ) + " ▁ units " ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } public static void main ( String args [ ] ) throws IOException { int n = 30 ; System . out . println ( sumofoddFactors ( n ) ) ; } }
class GFG { static int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; } public static void main ( String [ ] args ) { int n = 5 ; int val = 20 ; System . out . print ( countSolutions ( n , val ) ) ; } }
class GFG { static final int N = 6 ; static void fib ( int f [ ] , int n ) { int i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( i = 2 ; i <= n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } static void fibcoef ( int fc [ ] [ ] , int f [ ] , int n ) { for ( int i = 0 ; i <= n ; i ++ ) fc [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int k = j ; while ( k > 0 ) { k -- ; fc [ i ] [ j ] *= f [ k ] ; } k = 1 ; while ( ( j + 1 ) != k ) fc [ i ] [ j ] /= f [ k ++ ] ; } } } static void printFibonomialTriangle ( int n ) { int f [ ] = new int [ N + 1 ] ; fib ( f , n ) ; int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) dp [ i ] [ j ] = f [ i - j + 1 ] * dp [ i - 1 ] [ j - 1 ] + f [ j - 1 ] * dp [ i - 1 ] [ j ] ; } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) System . out . print ( dp [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 6 ; printFibonomialTriangle ( n ) ; } }
import java . io . * ; class GFG { static int sumofNterm ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * Math . pow ( r , i - 1 ) ) ) ; return sum ; } public static void main ( String args [ ] ) { int a = 1 , d = 1 , b = 2 , r = 2 , n = 3 ; System . out . println ( sumofNterm ( a , d , b , r , n ) ) ; } }
class GFG { static int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . printf ( " Sum ▁ = ▁ % d " , sumOfTheSeries ( n ) ) ; } }
public class GfG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; } public static void main ( String s [ ] ) { int n = 10 ; System . out . println ( sumOfSeries ( n ) ) ; } }
import java . io . * ; class MathSeries { static double Series ( double x , int n ) { double sum = 1 , term = 1 , fct , j , y = 2 , m ; int i ; for ( i = 1 ; i < n ; i ++ ) { fct = 1 ; for ( j = 1 ; j <= y ; j ++ ) { fct = fct * j ; } term = term * ( - 1 ) ; m = Math . pow ( x , y ) / fct ; m = m * term ; sum = sum + m ; y += 2 ; } return sum ; } public static void main ( String [ ] args ) { double x = 3 ; int n = 4 ; System . out . println ( Math . round ( Series ( x , n ) * 10000.0 ) / 10000.0 ) ; } }
import java . io . * ; class GFG { static double Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 ; double p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; } public static void main ( String args [ ] ) { double x = 9 ; int n = 10 ; System . out . printf ( " % .4f " , Series ( x , n ) ) ; } }
public class GfG { static int two_factor ( int n ) { int twocount = 0 ; while ( n % 2 == 0 ) { twocount ++ ; n = n / 2 ; } return twocount ; } static int five_factor ( int n ) { int fivecount = 0 ; while ( n % 5 == 0 ) { fivecount ++ ; n = n / 5 ; } return fivecount ; } static int find_con_zero ( int arr [ ] , int n ) { int twocount = 0 ; int fivecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twocount += two_factor ( arr [ i ] ) ; fivecount += five_factor ( arr [ i ] ) ; } if ( twocount < fivecount ) return twocount ; else return fivecount ; } public static void main ( String s [ ] ) { int arr [ ] = { 100 , 10 , 5 , 25 , 35 , 14 } ; int n = 6 ; System . out . println ( find_con_zero ( arr , n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; } public static void main ( String argc [ ] ) { int a = 1 , b = 4 , c = 5 ; System . out . println ( first ( a , b , c ) ) ; } }
import java . util . * ; class GFG { static void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { System . out . println ( " First ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Second ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Difference ▁ = ▁ " + 0 ) ; } else { if ( n % 4 == 1 n % 4 == 2 ) { System . out . println ( " First ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Second ▁ subset ▁ sum ▁ = ▁ " + ( ( s / 2 ) + 1 ) ) ; System . out . println ( " Difference ▁ = ▁ " + 1 ) ; } else { System . out . println ( " First ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Second ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Difference ▁ = ▁ " + 0 ) ; } } } public static void main ( String [ ] args ) { int n = 6 ; subsetDifference ( n ) ; } }
import java . io . * ; public class GFG { static void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; System . out . println ( ( float ) time ) ; } static public void main ( String [ ] args ) { double s = 25 , v = 56 ; timeToMeet ( s , v ) ; } }
import java . util . * ; class GFG { static void checksum ( int n ) { if ( n == 0 ) { System . out . println ( " - 1 ▁ 0 ▁ 1" ) ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( int i = 0 ; i <= n - 2 ; i += inc ) { if ( i + i + 1 + i + 2 == n ) { System . out . println ( i + " ▁ " + ( i + 1 ) + " ▁ " + ( i + 2 ) ) ; return ; } } System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { int n = 6 ; checksum ( n ) ; } }
import java . io . * ; class GFG { static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( divisorSum ( n ) ) ; n = 5 ; System . out . println ( divisorSum ( n ) ) ; } }
import java . io . * ; class GFG { static void printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { System . out . print ( m + " ▁ " ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; System . out . print ( binom + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int max = 10 ; printbinomial ( max ) ; } }
import java . io . * ; import java . util . * ; class GFG { static long maxPrimeFactors ( long n ) { long maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n >>= 1 ; } while ( n % 3 == 0 ) { maxPrime = 3 ; n = n / 3 ; } for ( int i = 5 ; i <= Math . sqrt ( n ) ; i += 6 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } while ( n % ( i + 2 ) == 0 ) { maxPrime = i + 2 ; n = n / ( i + 2 ) ; } } if ( n > 4 ) maxPrime = n ; return maxPrime ; } public static void main ( String [ ] args ) { Long n = 15l ; System . out . println ( maxPrimeFactors ( n ) ) ; n = 25698751364526l ; System . out . println ( maxPrimeFactors ( n ) ) ; } }
class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static int countUnsetBitsInGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( r - l + 1 ) - countSetBits ( n & num ) ; } public static void main ( String [ ] args ) { int n = 80 ; int l = 1 , r = 4 ; System . out . print ( countUnsetBitsInGivenRange ( n , l , r ) ) ; } }
import java . io . * ; class GFG { static long evenPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( evenPowerSum ( n ) ) ; } }
import java . io . * ; class GFG { static long evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( evenPowerSum ( n ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 501 ; public static int balancedprime ( int n ) { boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int k = 0 ; k < MAX + 1 ; k ++ ) prime [ k ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } Vector < Integer > v = new Vector < Integer > ( ) ; for ( int p = 3 ; p <= MAX ; p += 2 ) if ( prime [ p ] ) v . add ( p ) ; int count = 0 ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { if ( ( int ) v . get ( i ) == ( ( int ) v . get ( i + 1 ) + ( int ) v . get ( i - 1 ) ) / 2 ) count ++ ; if ( count == n ) return ( int ) v . get ( i ) ; } return 1 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( balancedprime ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { private static final int MAX = 1000001 ; private static final int [ ] factor = new int [ MAX ] ; public static void generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } } public static int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ; int dup = factor [ n ] ; int c = 1 ; int j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; } public static int smallest ( int n ) { for ( int i = 1 ; ; i ++ ) if ( calculateNoOFactors ( i ) >= n ) return i ; } public static void main ( String args [ ] ) { generatePrimeFactors ( ) ; int n = 4 ; System . out . println ( smallest ( n ) ) ; } }
import java . io . * ; class GFG { static int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; } public static void main ( String args [ ] ) throws IOException { int n = 4 ; System . out . println ( squaresum ( n ) ) ; } }
import java . util . * ; class GFG { static boolean isPrime ( int n ) { int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; } static int minimumSum ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( isPrime ( n - 2 ) ) return 2 ; return 3 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( minimumSum ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int firstDigit ( int n ) { while ( n >= 10 ) n /= 10 ; return n ; } public static int lastDigit ( int n ) { return ( n % 10 ) ; } public static void main ( String argc [ ] ) { int n = 98562 ; System . out . println ( firstDigit ( n ) + " ▁ " + lastDigit ( n ) ) ; } }
import java . math . * ; class GFG { static int firstDigit ( int n ) { int digits = ( int ) ( Math . log10 ( n ) ) ; n = ( int ) ( n / ( int ) ( Math . pow ( 10 , digits ) ) ) ; return n ; } static int lastDigit ( int n ) { return ( n % 10 ) ; } public static void main ( String args [ ] ) { int n = 98562 ; System . out . println ( firstDigit ( n ) + " ▁ " + lastDigit ( n ) ) ; } }
import java . util . * ; class GFG { public static boolean isPrime ( int x ) { if ( x == 0 x == 1 ) return false ; for ( int i = 2 ; i * i <= x ; ++ i ) if ( x % i == 0 ) return false ; return true ; } public static void findPrimes ( int n ) { System . out . print ( n ) ; System . out . print ( 2 + " ▁ " + ( n - 2 ) ) ; { System . out . print ( 3 + " ▁ " ) ; n = n - 3 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( i ) && isPrime ( n - i ) ) { System . out . print ( i + " ▁ " + ( n - i ) ) ; break ; } } } } public static void main ( String [ ] args ) { int n = 27 ; findPrimes ( n ) ; } }
class GFG { static long c [ ] = new long [ 100 ] ; static void coef ( int n ) { c [ 0 ] = 1 ; for ( int i = 0 ; i < n ; c [ 0 ] = - c [ 0 ] , i ++ ) { c [ 1 + i ] = 1 ; for ( int j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; } } static boolean isPrime ( int n ) { coef ( n ) ; c [ 0 ] ++ ; c [ n ] -- ; int i = n ; while ( ( i -- ) > 0 && c [ i ] % n == 0 ) ; return i < 0 ; } public static void main ( String [ ] args ) { int n = 37 ; if ( isPrime ( n ) ) System . out . println ( " Prime " ) ; else System . out . println ( " Not ▁ Prime " ) ; } }
import java . util . * ; class Digits { public static int motzkin ( int n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . print ( motzkin ( n ) ) ; } }
import java . io . * ; class GFG { static double sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( sumOfSeries ( n ) ) ; } }
import java . io . * ; import static java . lang . Math . * ; class narcissistic { int countDigit ( int n ) { if ( n == 0 ) return 0 ; return 1 + countDigit ( n / 10 ) ; } boolean check ( int n ) { int l = countDigit ( n ) ; int dup = n ; int sum = 0 ; while ( dup > 0 ) { sum += pow ( dup % 10 , l ) ; dup /= 10 ; } return ( n == sum ) ; } public static void main ( String args [ ] ) { narcissistic obj = new narcissistic ( ) ; int n = 1634 ; if ( obj . check ( n ) ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( summation ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GFG { private static final int MAX = 0 ; public static void leyland ( int n ) { List < Integer > ans = new ArrayList < Integer > ( ) ; for ( int x = 2 ; x <= n ; x ++ ) { for ( int y = 2 ; y <= x ; y ++ ) { int temp = ( int ) Math . pow ( x , y ) + ( int ) Math . pow ( y , x ) ; ans . add ( temp ) ; } } Collections . sort ( ans ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; } public static void main ( String args [ ] ) { int n = 6 ; leyland ( n ) ; } }
import java . util . Arrays ; import java . util . Collections ; class GFG { public static int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; } public static void main ( String [ ] args ) { int k = 3 ; System . out . print ( kthgroupsum ( k ) ) ; } }
import java . util . * ; class GFG { public static int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( nthTerm ( n ) ) ; } }
import java . io . * ; class GFG { static int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( seriesSum ( n ) ) ; } }
class GFG { static double cal_speed ( double dist , double time ) { System . out . print ( " Distance ( km ) : " + dist) ; System . out . print ( " Time ( hr ) : " + time) ; return dist / time ; } static double cal_dis ( double speed , double time ) { System . out . print ( " Time ( hr ) : " + time) ; System . out . print ( " Speed ( km / hr ) : " + speed) ; return speed * time ; } static double cal_time ( double dist , double speed ) { System . out . print ( " Distance ( km ) : "+ dist) ; System . out . print ( " Speed ( km / hr ) : " + speed) ; return speed * dist ; } public static void main ( String [ ] args ) { System . out . println ( " The calculated Speed ( km / hr ) is : "+ cal_speed ( 45.9 , 2.0 ) ) ; System . out . println ( " The calculated Distance ( km ) : "+ cal_dis ( 62.9 , 2.5 ) ) ; System . out . println ( " The calculated Time ( hr ) : "+ cal_time ( 48.0 , 4.5 ) ) ; } }
import java . io . * ; class GFG { static int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( term ( n ) ) ; } }
import java . io . * ; class GFG { static float avgOfFirstN ( int n ) { return ( float ) ( 1 + n ) / 2 ; } public static void main ( String args [ ] ) { int n = 20 ; System . out . println ( avgOfFirstN ( n ) ) ; } }
import java . io . * ; class GFG { static int summation ( int n ) { int sum ; sum = ( int ) ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( summation ( n ) ) ; } }
class GFG { static double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; } public static void main ( String [ ] args ) { int x = 2 ; int n = 5 ; System . out . printf ( " % .2f " , sum ( x , n ) ) ; } }
import java . io . * ; class Series { static int term ( int n ) { int x = ( ( ( 1 ) + ( int ) Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( term ( n ) ) ; } }
import java . util . Scanner ; class Deserium { static int countDigits ( int n ) { int c = 0 ; do { c ++ ; n = n / 10 ; } while ( n != 0 ) ; return c ; } static boolean isDeserium ( int x ) { int temp = x ; int p = countDigits ( x ) ; int sum = 0 ; while ( x != 0 ) { int digit = x % 10 ; sum += Math . pow ( digit , p ) ; p -- ; x = x / 10 ; } return ( sum == temp ) ; } public static void main ( String [ ] args ) { int x = 135 ; if ( isDeserium ( x ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int sameRemainder ( int a , int b , int c ) { int a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; } public static void main ( String [ ] args ) { int a = 62 , b = 132 , c = 237 ; System . out . println ( sameRemainder ( a , b , c ) ) ; } }
import java . io . * ; class GFG { static float mean ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; float mean = ( float ) sum / n ; return mean ; } static float sd ( int arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; float sdd = sum / n ; return sdd ; } static float combinedVariance ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { float mean1 = mean ( arr1 , n ) ; float mean2 = mean ( arr2 , m ) ; System . out . print ( " Mean1 : ▁ " + mean1 + " ▁ " ) ; System . out . println ( " Mean2 : ▁ " + mean2 ) ; float sd1 = sd ( arr1 , n ) ; float sd2 = sd ( arr2 , m ) ; System . out . print ( " StandardDeviation1 : ▁ " + sd1 + " ▁ " ) ; System . out . println ( " StandardDeviation2 : ▁ " + sd2 + " ▁ " ) ; float combinedMean = ( float ) ( n * mean1 + m * mean2 ) / ( n + m ) ; System . out . println ( " Combined ▁ Mean : ▁ " + combinedMean + " ▁ " ) ; float d1_square = ( mean1 - combinedMean ) * ( mean1 - combinedMean ) ; float d2_square = ( mean2 - combinedMean ) * ( mean2 - combinedMean ) ; System . out . print ( " d1 ▁ square : ▁ " + d1_square + " ▁ " ) ; System . out . println ( " d2 _ square : ▁ " + d2_square ) ; float combinedVar = ( n * ( sd1 + d1_square ) + m * ( sd2 + d2_square ) ) / ( n + m ) ; return combinedVar ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 23 , 45 , 34 , 78 , 12 , 76 , 34 } ; int arr2 [ ] = { 65 , 67 , 34 , 23 , 45 } ; int n = arr1 . length ; int m = arr2 . length ; System . out . println ( " Combined ▁ Variance : ▁ " + combinedVariance ( arr1 , arr2 , n , m ) ) ; } }
class GFG { static boolean checkDivisibility ( String num ) { int length = num . length ( ) ; if ( length == 1 && num . charAt ( 0 ) == '0' ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . abs ( sum ) ; return ( sum % 13 == 0 ) ; } public static void main ( String [ ] args ) { String number = "83959092724" ; if ( checkDivisibility ( number ) ) System . out . println ( number + " ▁ is ▁ divisible ▁ by ▁ 13 . " ) ; else System . out . println ( number + " ▁ is ▁ not ▁ divisible ▁ by ▁ 13 . " ) ; } }
import java . io . * ; class GFG { static void modularEquation ( int a , int b ) { if ( a < b ) { System . out . println ( " No ▁ solution ▁ possible ▁ " ) ; return ; } if ( a == b ) { System . out . println ( " Infinite ▁ Solution ▁ possible ▁ " ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) Math . sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; System . out . println ( count ) ; } public static void main ( String [ ] args ) { int a = 21 , b = 5 ; modularEquation ( a , b ) ; } }
import java . io . * ; public class GFG { static int countWays ( int num ) { int [ ] dp = new int [ num + 1 ] ; int MOD = ( int ) 1E9 + 7 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= num ; ++ i ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 3 ; ++ j ) { if ( i - j == 0 ) dp [ i ] += 1 ; else if ( j == 1 ) dp [ i ] += dp [ i - j ] * 2 ; else if ( i - j > 0 ) dp [ i ] += dp [ i - j ] ; if ( dp [ i ] >= MOD ) dp [ i ] %= MOD ; } } return dp [ num ] ; } static public void main ( String [ ] args ) { int n = 3 ; System . out . println ( countWays ( n ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static boolean judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; } public static void main ( String argc [ ] ) { int n = 17 ; if ( judgeSquareSum ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + Math . min ( Math . max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; } public static void main ( String [ ] args ) { int n = 13 ; System . out . println ( countDigitOne ( n ) ) ; n = 113 ; System . out . println ( countDigitOne ( n ) ) ; n = 205 ; System . out . println ( countDigitOne ( n ) ) ; } }
class GFG { public static boolean isPrime ( char c ) { return ( c == '2' c == '3' c == '5' c == '7' ) ; } public static void decrease ( StringBuilder s , int i ) { if ( s . charAt ( i ) <= '2' ) { s . deleteCharAt ( i ) ; s . setCharAt ( i , '7' ) ; } else if ( s . charAt ( i ) == '3' ) s . setCharAt ( i , '2' ) ; else if ( s . charAt ( i ) <= '5' ) s . setCharAt ( i , '3' ) ; else if ( s . charAt ( i ) <= '7' ) s . setCharAt ( i , '5' ) ; else s . setCharAt ( i , '7' ) ; return ; } public static String primeDigits ( StringBuilder s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! isPrime ( s . charAt ( i ) ) ) { while ( i >= 0 && s . charAt ( i ) <= '2' ) i -- ; if ( i < 0 ) { i = 0 ; decrease ( s , i ) ; } else decrease ( s , i ) ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) s . setCharAt ( j , '7' ) ; break ; } } return s . toString ( ) ; } public static void main ( String [ ] args ) { StringBuilder s = new StringBuilder ( "45" ) ; System . out . println ( primeDigits ( s ) ) ; s = new StringBuilder ( "1000" ) ; System . out . println ( primeDigits ( s ) ) ; s = new StringBuilder ( "7721" ) ; System . out . println ( primeDigits ( s ) ) ; s = new StringBuilder ( "7221" ) ; System . out . println ( primeDigits ( s ) ) ; s = new StringBuilder ( "74545678912345689748593275897894708927680" ) ; System . out . println ( primeDigits ( s ) ) ; } }
import java . util . * ; class solution { static void greatest ( String s ) { int n = s . length ( ) ; int [ ] a = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s . charAt ( i ) - '0' ; sum += a [ i ] ; } { if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 0 ) { System . out . println ( " - 1" ) ; } else { System . out . println ( n ) ; } } else { int re = sum % 3 ; int del = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { del = i ; flag = 1 ; break ; } else { del = i ; } } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) del = n - 1 ; } if ( del == - 1 ) System . out . println ( - 1 ) ; else { System . out . println ( del + 1 ) ; } } } public static void main ( String args [ ] ) { String s = "7510222" ; greatest ( s ) ; } }
class GFG { static boolean asPowerSum ( int w , int m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; } public static void main ( String [ ] args ) { int w = 3 , m = 7 ; if ( asPowerSum ( w , m ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int divisible ( String num ) { int n = num . length ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; } public static void main ( String [ ] args ) { String num = "1234" ; System . out . println ( divisible ( num ) ) ; } }
import java . io . * ; class GFG { static int n = 3 ; static int dotProduct ( int vect_A [ ] , int vect_B [ ] ) { int product = 0 ; for ( int i = 0 ; i < n ; i ++ ) product = product + vect_A [ i ] * vect_B [ i ] ; return product ; } static void crossProduct ( int vect_A [ ] , int vect_B [ ] , int cross_P [ ] ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; } public static void main ( String [ ] args ) { int vect_A [ ] = { 3 , - 5 , 4 } ; int vect_B [ ] = { 2 , 6 , 5 } ; int cross_P [ ] = new int [ n ] ; System . out . print ( " Dot ▁ product : " ) ; System . out . println ( dotProduct ( vect_A , vect_B ) ) ; System . out . print ( " Cross ▁ product : " ) ; crossProduct ( vect_A , vect_B , cross_P ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( cross_P [ i ] + " ▁ " ) ; } }
class GFG { static int MOD = 1000000007 ; static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( 1 * res * x ) % p ; x = ( 1 * x * x ) % p ; } return res ; } static int countEvenWays ( int n ) { return power ( 2 , n / 2 - 1 , MOD ) ; } public static void main ( String args [ ] ) { int n = 6 ; System . out . println ( countEvenWays ( n ) ) ; n = 8 ; System . out . println ( countEvenWays ( n ) ) ; } }
class GFG { static final int MAX = 1000001 ; static int factor [ ] = new int [ MAX ] ; static void cal_factor ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } } static int no_of_representations ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = a [ i ] ; int flag = 0 ; while ( factor [ temp ] != 1 ) { flag = - 1 ; count ++ ; temp = temp / factor [ temp ] ; } count += flag ; } return count ; } public static void main ( String [ ] args ) { cal_factor ( ) ; int a [ ] = { 4 , 4 , 4 } ; int n = a . length ; System . out . print ( no_of_representations ( a , n ) ) ; } }
import java . io . * ; class GFG { static int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; } public static void main ( String args [ ] ) { int M = 3 ; int A [ ] = { 1 , 2 , 4 , 3 } ; int N = A . length ; System . out . println ( coutSubSeq ( A , N , M ) ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int countSubSeq ( int A [ ] , int N , int M ) { int ans = 0 ; int h [ ] = new int [ M ] ; Arrays . fill ( h , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = i ; j < M ; j ++ ) { int rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; } public static void main ( String args [ ] ) { int M = 3 ; int A [ ] = { 1 , 2 , 4 , 3 } ; int N = A . length ; System . out . println ( countSubSeq ( A , N , M ) ) ; } }
import java . lang . * ; class GFG { static int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( findTerm ( n ) ) ; } }
import java . io . * ; class GFG { static int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( findNumber ( n ) ) ; } }
import java . math . * ; class GFG { static float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; } public static void main ( String args [ ] ) { int X [ ] = { 15 , 18 , 21 , 24 , 27 } ; int Y [ ] = { 25 , 25 , 27 , 31 , 32 } ; int n = X . length ; System . out . printf ( " % 6f " , correlationCoefficient ( X , Y , n ) ) ; } }
class GFG { static void result ( long n , long k , long t ) { if ( t <= k ) System . out . println ( t ) ; else if ( t <= n ) System . out . println ( k ) ; else { long temp = t - n ; temp = k - temp ; System . out . println ( temp ) ; } } public static void main ( String args [ ] ) { long n , k , t ; n = 10 ; k = 5 ; t = 12 ; result ( n , k , t ) ; } }
class GFG { static float weightedMean ( int X [ ] , int W [ ] , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) ( numWeight ) / sum ; } public static void main ( String args [ ] ) { int X [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int W [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = X . length ; int m = W . length ; if ( n == m ) System . out . println ( weightedMean ( X , W , n ) ) ; else System . out . println ( " - 1" ) ; } }
import java . io . * ; class GFG { static double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; } public static void main ( String args [ ] ) { double a = 1.20 , b = 22.5 ; System . out . printf ( " % .1f " , gcd ( a , b ) ) ; } }
import java . io . * ; class GFG { static float harmonicMean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; } public static void main ( String args [ ] ) { float arr [ ] = { 13.5f , 14.5f , 14.8f , 15.2f , 16.1f } ; int n = arr . length ; System . out . println ( harmonicMean ( arr , n ) ) ; } }
class GFG { static float harmonicMean ( int arr [ ] , int freq [ ] , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return ( frequency_sum / sum ) ; } public static void main ( String args [ ] ) { int num [ ] = { 13 , 14 , 15 , 16 , 17 } ; int freq [ ] = { 2 , 5 , 13 , 7 , 3 } ; int n = num . length ; System . out . println ( harmonicMean ( num , freq , n ) ) ; } }
import java . io . * ; class GFG { static void point ( int a , int b , int c , int d , int n ) { int x , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = b + i * a ; if ( ( x - d ) % c == 0 && x - d >= 0 ) { System . out . println ( x ) ; flag = 1 ; break ; } } if ( flag == 0 ) { System . out . println ( " No ▁ collision ▁ point " ) ; } } public static void main ( String [ ] args ) { int a = 20 ; int b = 2 ; int c = 9 ; int d = 19 ; int n = 20 ; point ( a , b , c , d , n ) ; } }
import java . io . * ; import java . math . * ; class GFG { static void findArmstrong ( int low , int high ) { for ( int i = low + 1 ; i < high ; ++ i ) { int x = i ; int n = 0 ; while ( x != 0 ) { x /= 10 ; ++ n ; } int pow_sum = 0 ; x = i ; while ( x != 0 ) { int digit = x % 10 ; pow_sum += Math . pow ( digit , n ) ; x /= 10 ; } if ( pow_sum == i ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String args [ ] ) { int num1 = 100 ; int num2 = 400 ; findArmstrong ( num1 , num2 ) ; System . out . println ( ) ; } }
class GFG { static void gcdMax ( int [ ] a , int [ ] b , int n , int N ) { int [ ] cnt = new int [ N ] ; int [ ] first = new int [ N ] ; int [ ] second = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; int x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; System . out . println ( first [ x ] + " ▁ " + second [ x ] ) ; } public static void main ( String [ ] args ) { int [ ] a = { 3 , 1 , 4 , 2 , 8 } ; int [ ] b = { 5 , 2 , 12 , 8 , 3 } ; int n = a . length ; int N = 20 ; gcdMax ( a , b , n , N ) ; } }
import java . util . * ; class GFG { static void printPierpont ( int n ) { boolean [ ] arr = new boolean [ n + 1 ] ; int two = 1 , three = 1 ; while ( two + 1 < n ) { arr [ two ] = true ; while ( two * three + 1 < n ) { arr [ three ] = true ; arr [ two * three ] = true ; three *= 3 ; } three = 1 ; two *= 2 ; } ArrayList < Integer > v = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] ) v . add ( i + 1 ) ; arr = new boolean [ n + 1 ] ; for ( int p = 2 ; p * p < n ; p ++ ) { if ( arr [ p ] == false ) for ( int i = p * 2 ; i < n ; i += p ) arr [ i ] = true ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) if ( ! arr [ v . get ( i ) ] ) System . out . print ( v . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 200 ; printPierpont ( n ) ; } }
class GFG { static boolean isWoodall ( int x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; int p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; } public static void main ( String args [ ] ) { int x = 383 ; if ( isWoodall ( x ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static void print_result ( int a [ ] , int n , int k , int m ) { Vector < Vector < Integer > > v = new Vector < Vector < Integer > > ( m ) ; for ( int i = 0 ; i < m ; i ++ ) v . add ( new Vector < Integer > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v . get ( rem ) . add ( a [ i ] ) ; if ( v . get ( rem ) . size ( ) == k ) { for ( int j = 0 ; j < k ; j ++ ) System . out . print ( v . get ( rem ) . get ( j ) + " ▁ " ) ; return ; } } System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 8 , 4 } ; int n = a . length ; print_result ( a , n , 2 , 3 ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static int smallestX ( int n ) { int [ ] temp = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) temp [ i ] = 0 ; if ( n == 0 ) return - 1 ; int count = 0 , x = 0 ; for ( x = 1 ; count < 10 ; x ++ ) { int y = x * n ; while ( y > 0 ) { if ( temp [ y % 10 ] == 0 ) { count ++ ; temp [ y % 10 ] = 1 ; } y /= 10 ; } } return x - 1 ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . print ( smallestX ( n ) ) ; } }
class GFG { static int digSum ( int n ) { int sum = 0 , rem = 0 ; while ( n > 0 ) { rem = n % 10 ; sum += rem ; n /= 10 ; } return sum ; } static int findX ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i + digSum ( i ) == n ) return i ; return - 1 ; } public static void main ( String [ ] args ) { int n = 43 ; System . out . println ( " x ▁ = ▁ " + findX ( n ) ) ; } }
class GFG { static void complement ( String number1 ) { char [ ] number = number1 . toCharArray ( ) ; for ( int i = 0 ; i < number . length ; i ++ ) if ( number [ i ] != ' . ' ) number [ i ] = ( char ) ( ( int ) ( '9' ) - ( int ) ( number [ i ] ) + ( int ) ( '0' ) ) ; System . out . println ( "9 ' s ▁ complement ▁ is ▁ : ▁ " + String . valueOf ( number ) ) ; } public static void main ( String [ ] args ) { String number = "345.45" ; complement ( number ) ; } }
public class Main { static int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( countWays ( n ) ) ; } }
class GFG { static boolean isDigitPresent ( int m , boolean hash [ ] ) { while ( m > 0 ) { if ( hash [ m % 10 ] ) return true ; m = m / 10 ; } return false ; } static int countDivisibles ( int n ) { boolean hash [ ] = new boolean [ 10 ] ; int m = n ; while ( m > 0 ) { hash [ m % 10 ] = true ; m = m / 10 ; } int ans = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( isDigitPresent ( i , hash ) ) ans ++ ; if ( n / i != i ) { if ( isDigitPresent ( n / i , hash ) ) ans ++ ; } } } return ans ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . print ( countDivisibles ( n ) ) ; } }
class GFG { static int MAX = 100 ; static String s = " " ; static void luDecomposition ( int [ ] [ ] mat , int n ) { int [ ] [ ] lower = new int [ n ] [ n ] ; int [ ] [ ] upper = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = i ; k < n ; k ++ ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ; upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; } for ( int k = i ; k < n ; k ++ ) { if ( i == k ) else { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ; } } } System . out . println ( setw ( 2 ) + " TABSYMBOL Lower ▁ Triangular " + setw ( 10 ) + " Upper ▁ Triangular " ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 4 ) + lower [ i ] [ j ] + " TABSYMBOL " ) ; System . out . print ( " TABSYMBOL " ) ; for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 4 ) + upper [ i ] [ j ] + " TABSYMBOL " ) ; System . out . print ( "NEW_LINE"); } } static String setw ( int noOfSpace ) { s = " " ; for ( int i = 0 ; i < noOfSpace ; i ++ ) s += " ▁ " ; return s ; } public static void main ( String arr [ ] ) { int mat [ ] [ ] = { { 2 , - 1 , - 2 } , { - 4 , 6 , 3 } , { - 4 , - 2 , 8 } } ; luDecomposition ( mat , 3 ) ; } }
public class DivisibleParts { static void printTwoDivisibleParts ( String num , int f , int s ) { int N = num . length ( ) ; int [ ] prefixReminder = new int [ N + 1 ] ; int [ ] suffixReminder = new int [ N + 1 ] ; suffixReminder [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( num . charAt ( i - 1 ) - '0' ) ) % f ; prefixReminder [ N ] = 0 ; int base = 1 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( num . charAt ( i ) - '0' ) * base ) % s ; base = ( base * 10 ) % s ; } for ( int i = 0 ; i < N ; i ++ ) { if ( prefixReminder [ i ] == 0 && suffixReminder [ i ] == 0 && num . charAt ( i ) != '0' ) { System . out . println ( num . substring ( 0 , i ) + " ▁ " + num . substring ( i ) ) ; return ; } } System . out . println ( " Not ▁ Possible " ) ; } public static void main ( String [ ] args ) { String num = "246904096" ; int f = 12345 ; int s = 1024 ; printTwoDivisibleParts ( num , f , s ) ; } }
class Subarray { static int calculate ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + 1 ; for ( int j = r ; j < n ; j ++ ) { if ( a [ i ] == a [ j ] ) r += 1 ; else break ; } int d = r - i ; ans += ( d * ( d + 1 ) / 2 ) ; i = r - 1 ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 4 , 5 , 3 , 3 , 3 } ; System . out . println ( calculate ( a , a . length ) ) ; } }
import java . io . * ; class GFG { static int sum ( int n ) { int rem = 0 ; int sum_of_digits = 0 ; while ( n > 0 ) { rem = n % 10 ; sum_of_digits += rem ; n = n / 10 ; } return sum_of_digits ; } static int count ( int n ) { int c = 0 ; for ( int i = n - 97 ; i <= n ; i ++ ) { int a = sum ( i ) ; int b = sum ( a ) ; if ( ( i + a + b ) == n ) { c += 1 ; } } return c ; } public static void main ( String [ ] args ) { int n = 9939 ; System . out . println ( count ( n ) ) ; } }
class GFG { static boolean isPowerOfK ( int n , int k ) { boolean oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; } public static void main ( String [ ] args ) { int n = 64 , k = 4 ; if ( isPowerOfK ( n , k ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static int MAX_DIGITS = 20 ; static int isOctal ( int n ) { while ( n > 0 ) { if ( ( n % 10 ) >= 8 ) return 0 ; else n = n / 10 ; } return 1 ; } static int isPalindrome ( int n ) { int divide = ( isOctal ( n ) == 0 ) ? 8 : 10 ; int octal [ ] = new int [ MAX_DIGITS ] ; int i = 0 ; while ( n != 0 ) { octal [ i ++ ] = n % divide ; n = n / divide ; } for ( int j = i - 1 , k = 0 ; k <= j ; j -- , k ++ ) if ( octal [ j ] != octal [ k ] ) return 0 ; return 1 ; } public static void main ( String [ ] args ) { int n = 97 ; if ( isPalindrome ( n ) > 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { System . out . print ( fact + " ▁ " ) ; fact = fact * x ; x ++ ; } } public static void main ( String [ ] args ) { int n = 100 ; printFactorialNums ( n ) ; } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean isThreeDisctFactors ( long n ) { int sq = ( int ) Math . sqrt ( n ) ; if ( 1L * sq * sq != n ) return false ; return isPrime ( sq ) ? true : false ; } public static void main ( String [ ] args ) { long num = 9 ; if ( isThreeDisctFactors ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; num = 15 ; if ( isThreeDisctFactors ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; num = 12397923568441L ; if ( isThreeDisctFactors ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int computeLastDigit ( long A , long B ) { int variable = 1 ; return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long i = A + 1 ; i <= B ; i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } } public static void main ( String [ ] args ) { System . out . println ( computeLastDigit ( 2632 , 2634 ) ) ; } }
class GFG { static float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; } public static void main ( String args [ ] ) { int n = 20 ; float a = 2.5f , d = 1.5f ; System . out . println ( sumOfAP ( a , d , n ) ) ; } }
class GFG { public static final long M = 1000000007 ; static long multiplyFactors ( int n ) { long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( multiplyFactors ( n ) ) ; } }
class GFG { public static final long M = 1000000007 ; static long power ( long x , long y ) { long res = 1 ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % M ; y = ( y >> 1 ) % M ; x = ( x * x ) % M ; } return res ; } static int countFactors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count ++ ; else count += 2 ; } } return count ; } static long multiplyFactors ( int n ) { int numFactor = countFactors ( n ) ; long product = power ( n , numFactor / 2 ) ; if ( numFactor % 2 == 1 ) product = ( product * ( int ) Math . sqrt ( n ) ) % M ; return product ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( multiplyFactors ( n ) ) ; } }
import java . util . * ; class GFG { static boolean isDivisibleBy10 ( String bin ) { int n = bin . length ( ) ; if ( bin . charAt ( n - 1 ) == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin . charAt ( i ) == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { String bin = "11000111001110" ; if ( isDivisibleBy10 ( bin ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . io . * ; class GFG { static void printTrib ( int n ) { if ( n < 1 ) return ; int first = 0 , second = 0 ; int third = 1 ; System . out . print ( first + " ▁ " ) ; if ( n > 1 ) System . out . print ( second + " ▁ " ) ; if ( n > 2 ) System . out . print ( second + " ▁ " ) ; for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; System . out . print ( curr + " ▁ " ) ; } } public static void main ( String args [ ] ) { int n = 10 ; printTrib ( n ) ; } }
import java . util . * ; import java . lang . Math ; class GFG { static ArrayList < Integer > SieveOfEratosthenes ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = true ; } ArrayList < Integer > lis = new ArrayList < Integer > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) lis . add ( p ) ; return lis ; } static int setBits ( int n ) { return Integer . bitCount ( n ) ; } public static int log2 ( int x ) { return ( int ) ( Math . log ( x ) / Math . log ( 2 ) + 1e-10 ) ; } public static void main ( String [ ] args ) { int x = 4 , y = 8 ; int count = 0 ; ArrayList < Integer > primeArr = new ArrayList < Integer > ( ) ; primeArr = SieveOfEratosthenes ( ( int ) Math . ceil ( log2 ( y ) ) ) ; for ( int i = x ; i < y + 1 ; i ++ ) { int temp = setBits ( i ) ; if ( primeArr . contains ( temp ) ) count += 1 ; } System . out . println ( count ) ; } }
class GFG { static int count_square ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { int k = n - i + 1 ; count += ( k * k ) ; } return count ; } public static void main ( String [ ] args ) { int N = 8 ; System . out . println ( count_square ( N ) ) ; } }
class GFG { static int countAnomalies ( int arr [ ] , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 } ; int n = arr . length ; int k = 1 ; System . out . print ( countAnomalies ( arr , n , k ) ) ; } }
class GFG { static int N = 100005 ; static int d [ ] = new int [ N ] , pre [ ] = new int [ N ] ; static void Positive_Divisors ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) d [ i ] ++ ; else d [ i ] += 2 ; } } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( d [ i ] == d [ i - 1 ] ) ans ++ ; pre [ i ] = ans ; } } public static void main ( String [ ] args ) { Positive_Divisors ( ) ; int n = 15 ; System . out . println ( pre [ n ] ) ; } }
class GFG { static int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) { return - 1 ; } int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = number * 10 + 1 ; if ( ( number % K == 0 ) ) { return len ; } } return - 1 ; } public static void main ( String [ ] args ) { int K = 7 ; System . out . println ( numLen ( K ) ) ; } }
class GFG { static boolean doesContainB ( int a , int b , int c ) { if ( a == b ) { return true ; } if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int a = 1 , b = 7 , c = 3 ; if ( doesContainB ( a , b , c ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class GFG { static void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) System . out . print ( y + " ▁ " + x + " ▁ " ) ; else System . out . print ( x + " ▁ " + y + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 2 , k = 1 ; printPermutation ( n , k ) ; } }
class GFG { static int maxSum ( int N ) { int ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( maxSum ( N ) ) ; } }
import java . util . * ; class GFG { static void maximumFactor ( int [ ] arr ) { int [ ] rank = new int [ Arrays . stream ( arr ) . max ( ) . getAsInt ( ) + 1 ] ; int [ ] factors = new int [ Arrays . stream ( arr ) . max ( ) . getAsInt ( ) + 1 ] ; int g = 0 ; for ( int i = 2 ; i <= Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) if ( arr [ j ] % i == 0 ) count += 1 ; rank [ g ] = count ; factors [ g ] = i ; g ++ ; } int m = Arrays . stream ( rank ) . max ( ) . getAsInt ( ) ; for ( int i = 0 ; i < rank . length ; i ++ ) { if ( rank [ i ] == m ) System . out . print ( factors [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 120 , 15 , 24 , 63 , 18 } ; maximumFactor ( arr ) ; } }
import java . io . * ; class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( findSum ( n ) ) ; } }
import java . util . * ; class GFG { public static double findMedian ( int a [ ] , int n ) { Arrays . sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = a . length ; System . out . println ( " Median ▁ = ▁ " + findMedian ( a , n ) ) ; } }
import java . util . * ; class GFG { public static double findMean ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = a . length ; System . out . println ( " Mean ▁ = ▁ " + findMean ( a , n ) ) ; } }
import java . util . ArrayList ; class GFG { static boolean CheckArray ( int arr [ ] , int n ) { int prod = 1 ; ArrayList < Integer > freq = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { freq . add ( arr [ i ] ) ; prod *= arr [ i ] ; } int root = ( int ) Math . sqrt ( prod ) ; if ( root * root == prod ) { if ( freq . contains ( root ) & freq . lastIndexOf ( root ) != ( freq . size ( ) ) ) { return true ; } } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 12 , 3 , 2 } ; int n = arr . length ; if ( CheckArray ( arr , n ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . util . * ; class GFG { static int toK ( int N , int K ) { int w = 1 ; int s = 0 ; while ( N != 0 ) { int r = N % K ; N = N / K ; s = r * w + s ; w *= 10 ; } return s ; } static boolean check ( int N ) { boolean fl = false ; while ( N != 0 ) { int r = N % 10 ; N = N / 10 ; if ( fl == true && r == 0 ) return false ; if ( r > 0 ) { fl = false ; continue ; } fl = true ; } return true ; } static void hasConsecutiveZeroes ( int N , int K ) { int z = toK ( N , K ) ; if ( check ( z ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int N = 15 ; int K = 8 ; hasConsecutiveZeroes ( N , K ) ; } }
public class GFG { static int MAX = 1000000 ; static boolean prime [ ] = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) { prime [ i ] = false ; } } } } static void SumOfKthPrimes ( int arr [ ] , int n , int k ) { int c = 0 ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { sum += arr [ i ] ; c = 0 ; } } } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int arr [ ] = { 2 , 3 , 5 , 7 , 11 } ; int n = arr . length ; int k = 2 ; SumOfKthPrimes ( arr , n , k ) ; } }
class GFG { static int MAX = 100000 ; static boolean [ ] prime = new boolean [ 100002 ] ; static void SieveOfEratosthenes ( ) { for ( int p = 2 ; p * p <= MAX ; p ++ ) if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } static int superpower ( int n ) { SieveOfEratosthenes ( ) ; int superPower = 0 , factor = 0 ; int i = 2 ; while ( n > 1 && i <= MAX ) { if ( ! prime [ i ] ) { factor = 0 ; while ( n % i == 0 && n > 1 ) { factor ++ ; n = n / i ; } if ( superPower < factor ) superPower = factor ; } i ++ ; } return superPower ; } public static void main ( String [ ] args ) { int n = 256 ; System . out . println ( superpower ( n ) ) ; } }
import java . io . * ; class GFG { static int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; } public static void main ( String [ ] args ) { int n = 31 ; System . out . println ( smallestDivisor ( n ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; } public static void main ( String args [ ] ) { int Heads = 100 , Legs = 300 ; int Rabbits = countRabbits ( Heads , Legs ) ; System . out . println ( " Rabbits ▁ = ▁ " + Rabbits ) ; System . out . println ( " Pigeons ▁ = ▁ " + ( Heads - Rabbits ) ) ; } }
import java . util . * ; class gfg { public static double calculateSum ( double n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; } public static void main ( String [ ] args ) { double n = 1.4142 ; System . out . println ( ( int ) Math . ceil ( calculateSum ( n ) ) ) ; } }
import java . util . * ; class solution { static int Sum_upto_nth_Term ( int n ) { return ( 1 - ( int ) Math . pow ( - 2 , n ) ) ; } public static void main ( String arr [ ] ) { int N = 5 ; System . out . println ( Sum_upto_nth_Term ( N ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int xorEqualsOrCount ( int N ) { int count = 0 ; int bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = N / 2 ; } return ( int ) Math . pow ( 2 , count ) ; } public static void main ( String args [ ] ) { int N = 7 ; System . out . println ( xorEqualsOrCount ( N ) ) ; } }
public class SumOfSeries { static int fact ( int n ) { if ( n == 1 ) return 1 ; return n * fact ( n - 1 ) ; } static double sum ( int x , int n ) { double total = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { total = total + ( Math . pow ( x , i ) / fact ( i + 1 ) ) ; } return total ; } public static void main ( String [ ] args ) { int x = 5 , n = 4 ; System . out . print ( " Sum ▁ is : ▁ " + sum ( x , n ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - ( int ) Math . pow ( i , 2 ) ; else result = result + ( int ) Math . pow ( i , 2 ) ; } return result ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . println ( sum_of_series ( n ) ) ; n = 10 ; System . out . println ( sum_of_series ( n ) ) ; } }
import java . util . * ; class solution { static int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( findSum ( N ) ) ; } }
public class GFG { private static final int MAX = 16 ; static long nCr [ ] [ ] = new long [ MAX ] [ MAX ] ; static void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } } static double findCosNTheta ( double sinTheta , int n ) { double cosTheta = Math . sqrt ( 1 - sinTheta * sinTheta ) ; double ans = 0 ; long toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { ans = ans + nCr [ n ] [ i ] * Math . pow ( cosTheta , n - i ) * Math . pow ( sinTheta , i ) * toggle ; toggle = toggle * - 1 ; } return ans ; } public static void main ( String args [ ] ) { binomial ( ) ; double sinTheta = 0.5 ; int n = 10 ; System . out . println ( findCosNTheta ( sinTheta , n ) ) ; } }
class GFG { static int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int calculateSum ( int n ) { return ( ( int ) Math . pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / ( int ) Math . pow ( 9 , 3 ) - n * ( n + 1 ) / 18 ; } public static void main ( String ar [ ] ) { int n = 3 ; System . out . println ( " Sum = ▁ " + calculateSum ( n ) ) ; } }
import java . util . * ; class GFG { static int calculateSum ( int n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; } public static void main ( String ar [ ] ) { int n = 8 ; System . out . println ( calculateSum ( n ) ) ; } }
public class GFG { static boolean isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = Math . log ( a ) / Math . log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . println ( isPower ( n ) ? " Yes " : " No " ) ; } }
class GFG { static float rmsValue ( int arr [ ] , int n ) { int square = 0 ; float mean = 0 ; float root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { square += Math . pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = ( float ) Math . sqrt ( mean ) ; return root ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 4 , 6 , 8 } ; int n = arr . length ; System . out . println ( rmsValue ( arr , n ) ) ; } }
import java . io . * ; class GFG { static double Mixture ( int X , int Y , int Z ) { double result1 = 0.0 , result = 0.0 ; result1 = ( ( X - Y ) / ( float ) X ) ; result = Math . pow ( result1 , Z ) ; result = result * X ; return result ; } public static void main ( String [ ] args ) { int X = 10 , Y = 2 , Z = 2 ; System . out . println ( ( float ) Mixture ( X , Y , Z ) + " ▁ litres " ) ; } }
class Geeks { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y != 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int check ( int n ) { int mod = ( int ) ( 1e9 + 7 ) ; n -- ; int ans = n * n ; if ( ans >= mod ) ans %= mod ; ans += n + 2 ; if ( ans >= mod ) ans %= mod ; ans = ( power ( 2 , n , mod ) % mod * ans % mod ) % mod ; ans = ( ans - 1 + mod ) % mod ; return ans ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( check ( n ) ) ; } }
import java . io . * ; import java . lang . * ; class GfG { public static int findLCM ( int a , int b ) { int lar = Math . max ( a , b ) ; int small = Math . min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } } public static void main ( String [ ] argc ) { int a = 5 , b = 7 ; System . out . println ( " LCM ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + findLCM ( a , b ) ) ; } }
class GFG { static void primes ( int n ) { int i = 2 ; int j = 0 ; int [ ] result = new int [ n ] ; int z = 0 ; while ( j < n ) { boolean flag = true ; for ( int item = 2 ; item <= ( int ) ( i * 1 / 2 ) ; item ++ ) if ( i % item == 0 && i != item ) { flag = false ; break ; } if ( flag ) { result [ z ++ ] = i ; j += 1 ; } i += 1 ; } for ( i = 0 ; i < result . length ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) System . out . print ( result [ j ] ) ; System . out . print ( " ▁ " ) ; } } static void smar_wln ( int n ) { primes ( n ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( " First ▁ " + n + " ▁ terms ▁ of ▁ the ▁ Sequence ▁ are " ) ; smar_wln ( n ) ; } }
import java . io . * ; class GFG { static int Pentatope_number ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( n + " th ▁ " + " Pentatope ▁ number ▁ : " + Pentatope_number ( n ) ) ; n = 12 ; System . out . println ( n + " th ▁ " + " Pentatope ▁ number ▁ : " + Pentatope_number ( n ) ) ; } }
import java . io . * ; class GFG { static int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( centeredIcosahedralNum ( n ) ) ; n = 12 ; System . out . println ( centeredIcosahedralNum ( n ) ) ; } }
import java . io . * ; class GFG { static int centered_square_num ( int n ) { return n * n + ( ( n - 1 ) * ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( n + " th ▁ Centered " + " ▁ square ▁ number : ▁ " + centered_square_num ( n ) ) ; } }
import java . io . * ; class GFG { static int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( seriesSum ( n ) ) ; } }
import java . util . * ; class GFG { static int Dodecagonal_number ( int n ) { return 5 * n * n - 4 * n ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( Dodecagonal_number ( n ) ) ; n = 12 ; System . out . println ( Dodecagonal_number ( n ) ) ; } }
class GFG { static void SieveOfEratosthenes ( int n , boolean prime [ ] , boolean primesquare [ ] , int a [ ] ) { for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= ( n * n ) ; i ++ ) primesquare [ i ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } int j = 0 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { a [ j ] = p ; primesquare [ p * p ] = true ; j ++ ; } } } static int countDivisors ( int n ) { if ( n == 1 ) return 1 ; boolean prime [ ] = new boolean [ n + 1 ] , primesquare [ ] = new boolean [ n * n + 1 ] ; SieveOfEratosthenes ( n , prime , primesquare , a ) ; int ans = 1 ; for ( int i = 0 ; ; i ++ ) { if ( a [ i ] * a [ i ] * a [ i ] > n ) break ; int cnt = 1 ; while ( n % a [ i ] == 0 ) { n = n / a [ i ] ; } ans = ans * cnt ; } if ( prime [ n ] ) ans = ans * 2 ; else if ( primesquare [ n ] ) ans = ans * 3 ; else if ( n != 1 ) ans = ans * 4 ; } static int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } static boolean checkArithmetic ( int n ) { int count = countDivisors ( n ) ; int sum = sumofFactors ( n ) ; return ( sum % count == 0 ) ; } public static void main ( String [ ] args ) { int n = 6 ; if ( checkArithmetic ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( magicOfSequence ( N ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static List < Integer > power = new ArrayList < Integer > ( ) ; static void nextPower ( Integer N ) { Integer carry = 0 ; for ( int i = 0 ; i < power . size ( ) ; i ++ ) { Integer prod = ( power . get ( i ) * N ) + carry ; power . set ( i , prod % 10 ) ; carry = prod / 10 ; } while ( carry >= 1 ) { power . add ( carry % 10 ) ; carry = carry / 10 ; } } static void printPowerNumber ( int X , int N ) { power . add ( 1 ) ; List < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { nextPower ( N ) ; res . add ( power . get ( power . size ( ) - 1 ) ) ; res . add ( power . get ( 0 ) ) ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) ) ; } public static void main ( String args [ ] ) { Integer N = 19 , X = 4 ; printPowerNumber ( X , N ) ; } }
class GFG { static int firstDigit ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( firstDigit ( n ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; } public static void main ( String [ ] args ) { System . out . println ( sumofseries ( 3 ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static void printGMeans ( int A , int B , int N ) { float R = ( float ) Math . pow ( ( float ) ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( A * Math . pow ( R , i ) + " ▁ " ) ; } public static void main ( String args [ ] ) { int A = 3 , B = 81 , N = 2 ; printGMeans ( A , B , N ) ; } }
import java . io . * ; class GFG { static int digitSum ( long n ) { int digSum = 0 ; while ( n > 0 ) { digSum += n % 10 ; n /= 10 ; } return digSum ; } public static long countInteger ( long n , long s ) { if ( n < s ) return 0 ; for ( long i = s ; i <= Math . min ( n , s + 163 ) ; i ++ ) if ( ( i - digitSum ( i ) ) > s ) return ( n - i + 1 ) ; return 0 ; } public static void main ( String args [ ] ) { long n = 1000 , s = 100 ; System . out . println ( countInteger ( n , s ) ) ; } }
import java . io . * ; class GFG { static int division ( int num1 , int num2 ) { if ( num1 == 0 ) return 0 ; if ( num2 == 0 ) return Integer . MAX_VALUE ; boolean negResult = false ; if ( num1 < 0 ) { num1 = - num1 ; if ( num2 < 0 ) num2 = - num2 ; else negResult = true ; } else if ( num2 < 0 ) { num2 = - num2 ; negResult = true ; } int quotient = 0 ; while ( num1 >= num2 ) { num1 = num1 - num2 ; quotient ++ ; } if ( negResult ) quotient = - quotient ; return quotient ; } public static void main ( String [ ] args ) { int num1 = 13 , num2 = 2 ; System . out . println ( division ( num1 , num2 ) ) ; } }
import java . io . * ; class GFG { static void Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( i * ( 7 * i - 5 ) / 2 ) ; System . out . print ( " ▁ " ) ; } } public static void main ( String args [ ] ) { int n = 10 ; Nonagonal ( n ) ; } }
import java . io . * ; class GFG { static int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; } public static void main ( String args [ ] ) { int n = 8 ; System . out . println ( seriesFunc ( n ) ) ; n = 13 ; System . out . println ( seriesFunc ( 13 ) ) ; } }
import java . io . * ; class GFG { static boolean checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += Math . pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; } public static void main ( String [ ] args ) { int x = 9474 ; if ( checkplusperfect ( x ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int subsetCount ( int arr [ ] , int n ) { return 1 << n ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 } ; int n = A . length ; System . out . println ( subsetCount ( A , n ) ) ; } }
import java . io . * ; class GFG { static float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; } public static void main ( String [ ] args ) { float org_cost = 100 ; float N_price = 120 ; System . out . print ( " ▁ GST ▁ = ▁ " + Calculate_GST ( org_cost , N_price ) + " % " ) ; } }
import java . io . * ; class GFG { static int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . print ( n + " th ▁ centered ▁ " + " hexagonal ▁ number : ▁ " ) ; System . out . println ( centeredHexagonalNumber ( n ) ) ; } }
class demo { public static int find_distance ( int n ) { return n * ( 3 * n + 7 ) ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . print ( " Distance ▁ = ▁ " ) ; System . out . println ( find_distance ( n ) ) ; } }
import java . util . * ; class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean twinPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . abs ( n1 - n2 ) == 2 ) ; } public static void main ( String [ ] args ) { int n1 = 11 , n2 = 13 ; if ( twinPrime ( n1 , n2 ) ) System . out . println ( " Twin ▁ Prime " ) ; else System . out . println ( " Not ▁ Twin ▁ Prime " ) ; } }
import java . util . * ; class GFG { static double sumOfSeries ( int n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( sumOfSeries ( n ) ) ; } }
import java . io . * ; class GFG { static int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( evenbinomialCoeffSum ( n ) ) ; } }
import java . util . * ; class GFG { static void triangular_series ( int n ) { int i , j = 1 , k = 1 ; for ( i = 1 ; i <= n ; i ++ ) { System . out . printf ( " % d ▁ " , k ) ; j = j + 1 ; k = k + j ; } } public static void main ( String [ ] args ) { int n = 5 ; triangular_series ( n ) ; } }
import java . io . * ; class GfG { static int sumOfTheSeries ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( " Sum ▁ = ▁ " + sumOfTheSeries ( n ) ) ; } }
import java . util . * ; class GFG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( sumOfSeries ( n ) ) ; } }
import java . util . * ; import static java . lang . Math . pow ; class Triangle { public static double numberOfTriangles ( int n ) { double ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( numberOfTriangles ( n ) ) ; } }
import java . util . * ; class Digits { public static int motzkin ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = ( ( 2 * i + 1 ) * dp [ i - 1 ] + ( 3 * i - 3 ) * dp [ i - 2 ] ) / ( i + 2 ) ; return dp [ n ] ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . print ( motzkin ( n ) ) ; } }
import java . util . Arrays ; import java . util . Collections ; class GFG { public static int kthgroupsum ( int k ) { return k * k * k ; } public static void main ( String [ ] args ) { int k = 3 ; System . out . print ( kthgroupsum ( k ) ) ; } }
import java . io . * ; class Sums { static void printXYZ ( int n ) { if ( n == 1 ) System . out . println ( - 1 ) ; else { System . out . println ( " x ▁ is ▁ " + n ) ; System . out . println ( " y ▁ is ▁ " + ( n + 1 ) ) ; System . out . println ( " z ▁ is ▁ " + ( n * ( n + 1 ) ) ) ; } } public static void main ( String [ ] args ) { int n = 7 ; printXYZ ( n ) ; } }
import java . io . * ; class Series { static int term ( int n ) { return n * ( n + 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( term ( n ) ) ; } }
import java . io . * ; class GeeksforGeeks { static double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; } public static void main ( String args [ ] ) { int a = 5 , b = 15 ; double HM = compute ( a , b ) ; String str = " " ; str = str + HM ; System . out . print ( " Harmonic ▁ Mean ▁ between ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + str . substring ( 0 , 5 ) ) ; } }
import java . io . * ; class GFG { static int series ( int n ) { return ( 8 * n * n ) + 1 ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( series ( n ) ) ; } }
class Divisible { public static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } static boolean isDivisible ( int x , int y ) { if ( y == 1 ) return true ; int z = gcd ( x , y ) ; if ( z == 1 ) return false ; return isDivisible ( x , y / z ) ; } public static void main ( String [ ] args ) { int x = 18 , y = 12 ; if ( isDivisible ( x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { public static void main ( String [ ] args ) { double n = 5 , a = 2 ; System . out . println ( sumOfSeries ( a , n ) ) ; } static double sumOfSeries ( double a , double n ) { double res = 0 , prev = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { prev *= ( a / i ) ; res = res + prev ; } return ( res ) ; } }
class GFG { static float Cel_To_Fah ( float n ) { return ( ( n * 9.0f / 5.0f ) + 32.0f ) ; } public static void main ( String [ ] args ) { float n = 20.0f ; System . out . println ( Cel_To_Fah ( n ) ) ; } }
import java . io . * ; class GFG { static void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { System . out . println ( " - 1" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) System . out . print ( r * i + " ▁ " ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( res ) ; } } public static void main ( String [ ] args ) { int n = 24 ; int k = 4 ; print_sequence ( n , k ) ; n = 24 ; k = 5 ; print_sequence ( n , k ) ; n = 6 ; k = 4 ; print_sequence ( n , k ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static int countCompositions ( int n ) { return 1 << ( n - 1 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . print ( countCompositions ( n ) ) ; } }
import java . util . * ; class GFG { static int countDigit ( long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; } public static void main ( String [ ] args ) { long n = 345289467 ; System . out . print ( " Number ▁ of ▁ digits ▁ : ▁ " + countDigit ( n ) ) ; } }
import java . io . * ; class GFG { static void printTrib ( int n ) { int dp [ ] = new int [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int n = 10 ; printTrib ( n ) ; } }
import java . io . * ; class GFG { static void multiply ( int T [ ] [ ] , int M [ ] [ ] ) { int a , b , c , d , e , f , g , h , i ; a = T [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 0 ] ; b = T [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 1 ] ; c = T [ 0 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 2 ] ; d = T [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 0 ] ; e = T [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 1 ] ; f = T [ 1 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 2 ] ; g = T [ 2 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 0 ] ; h = T [ 2 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 1 ] ; i = T [ 2 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 2 ] ; T [ 0 ] [ 0 ] = a ; T [ 0 ] [ 1 ] = b ; T [ 0 ] [ 2 ] = c ; T [ 1 ] [ 0 ] = d ; T [ 1 ] [ 1 ] = e ; T [ 1 ] [ 2 ] = f ; T [ 2 ] [ 0 ] = g ; T [ 2 ] [ 1 ] = h ; T [ 2 ] [ 2 ] = i ; } static void power ( int T [ ] [ ] , int n ) { if ( n == 0 n == 1 ) return ; int M [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; power ( T , n / 2 ) ; multiply ( T , T ) ; if ( n % 2 != 0 ) multiply ( T , M ) ; } static int tribonacci ( int n ) { int T [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 0 n == 1 ) return 0 ; else power ( T , n - 2 ) ; return T [ 0 ] [ 0 ] ; } public static void main ( String args [ ] ) { int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( tribonacci ( i ) + " ▁ " ) ; System . out . println ( ) ; } }
import java . io . * ; class GFG { static float geometricMean ( int [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) Math . log ( arr [ i ] ) ; sum = sum / n ; return ( float ) Math . exp ( sum ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = arr . length ; System . out . println ( geometricMean ( arr , n ) ) ; } }
import java . util . Stack ; public class GFG { static long smallestNumber ( int n ) { if ( n >= 0 && n <= 9 ) { return n ; } Stack < Integer > digits = new Stack < > ( ) ; for ( int i = 9 ; i >= 2 && n > 1 ; i -- ) { while ( n % i == 0 ) { digits . push ( i ) ; n = n / i ; } } if ( n != 1 ) { return - 1 ; } long k = 0 ; while ( ! digits . empty ( ) ) { k = k * 10 + digits . peek ( ) ; digits . pop ( ) ; } return k ; } static public void main ( String [ ] args ) { int n = 100 ; System . out . println ( smallestNumber ( n ) ) ; } }
class GFG { public static boolean isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; } public static void main ( String args [ ] ) { int n = 1234 ; if ( isMagic ( n ) ) System . out . println ( " Magic ▁ Number " ) ; else System . out . println ( " Not ▁ a ▁ magic ▁ Number " ) ; } }
import java . util . * ; class GFG { public static void printSequence ( int n ) { int a = 1 ; int ans = 2 ; int N = 1000000007 ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( ans + " ▁ " ) ; ans = ( ( a % N ) * ( ans % N ) ) % N ; a = ans ; ans = ( ans + 1 ) % N ; } } public static void main ( String [ ] args ) { int n = 6 ; printSequence ( n ) ; } }
import java . io . * ; class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( findSum ( n ) ) ; } }
import java . util . * ; class GFG { static int c ; static int HailstoneNumbers ( int N ) { System . out . print ( N + " ▁ " ) ; if ( N == 1 && c == 0 ) { return c ; } else if ( N == 1 && c != 0 ) { c ++ ; return c ; } else if ( N % 2 == 0 ) { c ++ ; HailstoneNumbers ( N / 2 ) ; } else if ( N % 2 != 0 ) { c ++ ; HailstoneNumbers ( 3 * N + 1 ) ; } return c ; } public static void main ( String [ ] args ) { int N = 7 ; int x ; x = HailstoneNumbers ( N ) ; System . out . println ( ) ; System . out . println ( " Number ▁ of ▁ Steps : ▁ " + x ) ; } }
class GFG { static int SUM ( int n , int m ) { if ( m == 1 ) return ( n * ( n + 1 ) / 2 ) ; int sum = SUM ( n , m - 1 ) ; return ( sum * ( sum + 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; int m = 3 ; System . out . println ( " SUM ( " + n + " , ▁ " + m + " ) : ▁ " + SUM ( n , m ) ) ; } }
class GFG { static int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return 1 ; } public static void main ( String [ ] args ) { int k = 31 ; System . out . println ( xorCalc ( k ) ) ; } }
public class GFG { static String findNthNo ( int n ) { String res = " " ; while ( n >= 1 ) { if ( ( n & 1 ) == 1 ) { res = res + "4" ; n = ( n - 1 ) / 2 ; } else { res = res + "7" ; n = ( n - 2 ) / 2 ; } } StringBuilder sb = new StringBuilder ( res ) ; sb . reverse ( ) ; return new String ( sb ) ; } public static void main ( String args [ ] ) { int n = 13 ; System . out . print ( findNthNo ( n ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static int divCount ( int n ) { boolean hash [ ] = new boolean [ n + 1 ] ; Arrays . fill ( hash , true ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; } public static void main ( String [ ] args ) { int n = 24 ; System . out . print ( divCount ( n ) ) ; } }
class GFG { static int getMax ( int [ ] Arr ) { int max = Arr [ 0 ] ; for ( int i = 1 ; i < Arr . length ; i ++ ) if ( Arr [ i ] > max ) max = Arr [ i ] ; return max ; } static int maxPrimefactorNum ( int N ) { int [ ] arr = new int [ N + 1 ] ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } return getMax ( arr ) ; } public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }
import java . io . * ; class GFG { static String decToBin ( int n ) { if ( n == 0 ) return "0" ; String bin = " " ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; } public static void main ( String [ ] args ) { int n = 38 ; System . out . println ( decToBin ( n ) ) ; } }
class GFG { public static int arraySum ( int arr [ ] , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 11 , 12 , 13 , 12 , 11 , 10 } ; int n = arr . length ; System . out . print ( arraySum ( arr , n ) ) ; } }
import java . util . * ; class GFG { static boolean isBalancePossible ( int T , int a ) { Vector < Integer > baseForm = new Vector < > ( ) ; int s = 0 ; while ( T > 0 ) { baseForm . add ( T % a ) ; T /= a ; s ++ ; } baseForm . add ( 0 ) ; for ( int i = 0 ; i < s ; i ++ ) { if ( baseForm . get ( i ) != 0 && baseForm . get ( i ) != 1 && baseForm . get ( i ) != ( a - 1 ) && baseForm . get ( i ) != a ) { return false ; } if ( baseForm . get ( i ) == a || baseForm . get ( i ) == ( a - 1 ) ) { baseForm . add ( i + 1 , baseForm . get ( i + 1 ) + 1 ) ; } } return true ; } public static void main ( String [ ] args ) { int T = 11 ; int a = 4 ; boolean balancePossible = isBalancePossible ( T , a ) ; if ( balancePossible ) { System . out . println ( " Balance ▁ is ▁ possible " ) ; } else { System . out . println ( " Balance ▁ is ▁ not ▁ possible " ) ; } } }
class GFG { public static int countDigits ( int a , int b ) { if ( a == 0 b == 0 ) return 1 ; return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; } public static void main ( String [ ] args ) { int a = 33 ; int b = - 24 ; System . out . print ( countDigits ( a , b ) ) ; } }
class GFG { static int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; } public static void main ( String arg [ ] ) { int n = 5 ; int m = 8 ; int k = 2 ; System . out . print ( lastPosition ( n , m , k ) ) ; } }
class GFG { static void primesInRange ( int n ) { int fact = 1 ; for ( int k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) System . out . println ( k ) ; } } public static void main ( String [ ] args ) { int n = 15 ; primesInRange ( n ) ; } }
public class Array_puzzle_2 { static final double EPS = 1e-9 ; static void productPuzzle ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ( int ) ( EPS + Math . pow ( 10.00 , sum - Math . log10 ( a [ i ] ) ) ) + " ▁ " ) ; } public static void main ( String args [ ] ) { int a [ ] = { 10 , 3 , 5 , 6 , 2 } ; int n = a . length ; System . out . println ( " The ▁ product ▁ array ▁ is : ▁ " ) ; productPuzzle ( a , n ) ; } }
import java . util . * ; class GFG { static int changeEvenBits ( int n ) { int to_subtract = 0 ; int m = 0 ; for ( int x = n ; x > 0 ; x >>= 2 ) { if ( ( x & 1 ) > 0 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; } public static void main ( String [ ] args ) { int n = 30 ; System . out . println ( changeEvenBits ( n ) ) ; } }
public class close_to_n_divisible_m { static int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; } public static void main ( String args [ ] ) { int n = 13 , m = 4 ; System . out . println ( closestNumber ( n , m ) ) ; n = - 15 ; m = 6 ; System . out . println ( closestNumber ( n , m ) ) ; n = 0 ; m = 8 ; System . out . println ( closestNumber ( n , m ) ) ; n = 18 ; m = - 7 ; System . out . println ( closestNumber ( n , m ) ) ; } }
import java . io . * ; import java . util . * ; import java . math . * ; class GFG { static boolean checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( Math . sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i <= 200 ; i ++ ) if ( checkPronic ( i ) ) System . out . print ( i + " ▁ " ) ; } }
public class Main { static int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; } public static void main ( String [ ] args ) { int num = 12 ; System . out . println ( findMinSum ( num ) ) ; } }
import java . io . * ; class GFG { static void findMin ( int sum ) { int a = 0 , b = 0 ; while ( sum > 0 ) { if ( sum % 7 == 0 ) { b ++ ; sum -= 7 ; } else if ( sum % 4 == 0 ) { a ++ ; sum -= 4 ; } else { a ++ ; sum -= 4 ; } } if ( sum < 0 ) { System . out . print ( " - 1n " ) ; return ; } for ( int i = 0 ; i < a ; i ++ ) System . out . print ( "4" ) ; for ( int i = 0 ; i < b ; i ++ ) System . out . print ( "7" ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) throws IOException { findMin ( 15 ) ; } }
class GFG { static int minNum ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . length ; System . out . println ( minNum ( arr , n ) ) ; } }
public class GFG { static int printMaxNum ( int num ) { int count [ ] = new int [ 10 ] ; String str = Integer . toString ( num ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) - '0' ] ++ ; int result = 0 , multiplier = 1 ; for ( int i = 0 ; i <= 9 ; i ++ ) { while ( count [ i ] > 0 ) { result = result + ( i * multiplier ) ; count [ i ] -- ; multiplier = multiplier * 10 ; } } return result ; } public static void main ( String [ ] args ) { int num = 38293367 ; System . out . println ( printMaxNum ( num ) ) ; } }
public class GFG { static String largestNumber ( String num ) { int n = num . length ( ) ; int right ; int rightMax [ ] = new int [ n ] ; rightMax [ n - 1 ] = - 1 ; right = n - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) < num . charAt ( right ) ) rightMax [ i ] = right ; else { rightMax [ i ] = - 1 ; right = i ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( rightMax [ i ] != - 1 ) { num = swap ( num , i , rightMax [ i ] ) ; break ; } } return num ; } static String swap ( String num , int i , int j ) { StringBuilder sb = new StringBuilder ( num ) ; sb . setCharAt ( i , num . charAt ( j ) ) ; sb . setCharAt ( j , num . charAt ( i ) ) ; return sb . toString ( ) ; } public static void main ( String [ ] args ) { String num = "8725634" ; System . out . println ( " Largest ▁ Number ▁ : ▁ " + largestNumber ( num ) ) ; } }
import java . util . * ; class GFG { static int nCr ( int n , int r ) { if ( r > n / 2 ) r = n - r ; int answer = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ) ; answer /= i ; } return answer ; } static float binomialProbability ( int n , int k , float p ) { return nCr ( n , k ) * ( float ) Math . pow ( p , k ) * ( float ) Math . pow ( 1 - p , n - k ) ; } public static void main ( String [ ] args ) { int n = 10 ; int k = 5 ; float p = ( float ) 1.0 / 3 ; float probability = binomialProbability ( n , k , p ) ; System . out . print ( " Probability ▁ of ▁ " + k ) ; System . out . print ( " ▁ heads ▁ when ▁ a ▁ coin ▁ is ▁ tossed ▁ " + n ) ; System . out . println ( " ▁ times ▁ where ▁ probability ▁ of ▁ each ▁ head ▁ is ▁ " + p ) ; System . out . println ( " ▁ is ▁ = ▁ " + probability ) ; } }
class GFG { public static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int divisors [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; return 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 8 , 12 } ; int n = arr . length ; System . out . println ( findMaxGCD ( arr , n ) ) ; } }
class GFG { public static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int count [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 8 , 12 } ; int n = arr . length ; System . out . println ( findMaxGCD ( arr , n ) ) ; } }
class GFG { static int count_one ( int n ) { int c_one = 0 ; while ( n != 0 ) { int rem = n % 10 ; if ( rem == 1 ) c_one = c_one + 1 ; n = n / 10 ; } return c_one ; } static int checkEvil ( int n ) { int i = 0 , bin = 0 , n_one = 0 ; while ( n != 0 ) { int r = n % 2 ; bin = bin + r * ( int ) ( Math . pow ( 10 , i ) ) ; n = n / 2 ; } n_one = count_one ( bin ) ; if ( n_one % 2 == 0 ) return 1 ; else return 0 ; } public static void main ( String [ ] args ) { int i , check , num ; num = 32 ; check = checkEvil ( num ) ; if ( check == 1 ) System . out . println ( num + " ▁ is ▁ Evil ▁ Number " ) ; else System . out . println ( num + " ▁ is ▁ Odious ▁ Number " ) ; } }
class GFG { static int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; } public static void main ( String [ ] args ) { System . out . println ( CountPairs ( 1 ) ) ; System . out . println ( CountPairs ( 2 ) ) ; System . out . println ( CountPairs ( 3 ) ) ; } }
class GFG { static long powermod ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1L ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long modInverse ( long a , long m ) { long m0 = m , t , q ; long x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } static long evaluteExpression ( long n ) { long firstsum = 0 , mod = 10 ; for ( long i = 2 , j = 0 ; ( 1L << j ) <= n ; i *= i , ++ j ) firstsum = ( firstsum + i ) % mod ; long secondsum = ( powermod ( 4L , n + 1 , mod ) - 1 ) * modInverse ( 3L , mod ) ; return ( firstsum * secondsum ) % mod ; } public static void main ( String [ ] args ) { long n = 3 ; System . out . println ( evaluteExpression ( n ) ) ; n = 10 ; System . out . println ( evaluteExpression ( n ) ) ; } }
public class GFG { static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; } public static void main ( String [ ] args ) { System . out . println ( PowerOFPINnfactorial ( 4 , 2 ) ) ; } }
class GFG { static int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; } public static void main ( String [ ] args ) { int num = 10101001 ; System . out . println ( binaryToDecimal ( num ) ) ; } }
class GFG { public static int stirlingFactorial ( double n ) { if ( n == 1 ) return 1 ; double z ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return ( int ) ( z ) ; } public static void main ( String [ ] args ) { System . out . println ( stirlingFactorial ( 1 ) ) ; System . out . println ( stirlingFactorial ( 2 ) ) ; System . out . println ( stirlingFactorial ( 3 ) ) ; System . out . println ( stirlingFactorial ( 4 ) ) ; System . out . println ( stirlingFactorial ( 5 ) ) ; System . out . println ( stirlingFactorial ( 6 ) ) ; System . out . println ( stirlingFactorial ( 7 ) ) ; } }
public class CountXor { static int countXorPair ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; System . out . println ( countXorPair ( arr , arr . length ) ) ; } }
import java . io . * ; public class LychrelNumberTest { private static int MAX_ITERATIONS = 20 ; private static boolean isLychrel ( long number ) { for ( int i = 0 ; i < MAX_ITERATIONS ; i ++ ) { number = number + reverse ( number ) ; if ( isPalindrome ( number ) ) return false ; } return true ; } private static boolean isPalindrome ( final long number ) { return number == reverse ( number ) ; } private static long reverse ( long number ) { long reverse = 0 ; while ( number > 0 ) { long remainder = number % 10 ; reverse = ( reverse * 10 ) + remainder ; number = number / 10 ; } return reverse ; } public static void main ( String [ ] args ) { long number = 295 ; System . out . println ( number + " ▁ is ▁ lychrel ? ▁ " + isLychrel ( number ) ) ; } }
import java . io . * ; class GFG { static int findRectNum ( int n ) { return n * ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( findRectNum ( n ) ) ; } }
import java . io . * ; import static java . lang . Math . * ; class Muller { static final int MAX_ITERATIONS = 10000 ; static double f ( double x ) { return 1 * pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ; } static void Muller ( double a , double b , double c ) { int i ; double res ; for ( i = 0 ; ; ++ i ) { double f1 = f ( a ) ; double f2 = f ( b ) ; double f3 = f ( c ) ; double d1 = f1 - f3 ; double d2 = f2 - f3 ; double h1 = a - c ; double h2 = b - c ; double a0 = f3 ; double a1 = ( ( ( d2 * pow ( h1 , 2 ) ) - ( d1 * pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; double a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; double x = ( ( - 2 * a0 ) / ( a1 + abs ( sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; double y = ( ( - 2 * a0 ) / ( a1 - abs ( sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; if ( x >= y ) res = x + c ; else res = y + c ; double m = res * 100 ; double n = c * 100 ; m = floor ( m ) ; n = floor ( n ) ; if ( m == n ) break ; a = b ; b = c ; c = res ; if ( i > MAX_ITERATIONS ) { System . out . println ( " Root ▁ cannot ▁ be ▁ found ▁ using " + " ▁ Muller ' s ▁ method " ) ; break ; } } if ( i <= MAX_ITERATIONS ) System . out . println ( " The ▁ value ▁ of ▁ the ▁ root ▁ is ▁ " + res ) ; } public static void main ( String args [ ] ) { double a = 0 , b = 1 , c = 2 ; Muller ( a , b , c ) ; } }
import java . util . * ; class GFG { static int MAX = 100001 ; static ArrayList < Integer > p = new ArrayList < Integer > ( ) ; static void sieve ( ) { int [ ] isPrime = new int [ MAX + 1 ] ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( isPrime [ i ] == 0 ) { p . add ( i ) ; for ( int j = 2 ; i * j <= MAX ; j ++ ) isPrime [ i * j ] = 1 ; } } } static int phi ( int n ) { int res = n ; for ( int i = 0 ; p . get ( i ) * p . get ( i ) <= n ; i ++ ) { if ( n % p . get ( i ) == 0 ) { res -= ( res / p . get ( i ) ) ; while ( n % p . get ( i ) == 0 ) n /= p . get ( i ) ; } } if ( n > 1 ) res -= ( res / n ) ; return res ; } public static void main ( String [ ] args ) { sieve ( ) ; System . out . println ( phi ( 11 ) ) ; System . out . println ( phi ( 21 ) ) ; System . out . println ( phi ( 31 ) ) ; System . out . println ( phi ( 41 ) ) ; System . out . println ( phi ( 51 ) ) ; System . out . println ( phi ( 61 ) ) ; System . out . println ( phi ( 91 ) ) ; System . out . println ( phi ( 101 ) ) ; } }
import static java . lang . Math . pow ; class Test { static void nthprimedigitsnumber ( long n ) { long len = 1 ; long prev_count = 0 ; while ( true ) { long curr_count = ( long ) ( prev_count + pow ( 4 , len ) ) ; if ( prev_count < n && curr_count >= n ) break ; len ++ ; prev_count = curr_count ; } for ( int i = 1 ; i <= len ; i ++ ) { for ( long j = 1 ; j <= 4 ; j ++ ) { if ( prev_count + pow ( 4 , len - i ) < n ) prev_count += pow ( 4 , len - i ) ; else { if ( j == 1 ) System . out . print ( "2" ) ; else if ( j == 2 ) System . out . print ( "3" ) ; else if ( j == 3 ) System . out . print ( "5" ) ; else if ( j == 4 ) System . out . print ( "7" ) ; break ; } } } System . out . println ( ) ; } public static void main ( String args [ ] ) { nthprimedigitsnumber ( 10 ) ; nthprimedigitsnumber ( 21 ) ; } }
class Gfg { static int cassini ( int n ) { return ( n & 1 ) != 0 ? - 1 : 1 ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( cassini ( n ) ) ; } }
class GFG { static boolean findNoIsDivisibleOrNot ( int a [ ] , int n ) { for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; } public static void main ( String [ ] args ) { int a [ ] = { 14 , 12 , 4 , 18 } ; int n = 2 ; if ( findNoIsDivisibleOrNot ( a , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class Test { static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } static void printRange ( int n ) { int a = factorial ( n + 2 ) + 2 ; int b = a + n - 1 ; System . out . println ( " [ " + a + " , ▁ " + b + " ] " ) ; } public static void main ( String args [ ] ) throws Exception { int n = 3 ; printRange ( n ) ; } }
import java . util . Arrays ; class GFG1 { static long findMinValue ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { val += ( double ) ( Math . log ( ( double ) ( arr [ i ] ) ) ) ; } long left = arr [ 0 ] , right = arr [ n - 1 ] ; long ans = 0 ; while ( left <= right ) { long mid = ( left + right ) / 2 ; double temp = ( double ) n * ( double ) ( Math . log ( ( double ) ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else { left = mid + 1 ; } } return ans ; } public static void main ( String [ ] args ) { long arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = arr . length ; System . out . println ( findMinValue ( arr , n ) ) ; } }
import static java . lang . Math . pow ; class Test { static int sumOfTermsInNthRow ( int n ) { int sum = ( int ) ( n * ( 2 * pow ( n , 2 ) + 1 ) ) ; return sum ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( " Sum ▁ of ▁ all ▁ the ▁ terms ▁ in ▁ nth ▁ row ▁ = ▁ " + sumOfTermsInNthRow ( n ) ) ; } }
class Test { static int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; } public static void main ( String args [ ] ) { System . out . println ( firstDigit ( 12345 ) ) ; System . out . println ( firstDigit ( 5432 ) ) ; } }
import java . * ; public class GFG { static int getOccurence ( int n , int d ) { int result = 0 ; int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; } public static void main ( String [ ] args ) { int n = 11 , d = 1 ; System . out . println ( getOccurence ( n , d ) ) ; } }
import static java . lang . Math . cos ; class GFG { static void cal_cos ( float n ) { float accuracy = ( float ) 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( float ) ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= cosval - cosx ) ; System . out . println ( cosx ) ; } public static void main ( String [ ] args ) { float n = 30 ; cal_cos ( n ) ; } }
import java . util . * ; class GFG { static ArrayList < Integer > v = new ArrayList < Integer > ( ) ; static void multiply ( int x ) { int carry = 0 ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { int res = carry + v . get ( i ) * x ; v . set ( i , res % 10 ) ; carry = res / 10 ; } while ( carry != 0 ) { v . add ( carry % 10 ) ; carry /= 10 ; } } static int findSumOfDigits ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) multiply ( i ) ; int sum = 0 ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) sum += v . get ( i ) ; return sum ; } public static void main ( String [ ] args ) { int n = 1000 ; System . out . println ( findSumOfDigits ( n ) ) ; } }
class GFG { static void printOtherSides ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) System . out . println ( " - 1" ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } else { if ( n == 2 ) System . out . println ( " - 1" ) ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } } public static void main ( String [ ] args ) { int a = 3 ; printOtherSides ( a ) ; } }
import java . io . * ; class GFG { static int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; } public static void main ( String [ ] args ) { int n = 36 ; int res = makeOdd ( n ) ; System . out . println ( res ) ; } }
import java . io . * ; class GFG { static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . length ; System . out . println ( getTotalXorOfSubarrayXors ( arr , N ) ) ; } }
class Test { static int countIterations ( int arr [ ] , int n ) { boolean oneFound = false ; int res = 0 ; for ( int i = 0 ; i < n ; ) { if ( arr [ i ] == 1 ) oneFound = true ; while ( i < n && arr [ i ] == 1 ) i ++ ; int count_zero = 0 ; while ( i < n && arr [ i ] == 0 ) { count_zero ++ ; i ++ ; } if ( oneFound == false && i == n ) return - 1 ; int curr_count ; if ( i < n && oneFound == true ) { if ( ( count_zero & 1 ) == 0 ) curr_count = count_zero / 2 ; else curr_count = ( count_zero + 1 ) / 2 ; count_zero = 0 ; } else { curr_count = count_zero ; count_zero = 0 ; } res = Math . max ( res , curr_count ) ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; System . out . println ( countIterations ( arr , arr . length ) ) ; } }
import java . util . * ; class GFG { static void printConsecutive ( int last , int first ) { System . out . print ( first ++ ) ; for ( int x = first ; x <= last ; x ++ ) System . out . print ( " ▁ + ▁ " + x ) ; } static void findConsecutive ( int N ) { for ( int last = 1 ; last < N ; last ++ ) { for ( int first = 0 ; first < last ; first ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { System . out . print ( N + " ▁ = ▁ " ) ; printConsecutive ( last , first + 1 ) ; return ; } } } System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int n = 12 ; findConsecutive ( n ) ; } }
class FindNth { static int printNthElement ( int n ) { int arr [ ] = new int [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( printNthElement ( n ) ) ; } }
class MaxSum { static int maxSumLCM ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( maxSumLCM ( n ) ) ; } }
import java . io . * ; class GFG { public static void main ( String [ ] args ) { double n = 12 ; System . out . println ( Math . sqrt ( n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static int findMaxValue ( ) { int res = 2 ; long fact = 2 ; while ( true ) { if ( fact < 0 ) break ; res ++ ; fact = fact * res ; } return res - 1 ; } public static void main ( String [ ] args ) { System . out . println ( " Maximum ▁ value ▁ of " + " ▁ integer ▁ " + findMaxValue ( ) ) ; } }
import java . lang . * ; import java . util . * ; class GFG { static boolean func ( int a [ ] , int k ) { for ( int i = 0 ; i < a . length ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; } public static void main ( String args [ ] ) { int [ ] a = { 14 , 27 , 38 , 76 , 84 } ; int k = 19 ; boolean res = func ( a , k ) ; System . out . println ( res ) ; } }
import java . io . * ; class GFG { static String tidyNum ( String str1 , int len ) { char [ ] str = str1 . toCharArray ( ) ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( int j = i + 1 ; j < len ; j ++ ) str [ j ] = '9' ; } } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { String str = "11333445538" ; int len = str . length ( ) ; System . out . println ( tidyNum ( str , len ) ) ; } }
class Main { static int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; } public static void main ( String [ ] args ) { int m = 2 , n = 6 ; System . out . println ( findCount ( m , n ) ) ; } }
class GFG { static int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; boolean isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } } public static void main ( String [ ] args ) { System . out . println ( findNthEvenDigitNumber ( 2 ) ) ; System . out . println ( findNthEvenDigitNumber ( 10 ) ) ; } }
import java . util . * ; class GFG { static int findNthEvenDigitNumber ( int n ) { if ( n == 1 ) { return 0 ; } Vector < Integer > v = new Vector < > ( ) ; n = n - 1 ; while ( n > 0 ) { v . add ( n % 5 ) ; n = n / 5 ; } int result = 0 ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + v . get ( i ) ; } return 2 * result ; } public static void main ( String [ ] args ) { System . out . println ( findNthEvenDigitNumber ( 2 ) ) ; System . out . println ( findNthEvenDigitNumber ( 10 ) ) ; } }
class IsDivisible { static boolean isDivisibleBy25 ( String str ) { int n = str . length ( ) ; if ( n == 1 ) return false ; return ( ( str . charAt ( n - 1 ) - '0' == 0 && str . charAt ( n - 2 ) - '0' == 0 ) || ( ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 25 == 0 ) ; } public static void main ( String [ ] args ) { String str = "76955" ; if ( isDivisibleBy25 ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str . charAt ( n - 3 ) - '0' ) * 100 + ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 16 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; int third_last = str . charAt ( n - 3 ) - '0' ; int fourth_last = str . charAt ( n - 4 ) - '0' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; } public static void main ( String args [ ] ) { String str = "769528" ; if ( check ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No ▁ " ) ; } }
import java . io . * ; class GFG { static int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; } public static void main ( String [ ] args ) { int result = findIndex ( 21 ) ; System . out . println ( result ) ; } }
import java . io . * ; class GFG { static int divisorSum ( int N , int K ) { int sum = 0 ; for ( int i = 2 ; i <= Math . ceil ( Math . sqrt ( N ) ) ; i ++ ) if ( N % i == 0 ) sum += ( i + N / i ) ; return sum ; } static boolean isPrime ( int n ) { if ( n == 1 n == 0 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean isHyperPerfect ( int N , int K ) { int sum = divisorSum ( N , K ) ; if ( ( 1 + K * ( sum ) ) == N ) return true ; else return false ; } public static void main ( String [ ] args ) { int N1 = 1570153 , K1 = 12 ; int N2 = 321 , K2 = 3 ; if ( isHyperPerfect ( N1 , K1 ) ) System . out . println ( N1 + " ▁ is ▁ " + K1 + " - HyperPerfect " ) ; else System . out . println ( N1 + " ▁ is ▁ not ▁ " + K1 + " - HyperPerfect " ) ; if ( isHyperPerfect ( N2 , K2 ) ) System . out . println ( N2 + " ▁ is ▁ " + K2 + " - HyperPerfect " ) ; else System . out . println ( N2 + " ▁ is ▁ not ▁ " + K2 + " - HyperPerfect " ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class KDigitSquare { public static long firstkdigits ( int n , int k ) { double product = n * Math . log10 ( n ) ; double decimal_part = product - Math . floor ( product ) ; decimal_part = Math . pow ( 10 , decimal_part ) ; double digits = Math . pow ( 10 , k - 1 ) , i = 0 ; return ( ( long ) ( decimal_part * digits ) ) ; } public static void main ( String [ ] args ) { int n = 1450 ; int k = 6 ; System . out . println ( firstkdigits ( n , k ) ) ; } }
class Generate { static void printWellOrdered ( int number , int x , int k ) { if ( k == 0 ) { System . out . print ( number + " ▁ " ) ; return ; } for ( int i = ( x + 1 ) ; i < 10 ; i ++ ) printWellOrdered ( number * 10 + i , i , k - 1 ) ; } static void generateWellOrdered ( int k ) { printWellOrdered ( 0 , 0 , k ) ; } public static void main ( String [ ] args ) { int k = 3 ; generateWellOrdered ( k ) ; } }
class GFG { static long moduloMultiplication ( long a , long b , long mod ) { long res = 0 ; a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; } public static void main ( String [ ] args ) { long a = 10123465234878998L ; long b = 65746311545646431L ; long m = 10005412336548794L ; System . out . print ( moduloMultiplication ( a , b , m ) ) ; } }
class GFG { static int count2sinRangeAtDigit ( int number , int d ) { int powerOf10 = ( int ) Math . pow ( 10 , d ) ; int nextPowerOf10 = powerOf10 * 10 ; int right = number % powerOf10 ; int roundDown = number - number % nextPowerOf10 ; int roundup = roundDown + nextPowerOf10 ; int digit = ( number / powerOf10 ) % 10 ; if ( digit < 2 ) { return roundDown / 10 ; } if ( digit == 2 ) { return roundDown / 10 + right + 1 ; } return roundup / 10 ; } static int numberOf2sinRange ( int number ) { String convert ; convert = String . valueOf ( number ) ; String s = convert ; int len = s . length ( ) ; int count = 0 ; for ( int digit = 0 ; digit < len ; digit ++ ) { count += count2sinRangeAtDigit ( number , digit ) ; } return count ; } public static void main ( String [ ] args ) { System . out . println ( numberOf2sinRange ( 22 ) ) ; System . out . println ( numberOf2sinRange ( 100 ) ) ; } }
import java . io . * ; class GFG { static int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . println ( findStarNum ( n ) ) ; } }
class IsDivisible { static boolean isDivisibleBy5 ( String str ) { int n = str . length ( ) ; return ( ( ( str . charAt ( n - 1 ) - '0' ) == 0 ) || ( ( str . charAt ( n - 1 ) - '0' ) == 5 ) ) ; } public static void main ( String [ ] args ) { String str = "76955" ; if ( isDivisibleBy5 ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class Test { static boolean isTidy ( int num ) { int prev = 10 ; while ( num != 0 ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; } public static void main ( String [ ] args ) { int num = 1556 ; System . out . println ( isTidy ( num ) ? " Yes " : " No " ) ; } }
import java . io . * ; class GFG { public static int squareFree ( int n ) { int cnt = 0 ; for ( int i = 1 ; ; i ++ ) { boolean isSqFree = true ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % ( j * j ) == 0 ) { isSqFree = false ; break ; } } if ( isSqFree == true ) { cnt ++ ; if ( cnt == n ) return i ; } } } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( " " + squareFree ( n ) ) ; } }
import java . util . * ; class GFG { static void kFactors ( int n , int k ) { ArrayList < Integer > P = new ArrayList < Integer > ( ) ; while ( n % 2 == 0 ) { P . add ( 2 ) ; n /= 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; P . add ( i ) ; } } if ( n > 2 ) P . add ( n ) ; if ( P . size ( ) < k ) { System . out . println ( " - 1" ) ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) System . out . print ( P . get ( i ) + " , ▁ " ) ; int product = 1 ; for ( int i = k - 1 ; i < P . size ( ) ; i ++ ) product = product * P . get ( i ) ; System . out . println ( product ) ; } public static void main ( String [ ] args ) { int n = 54 , k = 3 ; kFactors ( n , k ) ; } }
import java . io . * ; class GFG { static int nondecdigits ( int n ) { int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; boolean flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; } public static void main ( String [ ] args ) { int n = 200 ; System . out . println ( nondecdigits ( n ) ) ; } }
import java . util . * ; class GFG { static void nondecdigits ( String s ) { int m = s . length ( ) ; int [ ] a = new int [ m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = ( int ) s . charAt ( i ) - ( int ) '0' ; int level = m - 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( a [ i ] < a [ i - 1 ] ) { a [ i - 1 ] -- ; level = i - 1 ; } } if ( a [ 0 ] != 0 ) { for ( int i = 0 ; i <= level ; i ++ ) System . out . print ( a [ i ] ) ; for ( int i = level + 1 ; i < m ; i ++ ) System . out . print ( "9" ) ; } else { for ( int i = 1 ; i < level ; i ++ ) System . out . print ( a [ i ] ) ; for ( int i = level + 1 ; i < m ; i ++ ) System . out . print ( "9" ) ; } } public static void main ( String [ ] args ) { String n = "200" ; nondecdigits ( n ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; } public static void main ( String args [ ] ) { System . out . println ( " Total ▁ distinct ▁ " + " divisors ▁ of ▁ 100 ▁ are ▁ : ▁ " + countDivisors ( 100 ) ) ; } }
import java . io . * ; class GFG { static boolean hasEvenNumberOfFactors ( int n ) { double root_n = Math . sqrt ( n ) ; if ( ( root_n * root_n ) == n ) return false ; return true ; } static void printStatusOfDoors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( hasEvenNumberOfFactors ( i ) ) System . out . print ( " closed " + " ▁ " ) ; else System . out . print ( " open " + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 5 ; printStatusOfDoors ( n ) ; } }
import java . io . * ; public class GFG { static boolean validate ( long n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long temp = n ; int count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; } static public void main ( String [ ] args ) { long n = 1552793 ; if ( validate ( n ) ) System . out . println ( " True " ) ; else System . out . println ( " False " ) ; } }
class IsDivisible { static boolean divisibleBy36 ( String num ) { int l = num . length ( ) ; if ( l == 0 ) return false ; if ( l == 1 && num . charAt ( 0 ) != '0' ) return false ; int two_digit_num = ( num . charAt ( l - 2 ) - '0' ) * 10 + ( num . charAt ( l - 1 ) - '0' ) ; if ( two_digit_num % 4 != 0 ) return false ; int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) sum += ( num . charAt ( i ) - '0' ) ; if ( sum % 9 != 0 ) return false ; return true ; } public static void main ( String [ ] args ) { String num = "92567812197966231384" ; if ( divisibleBy36 ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class IsDivisible { static boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 8 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; int third_last = str . charAt ( n - 3 ) - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; } public static void main ( String [ ] args ) { String str = "76952" ; if ( check ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n / 10 ; } return count ; } static int checkPrime ( int n ) { if ( n <= 1 ) return - 1 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return - 1 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return - 1 ; return 0 ; } static void printPrimePoints ( int n ) { int count = countDigits ( n ) ; if ( count == 1 count == 2 ) { System . out . print ( " - 1" ) ; return ; } boolean found = false ; for ( int i = 1 ; i < ( count - 1 ) ; i ++ ) { int left = n / ( ( int ) Math . pow ( 10 , count - i ) ) ; int right = n % ( ( int ) Math . pow ( 10 , count - i - 1 ) ) ; if ( checkPrime ( left ) == 0 && checkPrime ( right ) == 0 ) { System . out . print ( i + " ▁ " ) ; found = true ; } } if ( found == false ) System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int n = 2317 ; printPrimePoints ( n ) ; } }
class GFG { static int power ( int num , int n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , n / 2 ) * power ( num , n / 2 ) ; else return num * power ( num , n / 2 ) * power ( num , n / 2 ) ; } static int checkRecursive ( int x , int n , int curr_num , int curr_sum ) { int results = 0 ; int p = power ( curr_num , n ) ; while ( p + curr_sum < x ) { results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) ; curr_num ++ ; p = power ( curr_num , n ) ; } if ( p + curr_sum == x ) results ++ ; return results ; } public static void main ( String [ ] args ) { int x = 10 , n = 2 ; System . out . println ( checkRecursive ( x , n , 1 , 0 ) ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void printGenerators ( int n ) { System . out . println ( "1 ▁ " ) ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) System . out . println ( i + " ▁ " ) ; } public static void main ( String args [ ] ) { int n = 10 ; printGenerators ( n ) ; } }
class IsDivisible { static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; } public static void main ( String [ ] args ) { String str = "1332" ; if ( check ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int MAX = 100001 ; static int [ ] perfectDiv = new int [ MAX ] ; static void precomputeCounts ( ) { for ( int i = 1 ; i * i < MAX ; ++ i ) { for ( int j = i * i ; j < MAX ; j += i * i ) ++ perfectDiv [ j ] ; } } static int countPerfectDivisors ( int n ) { return perfectDiv [ n ] ; } public static void main ( String [ ] args ) { precomputeCounts ( ) ; int n = 16 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; n = 12 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; } }
import java . util . Vector ; class Test { static final int MAXN = 100001 ; static int spf [ ] = new int [ MAXN ] ; static void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } static Vector < Integer > getFactorization ( int x ) { Vector < Integer > ret = new Vector < > ( ) ; while ( x != 1 ) { ret . add ( spf [ x ] ) ; x = x / spf [ x ] ; } return ret ; } public static void main ( String args [ ] ) { sieve ( ) ; int x = 12246 ; System . out . print ( " prime ▁ factorization ▁ for ▁ " + x + " ▁ : ▁ " ) ; Vector < Integer > p = getFactorization ( x ) ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) System . out . print ( p . get ( i ) + " ▁ " ) ; System . out . println ( ) ; } }
import java . util . Arrays ; class GFG { static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 6 , 2 , 5 , 4 } ; int size = arr . length ; System . out . println ( largestGCDSubsequence ( arr , size ) ) ; } }
class GFG { static final int MAX = 1000006 ; static void sieve ( int count [ ] ) { for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( count [ i ] == 0 ) { for ( int j = 2 * i ; j < MAX ; j += i ) count [ j ] ++ ; count [ i ] = 1 ; } } } static int query ( int count [ ] , int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += count [ i ] ; return sum ; } public static void main ( String [ ] args ) { int count [ ] = new int [ MAX ] ; sieve ( count ) ; System . out . println ( query ( count , 6 , 10 ) + " ▁ " + query ( count , 1 , 5 ) ) ; } }
import java . io . * ; class GFG { static void generateNumbers ( int factor [ ] , int n , int k ) { int next [ ] = new int [ k ] ; for ( int i = 0 ; i < n ; ) { int toincrement = 0 ; for ( int j = 0 ; j < k ; j ++ ) if ( next [ j ] < next [ toincrement ] ) toincrement = j ; if ( output != next [ toincrement ] ) { output = next [ toincrement ] ; System . out . print ( next [ toincrement ] + " ▁ " ) ; i ++ ; } next [ toincrement ] += factor [ toincrement ] ; } } public static void main ( String [ ] args ) { int factor [ ] = { 3 , 5 , 7 } ; int n = 10 ; int k = factor . length ; generateNumbers ( factor , n , k ) ; } }
import java . io . * ; class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static int multiplicativeOrder ( int A , int N ) { if ( GCD ( A , N ) != 1 ) return - 1 ; int result = 1 ; int K = 1 ; while ( K < N ) { result = ( result * A ) % N ; if ( result == 1 ) return K ; K ++ ; } return - 1 ; } public static void main ( String args [ ] ) { int A = 4 , N = 7 ; System . out . println ( multiplicativeOrder ( A , N ) ) ; } }
import java . io . * ; class GFG { static int sumOfRange ( int a , int b ) { int i = ( a * ( a + 1 ) ) >> 1 ; int j = ( b * ( b + 1 ) ) >> 1 ; return ( i - j ) ; } static int sumofproduct ( int n ) { int sum = 0 ; int root = ( int ) Math . sqrt ( n ) ; for ( int i = 1 ; i <= root ; i ++ ) { int up = n / i ; int low = Math . max ( n / ( i + 1 ) , root ) ; sum += ( i * sumOfRange ( up , low ) ) ; sum += ( i * ( n / i ) ) ; } return sum ; } static public void main ( String [ ] args ) { int n = 10 ; System . out . println ( sumofproduct ( n ) ) ; } }
class GFG { static int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; } public static void main ( String [ ] args ) { int n = 5 , x = 3 ; System . out . println ( minPower ( n , x ) ) ; } }
import java . lang . * ; class GFG { static int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; int sum = 5 ; while ( n > 2 ) { int d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . print ( calSum ( n ) ) ; } }
import java . lang . * ; class GFG { static int findKHCF ( int x , int y , int k ) { int small = Math . min ( x , y ) ; int count = 1 ; for ( int i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { int x = 4 , y = 24 , k = 3 ; System . out . print ( findKHCF ( x , y , k ) ) ; } }
class GFG { static int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 == 1 ) ans *= 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 == 1 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; } public static void main ( String [ ] args ) { int n = 72 ; System . out . println ( findMinNumber ( n ) ) ; } }
class GFG { static boolean isToOne ( int n ) { return ( n > 0 ) ; } public static void main ( String [ ] args ) { int n = 5 ; if ( isToOne ( n ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void findgcd ( int n , int x , int y ) { int g = gcd ( x , y ) ; for ( int i = 0 ; i < g ; i ++ ) System . out . print ( n ) ; } public static void main ( String [ ] args ) { int n = 123 , x = 5 , y = 2 ; findgcd ( n , x , y ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; } static int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; } static int countFactorialXNotY ( int x , int y ) { return ( firstFactorialDivisibleNumber ( y ) - firstFactorialDivisibleNumber ( x ) ) ; } public static void main ( String [ ] args ) { int x = 15 , y = 25 ; System . out . print ( countFactorialXNotY ( x , y ) ) ; } }
class GFG { static int firstFactorialDivisibleNumber ( int x ) { int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; } public static void main ( String [ ] args ) { int x = 16 ; System . out . print ( firstFactorialDivisibleNumber ( x ) ) ; } }
class GFG { static boolean SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) isPrime [ i ] = false ; } } return false ; } static void findPrimePair ( int n ) { boolean isPrime [ ] = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime [ i ] && isPrime [ n - i ] ) { System . out . print ( i + " ▁ " + ( n - i ) ) ; return ; } } } public static void main ( String [ ] args ) { int n = 74 ; findPrimePair ( n ) ; } }
import java . util . * ; class Digits { public static int getFirstDigit ( int x ) { while ( x >= 10 ) x /= 10 ; return x ; } public static int getCountWithSameStartAndEndFrom1 ( int x ) { if ( x < 10 ) return x ; int tens = x / 10 ; int res = tens + 9 ; int firstDigit = getFirstDigit ( x ) ; int lastDigit = x % 10 ; if ( lastDigit < firstDigit ) res -- ; return res ; } public static int getCountWithSameStartAndEnd ( int start , int end ) { return getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ; } public static void main ( String [ ] args ) { int start = 5 , end = 40 ; System . out . print ( getCountWithSameStartAndEnd ( start , end ) ) ; } }
import java . io . * ; class GFG { static void sieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } } static boolean rightTruPrime ( int n ) { boolean isPrime [ ] = new boolean [ n + 1 ] ; sieveOfEratosthenes ( n , isPrime ) ; while ( n != 0 ) { if ( isPrime [ n ] ) n = n / 10 ; else return false ; } return true ; } public static void main ( String args [ ] ) { int n = 59399 ; if ( rightTruPrime ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static void SieveOfEratosthenes ( int n , boolean prime [ ] ) { for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } static void mersennePrimes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , prime ) ; for ( int k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { long num = ( 1 << k ) - 1 ; if ( prime [ ( int ) ( num ) ] ) System . out . print ( num + " ▁ " ) ; } } public static void main ( String args [ ] ) { int n = 31 ; System . out . println ( " Mersenne ▁ prime " + " numbers ▁ smaller ▁ than " + " or ▁ equal ▁ to ▁ " + n ) ; mersennePrimes ( n ) ; } }
import java . io . * ; class GFG { static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; } static public void main ( String [ ] args ) { int N = 10 , K = 2 ; System . out . println ( findSum ( N , K ) ) ; } }
import java . io . * ; class GFG { static int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; } static public void main ( String [ ] args ) { int N = 10 , K = 2 ; System . out . println ( findSum ( N , K ) ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int findnum ( String str ) { int n = str . length ( ) ; int count_after_dot = 0 ; boolean dot_seen = false ; int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != ' . ' ) { num = num * 10 + ( str . charAt ( i ) - '0' ) ; if ( dot_seen == true ) count_after_dot ++ ; } else dot_seen = true ; } if ( dot_seen == false ) return 1 ; int dem = ( int ) Math . pow ( 10 , count_after_dot ) ; return ( dem / gcd ( num , dem ) ) ; } public static void main ( String [ ] args ) { String str = "5.125" ; System . out . print ( findnum ( str ) ) ; } }
class GFG { static int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( maxHandshake ( n ) ) ; } }
import java . util . * ; class solution { static boolean divisible ( String N , int digit ) { int ans = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { ans = ( ans * 10 + ( N . charAt ( i ) - '0' ) ) ; ans %= digit ; } return ( ans == 0 ) ; } static int allDigits ( String N ) { Boolean [ ] divide = new Boolean [ 10 ] ; Arrays . fill ( divide , Boolean . FALSE ) ; for ( int digit = 2 ; digit <= 9 ; digit ++ ) { if ( divisible ( N , digit ) ) divide [ digit ] = true ; } int result = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { if ( divide [ N . charAt ( i ) - '0' ] == true ) result ++ ; } return result ; } public static void main ( String args [ ] ) { String N = "122324" ; System . out . println ( allDigits ( N ) ) ; } }
class gfg { static int countNums ( int n , int x , int y ) { boolean [ ] arr = new boolean [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; } public static void main ( String [ ] args ) { int n = 15 , x = 5 , y = 7 ; System . out . println ( countNums ( n , x , y ) ) ; } }
import java . util . Arrays ; class GFG { static int reverse ( int x ) { int rev = 0 ; while ( x > 0 ) { rev = ( rev * 10 ) + x % 10 ; x = x / 10 ; } return rev ; } static void printEmirp ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { int rev = reverse ( p ) ; if ( p != rev && rev <= n && prime [ rev ] ) { System . out . print ( p + " ▁ " + rev + " ▁ " ) ; prime [ rev ] = false ; } } } } public static void main ( String [ ] args ) { int n = 100 ; printEmirp ( n ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; { sum = sum + i ; sum = sum + ( n / i ) ; } } } sum = sum - n ; return sum ; } static boolean checkAbundant ( int n ) { return ( getSum ( n ) > n ) ; } public static void main ( String args [ ] ) throws IOException { if ( checkAbundant ( 12 ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; if ( checkAbundant ( 15 ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static boolean isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } public static void main ( String [ ] args ) { if ( isPowerful ( 20 ) ) System . out . print ( "YESNEW_LINE"); else System . out . print ( "NONEW_LINE"); if ( isPowerful ( 27 ) ) System . out . print ( "YESNEW_LINE"); else System . out . print ( "NONEW_LINE"); } }
import java . io . * ; class GFG { static int divisorsSum ( int n ) { for ( int i = 1 ; i <= ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; } static boolean isDeficient ( int n ) { return ( divisorsSum ( n ) < ( 2 * n ) ) ; } public static void main ( String args [ ] ) { if ( isDeficient ( 12 ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; if ( isDeficient ( 15 ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . Vector ; class Test { static int MAX = 10000 ; static Vector < Integer > primes = new Vector < > ( ) ; static void sieveSundaram ( ) { boolean marked [ ] = new boolean [ MAX / 2 + 100 ] ; for ( int i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . addElement ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . addElement ( 2 * i + 1 ) ; } static boolean isSmith ( int n ) { int original_no = n ; int pDigitSum = 0 ; for ( int i = 0 ; primes . get ( i ) <= n / 2 ; i ++ ) { while ( n % primes . get ( i ) == 0 ) { int p = primes . get ( i ) ; n = n / p ; while ( p > 0 ) { pDigitSum += ( p % 10 ) ; p = p / 10 ; } } } if ( n != 1 && n != original_no ) { while ( n > 0 ) { pDigitSum = pDigitSum + n % 10 ; n = n / 10 ; } } int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits = sumDigits + original_no % 10 ; original_no = original_no / 10 ; } return ( pDigitSum == sumDigits ) ; } public static void main ( String [ ] args ) { sieveSundaram ( ) ; System . out . println ( " Printing ▁ first ▁ few ▁ Smith ▁ Numbers " + " ▁ using ▁ isSmith ( ) " ) ; for ( int i = 1 ; i < 500 ; i ++ ) if ( isSmith ( i ) ) System . out . print ( i + " ▁ " ) ; } }
class GFG { static boolean iskaprekar ( int n ) { if ( n == 1 ) return true ; int sq_n = n * n ; int count_digits = 0 ; while ( sq_n != 0 ) { count_digits ++ ; sq_n /= 10 ; } for ( int r_digits = 1 ; r_digits < count_digits ; r_digits ++ ) { int eq_parts = ( int ) Math . pow ( 10 , r_digits ) ; if ( eq_parts == n ) continue ; int sum = sq_n / eq_parts + sq_n % eq_parts ; if ( sum == n ) return true ; } return false ; } public static void main ( String [ ] args ) { System . out . println ( " Printing ▁ first ▁ few ▁ Kaprekar ▁ Numbers " + " ▁ using ▁ iskaprekar ( ) " ) ; for ( int i = 1 ; i < 10000 ; i ++ ) if ( iskaprekar ( i ) ) System . out . print ( i + " ▁ " ) ; } }
import java . io . * ; import java . util . * ; class GFG { static boolean isKeith ( int x ) { ArrayList < Integer > terms = new ArrayList < Integer > ( ) ; while ( temp > 0 ) { terms . add ( temp % 10 ) ; temp = temp / 10 ; n ++ ; } Collections . reverse ( terms ) ; int next_term = 0 , i = n ; while ( next_term < x ) { next_term = 0 ; for ( int j = 1 ; j <= n ; j ++ ) next_term += terms . get ( i - j ) ; terms . add ( next_term ) ; i ++ ; } return ( next_term == x ) ; } public static void main ( String [ ] args ) { if ( isKeith ( 14 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; if ( isKeith ( 12 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; if ( isKeith ( 197 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class Test { static boolean canBeSumofConsec ( int n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( canBeSumofConsec ( n ) ? " true " : " false " ) ; } }
import java . io . * ; class GFG { static int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long ef1 = 0 , ef2 = 2 ; long sum = ef1 + ef2 ; while ( ef2 <= limit ) { long ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return ( int ) sum ; } public static void main ( String [ ] args ) { int limit = 400 ; System . out . println ( evenFibSum ( limit ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static boolean isPerfect ( int n ) { int s = ( int ) ( Math . sqrt ( n ) ) ; return ( s * s == n ) ; } static int divisorsCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count += 1 ; else count += 2 ; } } return count ; } static int kDivisors ( int a , int b , int k ) { int count = 0 ; for ( int i = a ; i <= b ; i ++ ) { if ( isPerfect ( i ) ) if ( divisorsCount ( i ) == k ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int a = 21 , b = 149 , k = 333 ; System . out . println ( kDivisors ( a , b , k ) ) ; } }
class GFG { static long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( evenFib ( n ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static int MAX = 3000 ; public static int smartNumber ( int n ) { Integer [ ] primes = new Integer [ MAX ] ; Arrays . fill ( primes , new Integer ( 0 ) ) ; Vector < Integer > result = new Vector < > ( ) ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( primes [ i ] == 0 ) { primes [ i ] = 1 ; for ( int j = i * 2 ; j < MAX ; j = j + i ) { primes [ j ] -= 1 ; if ( ( primes [ j ] + 3 ) == 0 ) result . add ( j ) ; } } } Collections . sort ( result ) ; return result . get ( n - 1 ) ; } public static void main ( String [ ] args ) { int n = 50 ; System . out . println ( smartNumber ( n ) ) ; } }
import java . io . * ; class GFG { static int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; } public static void main ( String [ ] args ) { int x = 100 , y = 19 ; System . out . println ( countSteps ( x , y ) ) ; } }
import java . io . * ; class GFG { static int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; } public static void main ( String [ ] args ) { int n = 10 ; int p = 5 ; System . out . println ( findCountOfSolutions ( n , p ) ) ; } }
import java . util . Arrays ; class GFG { static int kaprekarRec ( int n , int prev ) { if ( n == 0 ) return 0 ; prev = n ; int [ ] digits = new int [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { digits [ i ] = n % 10 ; n = n / 10 ; } Arrays . sort ( digits ) ; int asc = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) asc = asc * 10 + digits [ i ] ; Arrays . sort ( digits ) ; int desc = 0 ; for ( int i = 3 ; i >= 0 ; i -- ) desc = desc * 10 + digits [ i ] ; int diff = Math . abs ( asc - desc ) ; if ( diff == prev ) return diff ; return kaprekarRec ( diff , prev ) ; } static int kaprekar ( int n ) { int prev = 0 ; return kaprekarRec ( n , prev ) ; } public static void main ( String [ ] args ) { System . out . println ( kaprekar ( 1000 ) ) ; System . out . println ( kaprekar ( 1112 ) ) ; System . out . println ( kaprekar ( 9812 ) ) ; } }
class GFG { static float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = ( int ) ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0f * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0f * A ) ) ; return sqrt_of_s ; } public static void main ( String [ ] args ) { float num = 9.2345f ; float sqroot_of_num = sqroot ( num ) ; System . out . print ( " Square ▁ root ▁ of ▁ " + num + " ▁ = ▁ " + Math . round ( sqroot_of_num * 100000.0 ) / 100000.0 ) ; } }
class GFG { static int power ( int x , int a ) { int res = 1 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) res = res * x ; x = x * x ; a >>= 1 ; } return res ; } static int breakInteger ( int N ) { if ( N == 2 ) return 1 ; if ( N == 3 ) return 2 ; int maxProduct = - 1 ; switch ( N % 3 ) { case 0 : maxProduct = power ( 3 , N / 3 ) ; break ; case 1 : maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) ; break ; case 2 : maxProduct = 2 * power ( 3 , N / 3 ) ; break ; } return maxProduct ; } public static void main ( String [ ] args ) { int maxProduct = breakInteger ( 10 ) ; System . out . println ( maxProduct ) ; } }
import java . util . * ; public class GfG { static int digSum ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return sum ; } public static void main ( String argc [ ] ) { int n = 1234 ; System . out . println ( digSum ( n ) ) ; } }
import java . io . * ; class GFG { static int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } public static void main ( String [ ] args ) { int n = 9999 ; System . out . println ( digSum ( n ) ) ; } }
import java . io . * ; class GFG { static int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; } public static void main ( String args [ ] ) { System . out . println ( " Count ▁ = ▁ " + countMultiples ( 25 ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int Modulo ( int a , char b [ ] ) { int mod = 0 ; for ( int i = 0 ; i < b . length ; i ++ ) mod = ( mod * 10 + b [ i ] - '0' ) % a ; } static int LastDigit ( char a [ ] , char b [ ] ) { int len_a = a . length , len_b = b . length ; if ( len_a == 1 && len_b == 1 && b [ 0 ] == '0' && a [ 0 ] == '0' ) return 1 ; if ( len_b == 1 && b [ 0 ] == '0' ) return 1 ; if ( len_a == 1 && a [ 0 ] == '0' ) return 0 ; int exp = ( Modulo ( 4 , b ) == 0 ) ? 4 : Modulo ( 4 , b ) ; int res = ( int ) ( Math . pow ( a [ len_a - 1 ] - '0' , exp ) ) ; return res % 10 ; } public static void main ( String args [ ] ) throws IOException { char a [ ] = "117" . toCharArray ( ) , b [ ] = { '3' } ; System . out . println ( LastDigit ( a , b ) ) ; } }
public class ReverseAdd { long reversDigits ( long num ) { long rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } boolean isPalindrome ( long num ) { return ( reversDigits ( num ) == num ) ; } void ReverseandAdd ( long num ) { long rev_num = 0 ; while ( num <= 4294967295l ) { rev_num = reversDigits ( num ) ; num = num + rev_num ; if ( isPalindrome ( num ) ) { System . out . println ( num ) ; break ; } else if ( num > 4294967295l ) { System . out . println ( " No ▁ palindrome ▁ exist " ) ; } } } public static void main ( String [ ] args ) { ReverseAdd ob = new ReverseAdd ( ) ; ob . ReverseandAdd ( 195l ) ; ob . ReverseandAdd ( 265l ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; } public static void main ( String args [ ] ) { int a = 34 , b = 17 ; System . out . println ( " Gcd ▁ of ▁ given " + " numbers ▁ is ▁ " + gcd ( a , b ) ) ; } }
import java . io . * ; class GFG { static void findNDigitNumsUtil ( int n , int sum , char out [ ] , int index ) { if ( index > n sum < 0 ) return ; if ( index == n ) { if ( sum == 0 ) { out [ index ] = ' \0' ; System . out . print ( out ) ; System . out . print ( " ▁ " ) ; } return ; } for ( int i = 0 ; i <= 9 ; i ++ ) { out [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , sum - i , out , index + 1 ) ; } } static void findNDigitNums ( int n , int sum ) { char [ ] out = new char [ n + 1 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) { out [ 0 ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , sum - i , out , 1 ) ; } } public static void main ( String [ ] args ) { int n = 2 , sum = 3 ; findNDigitNums ( n , sum ) ; } }
import java . util . * ; class GFG { static boolean oneDigit ( int num ) { return ( num >= 0 && num < 10 ) ; } static boolean isPalUtil ( int num , int dupNum ) { if ( oneDigit ( num ) ) return ( num == ( dupNum ) % 10 ) ; if ( ! isPalUtil ( num / 10 , dupNum ) ) return false ; dupNum /= 10 ; return ( num % 10 == ( dupNum ) % 10 ) ; } static boolean isPal ( int num ) { if ( num < 0 ) num = - num ; return isPalUtil ( num , dupNum ) ; } static void printPalPrimesLessThanN ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] && isPal ( p ) ) { System . out . print ( p + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int n = 100 ; System . out . printf ( " Palindromic ▁ primes ▁ smaller ▁ than ▁ or ▁ " + "equal to %d are :NEW_LINE", n); printPalPrimesLessThanN ( n ) ; } }
import java . io . * ; class GFG { static int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } static void printKAlmostPrimes ( int k , int n ) { for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == k ) { System . out . print ( num + " ▁ " ) ; i ++ ; } } return ; } public static void main ( String [ ] args ) { int n = 10 , k = 2 ; System . out . println ( " First ▁ " + n + " ▁ " + k + " - almost ▁ prime ▁ numbers ▁ : ▁ " ) ; printKAlmostPrimes ( k , n ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void lowest ( int den3 , int num3 ) { int common_factor = gcd ( num3 , den3 ) ; den3 = den3 / common_factor ; num3 = num3 / common_factor ; System . out . println ( num3 + " / " + den3 ) ; } static void addFraction ( int num1 , int den1 , int num2 , int den2 ) { int den3 = gcd ( den1 , den2 ) ; den3 = ( den1 * den2 ) / den3 ; int num3 = ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ; lowest ( den3 , num3 ) ; } public static void main ( String [ ] args ) { int num1 = 1 , den1 = 500 , num2 = 2 , den2 = 1500 ; System . out . print ( num1 + " / " + den1 + " ▁ + ▁ " + num2 + " / " + den2 + " ▁ is ▁ equal ▁ to ▁ " ) ; addFraction ( num1 , den1 , num2 , den2 ) ; } }
import java . io . * ; class GFG { static int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; } public static void main ( String [ ] args ) { System . out . println ( findPieces ( 1 ) ) ; System . out . println ( findPieces ( 2 ) ) ; System . out . println ( findPieces ( 3 ) ) ; System . out . println ( findPieces ( 50 ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static double M_E = 2.71828182845904523536 ; public static double M_PI = 3.141592654 ; static long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . floor ( x ) + 1 ; } public static void main ( String [ ] args ) { System . out . println ( findDigits ( 1 ) ) ; System . out . println ( findDigits ( 50000000 ) ) ; System . out . println ( findDigits ( 1000000000 ) ) ; System . out . println ( findDigits ( 120 ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return ( int ) ( Math . floor ( digits ) ) + 1 ; } public static void main ( String [ ] args ) { System . out . println ( findDigits ( 1 ) ) ; System . out . println ( findDigits ( 5 ) ) ; System . out . println ( findDigits ( 10 ) ) ; System . out . println ( findDigits ( 120 ) ) ; } }
import java . io . * ; class GFG { static int countEvenSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 1 } ; int n = arr . length ; System . out . print ( " The ▁ Number ▁ of ▁ Subarrays " + " ▁ with ▁ even ▁ sum ▁ is ▁ " ) ; System . out . println ( countEvenSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int countEvenSum ( int arr [ ] , int n ) { int temp [ ] = { 1 , 0 } ; int result = 0 , sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 ; temp [ sum ] ++ ; } result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) / 2 ) ; result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) / 2 ) ; return ( result ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 1 } ; int n = arr . length ; System . out . println ( " The ▁ Number ▁ of ▁ Subarrays " + " ▁ with ▁ even ▁ sum ▁ is ▁ " + countEvenSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( " Sum ▁ of ▁ Fibonacci " + " ▁ numbers ▁ is ▁ : ▁ " + calculateSum ( n ) ) ; } }
import java . io . * ; class GFG { static void findCombinationsUtil ( int arr [ ] , int index , int num , int reducedNum ) { if ( reducedNum < 0 ) return ; if ( reducedNum == 0 ) { for ( int i = 0 ; i < index ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; return ; } int prev = ( index == 0 ) ? 1 : arr [ index - 1 ] ; for ( int k = prev ; k <= num ; k ++ ) { arr [ index ] = k ; findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) ; } } static void findCombinations ( int n ) { int arr [ ] = new int [ n ] ; findCombinationsUtil ( arr , 0 , n , n ) ; } public static void main ( String [ ] args ) { int n = 5 ; findCombinations ( n ) ; } }
class GFG { static int z = 0 ; static int pow1 ( int base1 , int exponent , int modulus ) { int result = 1 ; base1 = base1 % modulus ; while ( exponent > 0 ) { if ( exponent % 2 == 1 ) result = ( result * base1 ) % modulus ; exponent = exponent >> 1 ; base1 = ( base1 * base1 ) % modulus ; } return result ; } static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static int order ( int p , int b ) { if ( gcd ( p , b ) != 1 ) { System . out . println ( " p ▁ and ▁ b ▁ are " + " not ▁ co - prime . " ) ; return - 1 ; } int k = 3 ; while ( true ) { if ( pow1 ( b , k , p ) == 1 ) return k ; k ++ ; } } static int convertx2e ( int x ) { z = 0 ; while ( x % 2 == 0 ) { x /= 2 ; z ++ ; } return x ; } static int STonelli ( int n , int p ) { if ( gcd ( n , p ) != 1 ) { System . out . println ( " a ▁ and ▁ p ▁ are ▁ not ▁ coprime " ) ; return - 1 ; } if ( pow1 ( n , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) { System . out . println ( " no ▁ sqrt ▁ possible " ) ; return - 1 ; } int s , e ; s = convertx2e ( p - 1 ) ; e = z ; int q ; for ( q = 2 ; ; q ++ ) { if ( pow1 ( q , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) break ; } int x = pow1 ( n , ( s + 1 ) / 2 , p ) ; int b = pow1 ( n , s , p ) ; int g = pow1 ( q , s , p ) ; int r = e ; while ( true ) { int m ; for ( m = 0 ; m < r ; m ++ ) { if ( order ( p , b ) == - 1 ) return - 1 ; if ( order ( p , b ) == Math . pow ( 2 , m ) ) break ; } if ( m == 0 ) return x ; x = ( x * pow1 ( g , ( int ) Math . pow ( 2 , r - m - 1 ) , p ) ) % p ; g = pow1 ( g , ( int ) Math . pow ( 2 , r - m ) , p ) ; b = ( b * g ) % p ; if ( b == 1 ) return x ; r = m ; } } public static void main ( String [ ] args ) { int n = 2 ; int p = 113 ; int x = STonelli ( n , p ) ; if ( x == - 1 ) System . out . println ( " Modular ▁ square " + "root is not existNEW_LINE"); else System . out . println ( " Modular ▁ square ▁ root ▁ of ▁ " + n + " ▁ and ▁ " + p + " ▁ is ▁ " + x + "NEW_LINE"); } }
class GFG { static boolean isPower ( int x , int y ) { int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; } public static void main ( String args [ ] ) { if ( isPower ( 27 , 729 ) ) System . out . println ( "1" ) ; else System . out . println ( "0" ) ; } }
import java . io . * ; import static java . lang . Math . * ; class Quadratic { static void findRoots ( int a , int b , int c ) { if ( a == 0 ) { System . out . println ( " Invalid " ) ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { System . out . println ( "Roots are real and different NEW_LINE"); System . out . println ( ( double ) ( - b + sqrt_val ) / ( 2 * a ) + "NEW_LINE" + ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ; } else if ( d == 0 ) { System . out . println ( "Roots are real and same NEW_LINE"); System . out . println ( - ( double ) b / ( 2 * a ) + "NEW_LINE" + - ( double ) b / ( 2 * a ) ) ; } { System . out . println ( "Roots are complex NEW_LINE"); System . out . println ( - ( double ) b / ( 2 * a ) + " ▁ + ▁ i " + sqrt_val + "NEW_LINE" + - ( double ) b / ( 2 * a ) + " ▁ - ▁ i " + sqrt_val ) ; } } public static void main ( String args [ ] ) { int a = 1 , b = - 7 , c = 12 ; findRoots ( a , b , c ) ; } }
public class GFG { static boolean isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; } public static void main ( String args [ ] ) { if ( isPerfectSquare ( 35 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " NO " ) ; if ( isPerfectSquare ( 49 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int findCount ( int d ) { return 9 * ( ( int ) ( Math . pow ( 10 , d - 1 ) ) - ( int ) ( Math . pow ( 9 , d - 1 ) ) ) ; } public static void main ( String args [ ] ) { int d = 1 ; System . out . println ( findCount ( d ) ) ; d = 2 ; System . out . println ( findCount ( d ) ) ; d = 4 ; System . out . println ( findCount ( d ) ) ; } }
class GFG { public static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( " Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ " + countDyckPaths ( n ) ) ; } }
class GFG { static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; } public static void main ( String [ ] args ) { int n = 55 ; if ( isTriangular ( n ) ) System . out . print ( " The ▁ number ▁ " + " is ▁ a ▁ triangular ▁ number " ) ; else System . out . print ( " The ▁ number " + " ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) ; } }
import java . io . * ; class GFG { static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; } public static void main ( String [ ] args ) { int num = 55 ; if ( isTriangular ( num ) ) System . out . println ( " The ▁ number ▁ is " + " ▁ a ▁ triangular ▁ number " ) ; else System . out . println ( " The ▁ number ▁ " + " is ▁ NOT ▁ a ▁ triangular ▁ number " ) ; } }
import java . io . * ; class GFG { static int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } static int toDeci ( String str , int base ) { int len = str . length ( ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str . charAt ( i ) ) >= base ) { System . out . println ( " Invalid ▁ Number " ) ; return - 1 ; } num += val ( str . charAt ( i ) ) * power ; power = power * base ; } return num ; } public static void main ( String [ ] args ) { String str = "11A " ; int base = 16 ; System . out . println ( " Decimal ▁ equivalent ▁ of ▁ " + str + " ▁ in ▁ base ▁ " + base + " ▁ is ▁ " + " ▁ " + toDeci ( str , base ) ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { int c ; while ( a != 0 ) { c = a ; a = b % a ; b = c ; } return b ; } static void forbenius ( int X , int Y ) { if ( gcd ( X , Y ) != 1 ) { System . out . println ( " NA " ) ; return ; } int A = ( X * Y ) - ( X + Y ) ; int N = ( X - 1 ) * ( Y - 1 ) / 2 ; System . out . println ( " Largest ▁ Amount ▁ = ▁ " + A ) ; System . out . println ( " Total ▁ Count ▁ = ▁ " + N ) ; } public static void main ( String [ ] args ) { int X = 2 , Y = 5 ; forbenius ( X , Y ) ; X = 5 ; Y = 10 ; System . out . println ( ) ; forbenius ( X , Y ) ; } }
import java . io . * ; class code_conversion { char xor_c ( char a , char b ) { return ( a == b ) ? '0' : '1' ; } char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; } String binarytoGray ( String binary ) { String gray = " " ; gray += binary . charAt ( 0 ) ; for ( int i = 1 ; i < binary . length ( ) ; i ++ ) { gray += xor_c ( binary . charAt ( i - 1 ) , binary . charAt ( i ) ) ; } return gray ; } String graytoBinary ( String gray ) { String binary = " " ; binary += gray . charAt ( 0 ) ; for ( int i = 1 ; i < gray . length ( ) ; i ++ ) { if ( gray . charAt ( i ) == '0' ) binary += binary . charAt ( i - 1 ) ; else binary += flip ( binary . charAt ( i - 1 ) ) ; } return binary ; } public static void main ( String args [ ] ) throws IOException { code_conversion ob = new code_conversion ( ) ; String binary = "01001" ; System . out . println ( " Gray ▁ code ▁ of ▁ " + binary + " ▁ is ▁ " + ob . binarytoGray ( binary ) ) ; String gray = "01101" ; System . out . println ( " Binary ▁ code ▁ of ▁ " + gray + " ▁ is ▁ " + ob . graytoBinary ( gray ) ) ; } }
class GFG { static int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( seriesSum ( 1 , 1 , N ) ) ; } }
import java . io . * ; class GFG { static int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; } public static void main ( String [ ] args ) { int n = 25 , p = 29 ; System . out . print ( modFact ( n , p ) ) ; } }
import java . io . * ; class GFG { static int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } static int findMinX ( int num [ ] , int rem [ ] , int k ) { int prod = 1 ; for ( int i = 0 ; i < k ; i ++ ) prod *= num [ i ] ; int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int pp = prod / num [ i ] ; result += rem [ i ] * inv ( pp , num [ i ] ) * pp ; } return result % prod ; } public static void main ( String args [ ] ) { int num [ ] = { 3 , 4 , 5 } ; int rem [ ] = { 2 , 3 , 1 } ; int k = num . length ; System . out . println ( " x ▁ is ▁ " + findMinX ( num , rem , k ) ) ; } }
import java . io . * ; class GFG { static int findMinX ( int num [ ] , int rem [ ] , int k ) { while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } } public static void main ( String args [ ] ) { int num [ ] = { 3 , 4 , 5 } ; int rem [ ] = { 2 , 3 , 1 } ; int k = num . length ; System . out . println ( " x ▁ is ▁ " + findMinX ( num , rem , k ) ) ; } }
class GFG { static int nCrModpDP ( int n , int r , int p ) { int [ ] C = new int [ r + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; } static int nCrModpLucas ( int n , int r , int p ) { if ( r == 0 ) return 1 ; int ni = n % p ; int ri = r % p ; } public static void main ( String [ ] args ) { int n = 1000 , r = 900 , p = 13 ; System . out . println ( " Value ▁ of ▁ nCr ▁ % ▁ p ▁ is ▁ " + nCrModpLucas ( n , r , p ) ) ; } }
import java . io . * ; class Numbers { static boolean isValid ( int n , int d ) { int digit = n % 10 ; int sum = digit ; if ( digit == d ) return false ; n /= 10 ; while ( n > 0 ) { digit = n % 10 ; if ( digit == d digit <= sum ) return false ; else { sum += digit ; n /= 10 ; } } return true ; } static void printGoodNumber ( int L , int R , int d ) { for ( int i = L ; i <= R ; i ++ ) { if ( isValid ( i , d ) ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int L = 410 , R = 520 , d = 3 ; printGoodNumber ( L , R , d ) ; } }
class GFG { public static int nearestSmallerEqFib ( int n ) { if ( n == 0 n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; } public static void printFibRepresntation ( int n ) { while ( n > 0 ) { int f = nearestSmallerEqFib ( n ) ; System . out . print ( f + " ▁ " ) ; n = n - f ; } } public static void main ( String [ ] args ) { int n = 30 ; System . out . println ( " Non - neighbouring ▁ Fibonacci ▁ " + " ▁ Representation ▁ of ▁ " + n + " ▁ is " ) ; printFibRepresntation ( n ) ; } }
class GFG { static int dp [ ] [ ] [ ] = new int [ 5001 ] [ 5001 ] [ 5 ] ; static int countWaysUtil ( int n , int parts , int nextPart ) { if ( parts == 0 && n == 0 ) return 1 ; if ( n <= 0 parts <= 0 ) return 0 ; if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) return dp [ n ] [ nextPart ] [ parts ] ; for ( int i = nextPart ; i <= n ; i ++ ) ans += countWaysUtil ( n - i , parts - 1 , i ) ; return ( dp [ n ] [ nextPart ] [ parts ] = ans ) ; } static int countWays ( int n ) { for ( int i = 0 ; i < 5001 ; i ++ ) { for ( int j = 0 ; j < 5001 ; j ++ ) { for ( int l = 0 ; l < 5 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } return countWaysUtil ( n , 4 , 1 ) ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( countWays ( n ) ) ; } }
class GFG { static void printTwins ( int low , int high ) { boolean prime [ ] = new boolean [ high + 1 ] , twin = false ; for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p <= Math . floor ( Math . sqrt ( high ) ) + 1 ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= high ; i += p ) { prime [ i ] = false ; } } } for ( int i = low ; i <= high ; i ++ ) { if ( prime [ i ] && prime [ i + 2 ] ) { int a = i + 2 ; System . out . print ( " Smallest ▁ twins ▁ in ▁ given ▁ range : ▁ ( " + i + " , ▁ " + a + " ) " ) ; twin = true ; break ; } } if ( twin == false ) { System . out . println ( " No ▁ such ▁ pair ▁ exists " ) ; } } public static void main ( String [ ] args ) { printTwins ( 10 , 100 ) ; } }
import java . util . * ; class GFG { static int nextSparse ( int x ) { ArrayList < Integer > bin = new ArrayList < Integer > ( ) ; while ( x != 0 ) { bin . add ( x & 1 ) ; x >>= 1 ; } bin . add ( 0 ) ; int last_final = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( bin . get ( i ) == 1 && bin . get ( i - 1 ) == 1 && bin . get ( i + 1 ) != 1 ) { bin . set ( i + 1 , 1 ) ; for ( int j = i ; j >= last_final ; j -- ) bin . set ( j , 0 ) ; last_final = i + 1 ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += bin . get ( i ) * ( 1 << i ) ; return ans ; } public static void main ( String [ ] args ) { int x = 38 ; System . out . println ( " Next ▁ Sparse ▁ Number ▁ is ▁ " + nextSparse ( x ) ) ; } }
import java . io . * ; class GFG { static int sumBitDifferences ( int arr [ ] , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 5 } ; int n = arr . length ; System . out . println ( sumBitDifferences ( arr , n ) ) ; } }
class GFG { static void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . printf ( " % d ▁ " , arr [ i ] ) ; System . out . println ( " " ) ; } static void generateUtil ( int x , int arr [ ] , int curr_sum , int curr_idx ) { if ( curr_sum == x ) { printArr ( arr , curr_idx ) ; return ; } int num = 1 ; while ( num <= x - curr_sum && ( curr_idx == 0 num <= arr [ curr_idx - 1 ] ) ) { arr [ curr_idx ] = num ; generateUtil ( x , arr , curr_sum + num , curr_idx + 1 ) ; num ++ ; } } static void generate ( int x ) { int arr [ ] = new int [ x ] ; generateUtil ( x , arr , 0 , 0 ) ; } public static void main ( String [ ] args ) { int x = 5 ; generate ( x ) ; } }
class GFG { static boolean isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; } public static void main ( String [ ] args ) { System . out . println ( " Below ▁ are ▁ all ▁ perfect " + " numbers ▁ till ▁ 10000" ) ; for ( int n = 2 ; n < 10000 ; n ++ ) if ( isPerfect ( n ) ) System . out . println ( n + " ▁ is ▁ a ▁ perfect ▁ number " ) ; } }
class GFG { static boolean checkUtil ( int num , int dig , int base ) { if ( dig == 1 && num < base ) return true ; if ( dig > 1 && num >= base ) return checkUtil ( num / base , -- dig , base ) ; return false ; } static boolean check ( int num , int dig ) { for ( int base = 2 ; base <= 32 ; base ++ ) if ( checkUtil ( num , dig , base ) ) return true ; return false ; } public static void main ( String [ ] args ) { int num = 8 ; int dig = 3 ; if ( check ( num , dig ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . io . * ; class GFG { static int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % a ; return res ; } public static void main ( String [ ] args ) { String num = "12316767678678" ; System . out . println ( mod ( num , 10 ) ) ; } }
import java . io . * ; class GFG { static int modInverse ( int a , int m ) { for ( int x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; return 1 ; } public static void main ( String args [ ] ) { int a = 3 , m = 11 ; System . out . println ( modInverse ( a , m ) ) ; } }
class GFG { static int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } public static void main ( String args [ ] ) { int a = 3 , m = 11 ; System . out . println ( " Modular ▁ multiplicative ▁ " + " inverse ▁ is ▁ " + modInverse ( a , m ) ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int phi ( int n ) { int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; } public static void main ( String [ ] args ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) System . out . println ( " phi ( " + n + " ) ▁ = ▁ " + phi ( n ) ) ; } }
import java . io . * ; class GFG { static int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; } public static void main ( String args [ ] ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) System . out . println ( " phi ( " + n + " ) ▁ = ▁ " + phi ( n ) ) ; } }
import java . io . * ; class GFG { static int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res *= i ; return res ; } static double sum ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / factorial ( i ) ; return sum ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( sum ( n ) ) ; } }
class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } static long findWays ( int n ) { if ( ( n & 1 ) != 0 ) return 0 ; return catalan ( n / 2 ) ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( " Total ▁ possible ▁ expressions ▁ of ▁ length ▁ " + n + " ▁ is ▁ " + findWays ( 6 ) ) ; } }
class GFG { static boolean isOperand ( char c ) { return ( c >= '0' && c <= '9' ) ; } static int value ( char c ) { return ( int ) ( c - '0' ) ; } static int evaluate ( String exp ) { if ( exp . length ( ) == 0 ) return - 1 ; int res = value ( exp . charAt ( 0 ) ) ; for ( int i = 1 ; i < exp . length ( ) ; i += 2 ) { char opr = exp . charAt ( i ) , opd = exp . charAt ( i + 1 ) ; if ( isOperand ( opd ) == false ) return - 1 ; if ( opr == ' + ' ) res += value ( opd ) ; else if ( opr == ' - ' ) res -= value ( opd ) ; else if ( opr == ' * ' ) res *= value ( opd ) ; else if ( opr == ' / ' ) res /= value ( opd ) ; else return - 1 ; } return res ; } public static void main ( String [ ] args ) { String expr1 = "1 + 2*5 + 3" ; int res = evaluate ( expr1 ) ; if ( res == - 1 ) System . out . println ( expr1 + " ▁ is ▁ Invalid " ) ; else System . out . println ( " Value ▁ of ▁ " + expr1 + " ▁ is ▁ " + res ) ; String expr2 = "1 + 2*3" ; res = evaluate ( expr2 ) ; if ( res == - 1 ) System . out . println ( expr2 + " ▁ is ▁ Invalid " ) ; else System . out . println ( " Value ▁ of ▁ " + expr2 + " ▁ is ▁ " + res ) ; String expr3 = "4-2 + 6*3" ; res = evaluate ( expr3 ) ; if ( res == - 1 ) System . out . println ( expr3 + " ▁ is ▁ Invalid " ) ; else System . out . println ( " Value ▁ of ▁ " + expr3 + " ▁ is ▁ " + res ) ; String expr4 = "1 + + 2" ; res = evaluate ( expr4 ) ; if ( res == - 1 ) System . out . println ( expr4 + " ▁ is ▁ Invalid " ) ; else System . out . println ( " Value ▁ of ▁ " + expr4 + " ▁ is ▁ " + res ) ; } }
class Test { static void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; System . out . print ( f1 + " ▁ " ) ; for ( i = 1 ; i < n ; i ++ ) { System . out . print ( f2 + " ▁ " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } } public static void main ( String [ ] args ) { printFibonacciNumbers ( 7 ) ; } }
class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; } public static void main ( String [ ] args ) { int a = 15 , b = 20 ; System . out . println ( " LCM ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + lcm ( a , b ) ) ; } }
class GFG { static void convert_to_words ( char [ ] num ) { int len = num . length ; if ( len == 0 ) { System . out . println ( " empty ▁ string " ) ; return ; } if ( len > 4 ) { System . out . println ( " Length ▁ more ▁ than ▁ 4 ▁ is ▁ not ▁ supported " ) ; return ; } String [ ] single_digits = new String [ ] { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String [ ] two_digits = new String [ ] { " " , " ten " , " eleven " , " twelve " , " thirteen " , " fourteen " , " fifteen " , " sixteen " , " seventeen " , " eighteen " , " nineteen " } ; String [ ] tens_multiple = new String [ ] { " " , " " , " twenty " , " thirty " , " forty " , " fifty " , " sixty " , " seventy " , " eighty " , " ninety " } ; String [ ] tens_power = new String [ ] { " hundred " , " thousand " } ; System . out . print ( String . valueOf ( num ) + " : ▁ " ) ; if ( len == 1 ) { System . out . println ( single_digits [ num [ 0 ] - '0' ] ) ; return ; } int x = 0 ; while ( x < num . length ) { if ( len >= 3 ) { if ( num [ x ] - '0' != 0 ) { System . out . print ( single_digits [ num [ x ] - '0' ] + " ▁ " ) ; System . out . print ( tens_power [ len - 3 ] + " ▁ " ) ; } -- len ; } else { if ( num [ x ] - '0' == 1 ) { int sum = num [ x ] - '0' + num [ x + 1 ] - '0' ; System . out . println ( two_digits [ sum ] ) ; return ; } else if ( num [ x ] - '0' == 2 && num [ x + 1 ] - '0' == 0 ) { System . out . println ( " twenty " ) ; return ; } else { int i = ( num [ x ] - '0' ) ; if ( i > 0 ) System . out . print ( tens_multiple [ i ] + " ▁ " ) ; else System . out . print ( " " ) ; ++ x ; if ( num [ x ] - '0' != 0 ) System . out . println ( single_digits [ num [ x ] - '0' ] ) ; } } ++ x ; } } public static void main ( String [ ] args ) { convert_to_words ( "9923" . toCharArray ( ) ) ; convert_to_words ( "523" . toCharArray ( ) ) ; convert_to_words ( "89" . toCharArray ( ) ) ; convert_to_words ( "8" . toCharArray ( ) ) ; } }
class GFG { static int MAX = 11 ; static boolean isMultipleof5 ( int n ) { char str [ ] = new char [ MAX ] ; int len = str . length ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) System . out . println ( n + " ▁ is ▁ multiple ▁ " + " of ▁ 5" ) ; else System . out . println ( n + " ▁ is ▁ not ▁ a ▁ " + " multiple ▁ of ▁ 5" ) ; } }
import java . io . * ; class GFG { static int pairORSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; System . out . println ( pairORSum ( arr , n ) ) ; } }
class GFG { static long multiplyByFifteen ( long n ) { long prod = ( n << 4 ) ; prod = prod - n ; return prod ; } public static void main ( String [ ] args ) { long n = 7 ; System . out . print ( multiplyByFifteen ( n ) ) ; } }
class GFG { static void minAND ( int [ ] arr , int n ) { int s = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } System . out . println ( s ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 } ; int n = arr . length ; minAND ( arr , n ) ; } }
class GFG { static boolean check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) return true ; return false ; } public static void main ( String [ ] args ) { int a [ ] = { 0 , 1 , 0 , 1 } ; int n = a . length ; if ( check ( a , n ) == true ) System . out . println ( "YESNEW_LINE") ; else System . out . println ( "NONEW_LINE"); } }
class GFG { static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void findArray ( int [ ] q , int n ) { int ans ; int [ ] arr = new int [ n ] ; for ( int k = 0 , j = 0 ; j < n / 4 ; j ++ ) { ans = q [ k ] ^ q [ k + 3 ] ; arr [ k + 1 ] = q [ k + 1 ] ^ ans ; arr [ k + 2 ] = q [ k + 2 ] ^ ans ; arr [ k ] = q [ k ] ^ ( ( arr [ k + 1 ] ) ^ ( arr [ k + 2 ] ) ) ; arr [ k + 3 ] = q [ k + 3 ] ^ ( arr [ k + 1 ] ^ arr [ k + 2 ] ) ; k += 4 ; } printArray ( arr , n ) ; } public static void main ( String args [ ] ) { int [ ] q = { 4 , 1 , 7 , 0 } ; int n = q . length ; findArray ( q , n ) ; } }
import java . io . * ; class GFG { static boolean isEqualBlock ( int n ) { int first_bit = n % 2 ; int first_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit && n > 0 ) { n = n / 2 ; first_count ++ ; } if ( n == 0 ) return false ; while ( n > 0 ) { first_bit = n % 2 ; int curr_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit ) { n = n / 2 ; curr_count ++ ; } if ( curr_count != first_count ) return false ; } return true ; } public static void main ( String [ ] args ) { int n = 51 ; if ( isEqualBlock ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; System . out . println ( first_3 + " ▁ " + last_3 ) ; } public static void main ( String args [ ] ) { int n = 86 ; binToDecimal3 ( n ) ; } }
import java . util . * ; class GFG { static boolean isPowerOfTwo ( int x ) { if ( x == 0 ) return false ; if ( ( x & ( x - 1 ) ) == 0 ) return true ; else return false ; } static int countNum ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) || isPowerOfTwo ( a [ i ] + 1 ) ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 6 , 9 , 3 , 1 } ; int n = arr . length ; System . out . println ( countNum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static boolean checkEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; parity ++ ; } if ( parity % 2 == 0 ) return true ; else return false ; } static long sumlist ( int a [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkEvenParity ( a [ i ] ) ) sum += a [ i ] ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 3 , 5 , 9 } ; int n = arr . length ; System . out . println ( sumlist ( arr , n ) ) ; } }
class GFG { static int findOddPair ( int A [ ] , int N ) { int oddPair = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; } public static void main ( String [ ] args ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = A . length ; System . out . println ( findOddPair ( A , N ) ) ; } }
import java . io . * ; class GFG { static int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] ^ A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; } public static void main ( String [ ] args ) { int A [ ] = { 5 , 4 , 7 , 2 , 1 } ; int N = A . length ; System . out . println ( findevenPair ( A , N ) ) ; } }
import java . io . * ; class GFG { static int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 != 0 ) count ++ ; } int totalPairs = ( N * ( N - 1 ) / 2 ) ; int oddEvenPairs = count * ( N - count ) ; return totalPairs - oddEvenPairs ; } public static void main ( String [ ] args ) { int a [ ] = { 5 , 4 , 7 , 2 , 1 } ; int n = a . length ; System . out . println ( findEvenPair ( a , n ) ) ; } }
import java . io . * ; class GFG { static int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; } public static void main ( String [ ] args ) { int [ ] a = { 5 , 1 , 3 , 2 } ; int n = a . length ; System . out . println ( findevenPair ( a , n ) ) ; } }
import java . io . * ; class GFG { static int findevenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; } public static void main ( String [ ] args ) { int a [ ] = { 5 , 1 , 3 , 2 } ; int n = a . length ; System . out . print ( findevenPair ( a , n ) ) ; } }
import java . io . * ; class GFG { static int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; } public static void main ( String [ ] args ) { int X = 4 ; System . out . println ( " Required ▁ Number ▁ is ▁ : ▁ " + calculate ( X ) ) ; } }
import java . io . * ; class GFG { static void ReplaceElements ( int arr [ ] , int n ) { int X = 0 ; for ( int i = 0 ; i < n ; ++ i ) { X ^= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = X ^ arr [ i ] ; } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 3 , 5 , 5 } ; int n = arr . length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
class GFG { static int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; } public static void main ( String [ ] args ) { int a = - 10 ; int b = 15 ; int x = a ; System . out . print ( " x ▁ is ▁ : ▁ " + x ) ; x = alternate ( a , b , x ) ; System . out . print ( " After exchange "); System . out . print ( " x is : " + x); } }
import java . io . * ; class GFG { static int countZeros ( int x ) { int y ; int n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; } public static void main ( String [ ] args ) { int x = 101 ; System . out . println ( countZeros ( x ) ) ; } }
class GFG { static void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) System . out . print ( " Equal "); else if ( ( x & ( ~ y ) ) > y ) System . out . print ( y ) ; else System . out . print ( x ) ; } public static void main ( String [ ] args ) { int x = 10 , y = 16 ; LeadingZeros ( x , y ) ; } }
import java . io . * ; class GFG { static void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } System . out . println ( " Number ▁ of ▁ different ▁ bits ▁ : ▁ " + count ) ; } public static void main ( String [ ] args ) { int A = 12 , B = 15 ; solve ( A , B ) ; } }
public class GFG { static int setRightmostUnsetBit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 21 ; System . out . println ( setRightmostUnsetBit ( n ) ) ; } }
public class GFG { static int AND ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; System . out . println ( AND ( a , n ) ) ; } }
import java . util . * ; class GFG { static void TwoscomplementbyXOR ( String str ) { int n = str . length ( ) ; boolean check_bit = false ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '0' && check_bit == false ) { continue ; } else { if ( check_bit == true ) { if ( str . charAt ( i ) == '0' ) str = str . substring ( 0 , i ) + '1' + str . substring ( i + 1 ) ; else str = str . substring ( 0 , i ) + '0' + str . substring ( i + 1 ) ; } check_bit = true ; } } if ( check_bit == false ) { System . out . println ( "1" + str ) ; } else System . out . println ( str ) ; } public static void main ( String [ ] args ) { String str = "101" ; TwoscomplementbyXOR ( str ) ; } }
class GFG { static boolean bitsAreInAltPatrnInGivenTRange ( int n , int l , int r ) { int num , prev , curr ; num = n >> ( l - 1 ) ; prev = num & 1 ; num = num >> 1 ; for ( int i = 1 ; i <= ( r - l ) ; i ++ ) { curr = num & 1 ; if ( curr == prev ) return false ; prev = curr ; num = num >> 1 ; } return true ; } public static void main ( String [ ] args ) { int n = 18 ; int l = 1 , r = 3 ; if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static long increment ( long i ) { i = - ( ~ i ) ; return i ; } public static void main ( String [ ] args ) { long n = 3 ; System . out . print ( increment ( n ) ) ; } }
class GFG { static int bit_count ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; } static int maxsum ( int [ ] arr , int n ) { int [ ] bits = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { bits [ i ] = bit_count ( arr [ i ] ) ; } int [ ] sum = new int [ 32 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum [ bits [ i ] ] += arr [ i ] ; } int maximum = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { maximum = Math . max ( sum [ i ] , maximum ) ; } return maximum ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 8 , 5 , 6 , 7 } ; int n = arr . length ; System . out . println ( maxsum ( arr , n ) ) ; } }
class GFG { static int xorPairSum ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( xorPairSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; } public static void main ( String [ ] args ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = A . length ; System . out . println ( findEvenPair ( A , N ) ) ; } }
class GFG { static boolean allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 17 ; int l = 2 , r = 4 ; if ( allBitsSetInTheGivenRange ( n , l , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static boolean checkSame ( int n ) { int set = 0 ; int unset = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 12 ; if ( checkSame ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; class GFG { static void KthCharacter ( int m , int n , int k ) { int distance = ( int ) Math . pow ( 2 , n ) ; int Block_number = k / distance ; int remaining = k % distance ; int s [ ] = new int [ 32 ] ; int x = 0 ; for ( ; m > 0 ; x ++ ) { s [ x ] = m % 2 ; m = m / 2 ; } int root = s [ x - 1 - Block_number ] ; if ( remaining == 0 ) { System . out . println ( root ) ; return ; } Boolean flip = true ; while ( remaining > 1 ) { if ( ( remaining & 1 ) > 0 ) { flip = ! flip ; } remaining = remaining >> 1 ; } if ( flip ) { System . out . println ( ( root > 0 ) ? 0 : 1 ) ; } else { System . out . println ( root ) ; } } public static void main ( String [ ] args ) { int m = 5 , k = 5 , n = 3 ; KthCharacter ( m , n , k ) ; } }
class GFG { static boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; } public static void main ( String [ ] args ) { int n = 9 ; if ( onlyFirstAndLastAreSet ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int getInteger ( int L , int R ) { int number = 0 ; for ( int i = L ; i <= R ; i ++ ) number += Math . pow ( 2 , i ) ; return number ; } public static void main ( String [ ] args ) { int L = 2 , R = 5 ; System . out . println ( getInteger ( L , R ) ) ; } }
import java . io . * ; class GFG { static int setbitsfromLtoR ( int L , int R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; } public static void main ( String [ ] args ) { int L = 2 , R = 5 ; System . out . println ( setbitsfromLtoR ( L , R ) ) ; } }
import java . io . * ; class GFG { static int findXor ( int arr [ ] , int n ) { int xoR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 6 } ; int n = arr . length ; System . out . println ( findXor ( arr , n ) ) ; } }
class GFG { static void printOdds ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; int set_bit = res & ( ~ ( res - 1 ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit ) != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( x + " ▁ " + y ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 3 , 4 , 4 , 5 } ; int n = arr . length ; printOdds ( arr , n ) ; } }
import java . util . * ; class GFG { static void subsetBitwiseORk ( int arr [ ] , int n , int k ) { ArrayList < Integer > v = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] k ) == k ) { v . add ( arr [ i ] ) ; } } int ans = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) ans = ans | v . get ( i ) ; if ( ans != k ) { System . out . println ( " Subset ▁ does " + " ▁ not ▁ exist " ) ; return ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( v . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int k = 3 ; int arr [ ] = { 1 , 4 , 2 } ; int n = arr . length ; subsetBitwiseORk ( arr , n , k ) ; } }
import java . io . * ; class GFG { static int findEletobeInserted ( int A [ ] , int n , int k ) { int ans = k ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = A . length ; int k = 10 ; System . out . println ( findEletobeInserted ( A , n , k ) + " ▁ has ▁ to ▁ be ▁ inserted ▁ in ▁ " + " the ▁ given ▁ array ▁ to ▁ make " + " ▁ xor ▁ sum ▁ of ▁ " + k ) ; } }
class GFG { static final int BITS = 32 ; static int andSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } int subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 } ; int size = 3 ; System . out . println ( andSum ( arr , size ) ) ; } }
import java . io . * ; class GFG { static long _popcnt32 ( long n ) { long count = 0 ; while ( n != 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; } static long maximize ( long a ) { long n = _popcnt32 ( a ) ; if ( n == 32 ) return a ; long res = ( 1 << n ) - 1 ; return ( res << ( 32 - n ) ) ; } public static void main ( String args [ ] ) { long a = 3 ; System . out . print ( maximize ( a ) ) ; } }
class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } public static void main ( String [ ] args ) { int i = 3 ; System . out . print ( countSetBits ( i ) ) ; } }
class GFG { static boolean isEven ( int n ) { boolean isEven = true ; for ( int i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; } public static void main ( String args [ ] ) { int n = 101 ; if ( isEven ( n ) ) System . out . println ( " Even " ) ; else System . out . println ( " Odd " ) ; } }
class GFG { static boolean isEven ( int n ) { return ( ( n / 2 ) * 2 == n ) ; } public static void main ( String [ ] args ) { int n = 101 ; if ( isEven ( n ) != false ) System . out . print ( " Even " ) ; else System . out . print ( " Odd " ) ; } }
import java . io . * ; class GFG { static int add ( int x , int y ) { int keep = ( x & y ) << 1 ; int res = x ^ y ; if ( keep == 0 ) return res ; return add ( keep , res ) ; } public static void main ( String [ ] args ) { System . out . println ( add ( 15 , 38 ) ) ; } }
import java . io . * ; class GFG { static boolean checkValidPair ( int num1 , int num2 ) { String s1 = Integer . toString ( num1 ) ; String s2 = Integer . toString ( num2 ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) for ( int j = 0 ; j < s2 . length ( ) ; j ++ ) if ( s1 . charAt ( i ) == s2 . charAt ( j ) ) return true ; return false ; } static int countPairs ( int [ ] arr , int n ) { int numberOfPairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( checkValidPair ( arr [ i ] , arr [ j ] ) ) numberOfPairs ++ ; return numberOfPairs ; } public static void main ( String args [ ] ) { int [ ] arr = new int [ ] { 10 , 12 , 24 } ; int n = arr . length ; System . out . print ( countPairs ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int NUM_BITS = 32 ; static boolean isPowerOf2 ( int num ) { if ( num != 0 && ( num & ( num - 1 ) ) == 0 ) return true ; return false ; } static boolean checkSubsequence ( int [ ] arr , int n ) { if ( n == 1 ) return isPowerOf2 ( arr [ 0 ] ) ; int total = 0 ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) total = total | ( 1 << i ) ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) { int ans = total ; for ( int j = 0 ; j < n ; j ++ ) { int p = arr [ j ] & ( 1 << i ) ; if ( p == 0 ) ans = ans & arr [ j ] ; } if ( isPowerOf2 ( ans ) ) return true ; } return false ; } public static void main ( String args [ ] ) { int [ ] arr = { 12 , 13 , 7 } ; int n = arr . length ; if ( checkSubsequence ( arr , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static String findWinner ( int A [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " Alice " ; else return " Bob " ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 4 , 3 , 5 } ; int n = A . length ; System . out . print ( " Winner ▁ = ▁ " + findWinner ( A , n ) ) ; } }
class GFG { static boolean isFibbinaryNum ( int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 10 ; if ( isFibbinaryNum ( n ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . lang . * ; class GFG { static int maxXOR ( int n , int k ) { int c = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; } public static void main ( String [ ] args ) { int n = 12 ; int k = 3 ; System . out . println ( maxXOR ( n , k ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static long divide ( long dividend , long divisor ) { long sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1L << i ; } } if ( sign == - 1 ) quotient = - quotient ; return quotient ; } public static void main ( String args [ ] ) { int a = 10 , b = 3 ; System . out . println ( divide ( a , b ) ) ; int a1 = 43 , b1 = - 8 ; System . out . println ( divide ( a1 , b1 ) ) ; } }
import java . io . * ; class GFG { static int count ( int n ) { int c = 0 ; while ( n != 0 ) { c ++ ; n = n >> 1 ; } return c ; } static int XOR ( int a , int b ) { int c = Math . min ( a , b ) ; int d = Math . max ( a , b ) ; if ( count ( c ) < count ( d ) ) c = c << ( count ( d ) - count ( c ) ) ; return ( c ^ d ) ; } public static void main ( String args [ ] ) { int a = 13 , b = 5 ; System . out . println ( XOR ( a , b ) ) ; } }
import java . util . * ; class GFG { static int swapBitsInPair ( int x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; } public static void main ( String [ ] args ) { int x = 4 ; System . out . print ( swapBitsInPair ( x ) ) ; } }
import java . io . * ; class GFG { static int setevenbits ( int n ) { int temp = n ; int count = 0 ; int res = 0 ; for ( temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n & res ) ; } static int setoddbits ( int m ) { int count = 0 ; int res = 0 ; for ( int temp = m ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( m & res ) ; } static int getAlternateBits ( int n , int m ) { int tempn = setevenbits ( n ) ; int tempm = setoddbits ( m ) ; return ( tempn tempm ) ; } public static void main ( String [ ] args ) { int n = 10 ; int m = 11 ; System . out . println ( getAlternateBits ( n , m ) ) ; } }
import java . io . * ; class GFG { static boolean isDivisibleBy10 ( char bin [ ] , int n ) { if ( bin [ n - 1 ] == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin [ i ] == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; } static boolean isDivisibleBy20 ( char bin [ ] , int n ) { if ( bin [ n - 1 ] == '1' ) return false ; return isDivisibleBy10 ( bin , n - 1 ) ; } public static void main ( String args [ ] ) { char bin [ ] = "101000" . toCharArray ( ) ; int n = bin . length ; if ( isDivisibleBy20 ( bin , n - 1 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int toggleBits ( int n1 , int n2 ) { return ( n1 ^ n2 ) ; } public static void main ( String args [ ] ) { int n1 = 2 , n2 = 5 ; System . out . println ( toggleBits ( n1 , n2 ) ) ; } }
import java . io . * ; class GFG { static int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; } public static void main ( String args [ ] ) { int n = 11 ; System . out . println ( evenbittogglenumber ( n ) ) ; } }
import java . io . * ; class GFG { static int takeLandFsetbits ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 1 ) + 1 ; } static int toggleFandLbits ( int n ) { if ( n == 1 ) return 0 ; return n ^ takeLandFsetbits ( n ) ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( toggleFandLbits ( n ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static boolean checkOdious ( int n ) { return ( countSetBits ( n ) % 2 == 1 ) ; } public static void main ( String args [ ] ) { int num = 32 ; if ( checkOdious ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int setleftmostunsetbit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = 0 ; for ( int temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( setleftmostunsetbit ( n ) ) ; } }
public class Main { static int maxXorSum ( int n , int k ) { if ( k == 1 ) return n ; int res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; } public static void main ( String [ ] args ) { int n = 4 , k = 3 ; System . out . print ( maxXorSum ( n , k ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int getPosOfRightmostSetBit ( int n ) { return ( int ) ( Math . log ( n & - n ) / Math . log ( 2 ) ) ; } static int toggleLastKBits ( int n , int k ) { int num = ( 1 << k ) - 1 ; return ( n ^ num ) ; } static int incrementByOne ( int n ) { int k = getPosOfRightmostSetBit ( ~ n ) ; n = ( ( 1 << k ) n ) ; if ( k != 0 ) n = toggleLastKBits ( n , k ) ; return n ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( incrementByOne ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int xnor ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a == 0 && b == 0 ) return 1 ; int a_rem = 0 ; int b_rem = 0 ; int count = 0 ; int xnornum = 0 ; while ( true ) { a_rem = a & 1 ; b_rem = b & 1 ; if ( a_rem == b_rem ) xnornum |= ( 1 << count ) ; count ++ ; a = a >> 1 ; b = b >> 1 ; if ( a < 1 ) break ; } return xnornum ; } public static void main ( String argc [ ] ) { int a = 10 , b = 50 ; System . out . println ( xnor ( a , b ) ) ; } }
import java . io . * ; class GFG { static int togglebit ( int n ) { if ( n == 0 ) return 1 ; int i = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return i ^ n ; } static int xnor ( int num1 , int num2 ) { if ( num1 < num2 ) { int temp = num1 ; num1 = num2 ; num2 = temp ; } num1 = togglebit ( num1 ) ; return num1 ^ num2 ; } public static void main ( String [ ] args ) { int a = 10 , b = 20 ; System . out . println ( xnor ( a , b ) ) ; } }
class GFG { static void MaximumSum ( int a [ ] , int b [ ] , int n ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } System . out . println ( sum1 + sum2 ) ; } public static void main ( String arg [ ] ) { int A [ ] = { 1 , 2 , 4 , 3 , 2 } ; int B [ ] = { 2 , 3 , 3 , 12 , 1 } ; int n = A . length ; MaximumSum ( A , B , n ) ; } }
import java . io . * ; import java . util . * ; class GFG { static boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; } static boolean differAtOneBitPos ( int a , int b ) { return isPowerOfTwo ( a ^ b ) ; } public static void main ( String args [ ] ) { int a = 13 , b = 9 ; if ( differAtOneBitPos ( a , b ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static long power2 ( long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 2 ; return power2 ( n / 2 ) * power2 ( n / 2 ) ; } static long multiply ( long x , long n ) { return x * power2 ( n ) ; } public static void main ( String [ ] args ) { long x = 70 , n = 2 ; System . out . println ( multiply ( x , n ) ) ; } }
import java . util . * ; class GFG { static long multiply ( long x , long n ) { return x << n ; } public static void main ( String [ ] args ) { long x = 70 , n = 2 ; System . out . println ( multiply ( x , n ) ) ; } }
import java . util . * ; class GFG { static boolean isDivBy2PowerM ( int n , int m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 8 , m = 2 ; if ( isDivBy2PowerM ( n , m ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static int findWinner ( int N ) { return N & 1 ; } public static void main ( String [ ] args ) { int N = 15 ; if ( findWinner ( N ) == 1 ) System . out . println ( " Player ▁ A " ) ; else System . out . println ( " Player ▁ B " ) ; } }
import java . io . * ; class GFG { static int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; } public static void main ( String args [ ] ) { int n = 11 ; System . out . println ( evenbittogglenumber ( n ) ) ; } }
import java . io . * ; public class GFG { static void divide ( int n , int m ) { System . out . println ( " Remainder ▁ = ▁ " + ( ( n ) & ( m - 1 ) ) ) ; System . out . println ( " Quotient ▁ = ▁ " + ( n >> ( int ) ( Math . log ( m ) / Math . log ( 2 ) ) ) ) ; } static public void main ( String [ ] args ) { int n = 43 , m = 8 ; divide ( n , m ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { static int maxAND ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = res > ( arr [ i ] & arr [ j ] ) ? res : ( arr [ i ] & arr [ j ] ) ; return res ; } public static void main ( String argc [ ] ) { int arr [ ] = { 4 , 8 , 6 , 2 } ; int n = arr . length ; System . out . println ( " Maximum ▁ AND ▁ Value ▁ = ▁ " + maxAND ( arr , n ) ) ; } }
class GFG { static int index ( int i ) { return 1 + ( i >> 31 ) - ( - i >> 31 ) ; } static void check ( int n ) { String s [ ] = { " negative " , " zero " , " positive " } ; int val = index ( n ) ; System . out . println ( n + " ▁ is ▁ " + s [ val ] ) ; } public static void main ( String [ ] args ) { check ( 30 ) ; check ( - 20 ) ; check ( 0 ) ; } }
import java . io . * ; class GFG { static boolean checking ( String s ) { int c = 0 ; int n = s . length ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '0' ) c ++ ; if ( c >= 6 && s . charAt ( i ) == '1' ) return true ; } return false ; } public static void main ( String [ ] args ) { String s = "100010001" ; if ( checking ( s ) ) System . out . println ( " Possible " ) ; else System . out . println ( " Not ▁ possible " ) ; } }
import java . io . * ; class GFG { public static int modifyBit ( int n , int p , int b ) { int mask = 1 << p ; return ( n & ~ mask ) | ( ( b << p ) & mask ) ; } public static void main ( String [ ] args ) { System . out . println ( modifyBit ( 6 , 2 , 0 ) ) ; System . out . println ( modifyBit ( 6 , 5 , 1 ) ) ; } }
class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static int countSetBitsInGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return countSetBits ( n & num ) ; } public static void main ( String [ ] args ) { int n = 42 ; int l = 2 , r = 5 ; System . out . print ( countSetBitsInGivenRange ( n , l , r ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static boolean areAllBitsSet ( long n ) { if ( n == 0 ) return false ; if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } public static boolean isOnesComplementOfOther ( long a , long b ) { return areAllBitsSet ( a ^ b ) ; } public static void main ( String argc [ ] ) { long a = 10 , b = 5 ; if ( isOnesComplementOfOther ( a , b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int findUnique ( int a [ ] , int n , int k ) { byte sizeof_int = 4 ; int INT_SIZE = 8 * sizeof_int ; int count [ ] = new int [ INT_SIZE ] ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; int res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; } public static void main ( String [ ] args ) { int a [ ] = { 6 , 2 , 5 , 2 , 2 , 6 , 6 } ; int n = a . length ; int k = 3 ; System . out . println ( findUnique ( a , n , k ) ) ; } }
import java . util . * ; class GFG { static boolean powerOfTwo ( int n ) { return ( ( n & n - 1 ) == 0 ) ; } static boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; return powerOfTwo ( n - 1 ) ; } public static void main ( String [ ] args ) { int n = Integer . parseUnsignedInt ( "9" ) ; if ( onlyFirstAndLastAreSet ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class AlternateSetBits { static boolean allBitsAreSet ( int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } static boolean bitsAreInAltOrder ( int n ) { int num = n ^ ( n >>> 1 ) ; return allBitsAreSet ( num ) ; } public static void main ( String args [ ] ) { int n = 10 ; if ( bitsAreInAltOrder ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static int setBit ( int xorValue ) { int count = 0 ; while ( xorValue >= 1 ) { if ( xorValue % 2 == 1 ) count ++ ; xorValue /= 2 ; } return count ; } static int minFlip ( int n , int k ) { int size = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; int max = ( int ) Math . pow ( 2 , k ) - 1 ; max = max << ( size - k ) ; int xorValue = ( n ^ max ) ; return ( setBit ( xorValue ) ) ; } public static void main ( String [ ] args ) { int n = 27 , k = 3 ; System . out . println ( " Min ▁ Flips ▁ = ▁ " + minFlip ( n , k ) ) ; } }
import java . util . * ; class GFG { static int setallbitgivenrange ( int n , int l , int r ) { int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; } public static void main ( String [ ] args ) { int n = 17 , l = 2 , r = 3 ; System . out . println ( setallbitgivenrange ( n , l , r ) ) ; } }
import java . io . * ; class GFG { static int countBits ( int number ) { return ( int ) ( Math . log ( number ) / Math . log ( 2 ) + 1 ) ; } public static void main ( String [ ] args ) { int num = 65 ; System . out . println ( countBits ( num ) ) ; } }
import java . io . * ; class GFG { static String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return " Yes " ; return " No " ; } public static void main ( String [ ] args ) { int n = 17 ; int l = 2 ; int r = 4 ; System . out . println ( allBitsSetInTheGivenRange ( n , l , r ) ) ; } }
class GFG { static int setAllBitsAfterMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; } static int toggle ( int n ) { n = n ^ setAllBitsAfterMSB ( n ) ; return n ; } public static void main ( String arg [ ] ) { int n = 10 ; n = toggle ( n ) ; System . out . print ( n ) ; } }
class GFG { static int getRightMostSetBit ( int n ) { return ( int ) ( ( Math . log ( n & - n ) ) / ( Math . log ( 2 ) ) ) + 1 ; } static int posOfRightMostSameBit ( int m , int n ) { return getRightMostSetBit ( ~ ( m ^ n ) ) ; } public static void main ( String [ ] args ) { int m = 16 , n = 7 ; System . out . print ( " Position ▁ = ▁ " + posOfRightMostSameBit ( m , n ) ) ; } }
class GFG { static String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return " Yes " ; return " No " ; } public static void main ( String [ ] args ) { int n = 22 ; int l = 2 , r = 3 ; System . out . print ( allBitsSetInTheGivenRange ( n , l , r ) ) ; } }
import java . util . * ; class GFG { static void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 3 ; printNonConsecutive ( n ) ; } }
class GFG { static int INT_SIZE = 32 ; static int constructNthNumber ( int group_no , int aux_num , int op ) { int a [ ] = new int [ INT_SIZE ] ; int num = 0 , len_f ; int i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num > 0 ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; } static int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 == 1 ) else aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . printf ( " % d " , getNthNumber ( n ) ) ; } }
public class Main { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( countSetBits ( i ) == 2 ) sum += i ; return sum ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( findSum ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; } public static void main ( String argc [ ] ) { int n = 107 ; int m = 4 ; n = toggleLastMBits ( n , m ) ; System . out . println ( n ) ; } }
class GFG { static int getFirstSetBitPos ( int n ) { return ( int ) ( Math . log ( n & - n ) / Math . log ( 2 ) ) + 1 ; } static int previousSmallerInteger ( int n ) { int pos = getFirstSetBitPos ( n ) ; return ( n & ~ ( 1 << ( pos - 1 ) ) ) ; } public static void main ( String [ ] args ) { int n = 25 ; System . out . print ( " Previous ▁ smaller ▁ Integer ▁ = " + previousSmallerInteger ( n ) ) ; } }
import java . io . * ; class GFG { static String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " No " ; n = n >> 1 ; } return " Yes " ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( areAllBitsSet ( n ) ) ; } }
import java . io . * ; class GFG { static String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( areAllBitsSet ( n ) ) ; } }
class GFG { static int getFirstSetBitPos ( int n ) { return ( ( int ) ( Math . log ( n & - n ) / Math . log ( 2 ) ) + 1 ) - 1 ; } static int nextGreaterWithOneMoreSetBit ( int n ) { int pos = getFirstSetBitPos ( ~ n ) ; if ( pos > - 1 ) return ( 1 << pos ) | n ; return ( ( n << 1 ) + 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . print ( " Next ▁ greater ▁ integer ▁ = ▁ " + nextGreaterWithOneMoreSetBit ( n ) ) ; } }
import java . io . * ; class GFG { static long CountZeroBit ( long x ) { long count = 0 ; while ( x > 0 ) { if ( ( x & 1L ) == 0 ) count ++ ; x >>= 1L ; } return count ; } static long CountXORandSumEqual ( long x ) { long count = CountZeroBit ( x ) ; return ( 1L << count ) ; } public static void main ( String [ ] args ) { long x = 10 ; System . out . println ( CountXORandSumEqual ( x ) ) ; } }
class GFG { static int missingNumber ( int arr1 [ ] , int arr2 [ ] , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 4 , 8 , 1 , 3 , 7 } ; int arr2 [ ] = { 7 , 4 , 3 , 1 } ; int n = arr1 . length ; System . out . println ( " Missing ▁ number ▁ = ▁ " + missingNumber ( arr1 , arr2 , n ) ) ; } }
class GFG { static int countValues ( int x ) { int count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x /= 2 ; } return count ; } public static void main ( String [ ] args ) { int x = 10 ; System . out . println ( countValues ( x ) ) ; } }
class GFG { static void constructXOR ( int A [ ] , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 4 , 1 , 3 , 5 } ; int n = A . length ; constructXOR ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; } }
import java . io . * ; class GFG { static int bitCount ( int n ) { int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) ++ count ; n >>= 1 ; } return count ; } static long countPairsWithKDiff ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int xoredNum = arr [ i ] ^ arr [ j ] ; if ( k == bitCount ( xoredNum ) ) ++ ans ; } } return ans ; } public static void main ( String [ ] args ) { int k = 2 ; int arr [ ] = { 2 , 4 , 1 , 3 , 1 } ; int n = arr . length ; System . out . println ( " Total ▁ pairs ▁ for ▁ k ▁ = ▁ " + k + " ▁ are ▁ " + countPairsWithKDiff ( arr , n , k ) + "NEW_LINE"); } }
class GFG { static int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m > 0 ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m /= 2 ; } return ans ; } public static void main ( String [ ] args ) { int n = 20 , m = 13 ; System . out . print ( multiply ( n , m ) ) ; } }
import java . util . * ; class solution { static boolean EqualNumber ( int A , int B ) { if ( ( A ^ B ) != 0 ) return true ; else return false ; } public static void main ( String args [ ] ) { int A = 5 , B = 6 ; if ( EqualNumber ( A , B ) == false ) System . out . println ( 1 ) ; else System . out . println ( 0 ) ; } }
import java . io . * ; class GFG { static boolean areSetBitsIncreasing ( int n ) { int prev_count = Integer . MAX_VALUE ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; } static public void main ( String [ ] args ) { int n = 10 ; if ( areSetBitsIncreasing ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class Test { static boolean findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( findPattern ( n ) ? " Yes " : " No " ) ; } }
class GFG { static int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; } public static void main ( String [ ] args ) { int n = 31 ; System . out . println ( countXOR ( n ) ) ; } }
class GFG { static int msbPos ( long n ) { int msb_p = - 1 ; while ( n > 0 ) { n = n >> 1 ; msb_p ++ ; } return msb_p ; } static long andOperator ( long x , long y ) { while ( x > 0 && y > 0 ) { int msb_p1 = msbPos ( x ) ; int msb_p2 = msbPos ( y ) ; if ( msb_p1 != msb_p2 ) break ; long msb_val = ( 1 << msb_p1 ) ; res = res + msb_val ; x = x - msb_val ; y = y - msb_val ; } return res ; } public static void main ( String [ ] args ) { long x = 10 , y = 15 ; System . out . print ( andOperator ( x , y ) ) ; } }
import java . util . * ; class GFG { public static int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; } public static void main ( String [ ] args ) { int n = 50 ; System . out . println ( multiplyTen ( n ) ) ; } }
import java . util . * ; class GFG { public static int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( countValues ( n ) ) ; } }
import java . util . * ; class GFG { public static int countValues ( int n ) { int unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( countValues ( n ) ) ; } }
import java . io . * ; class GFG { static char findProffesion ( int level , int pos ) { if ( level == 1 ) return ' e ' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' d ' ) return ( pos % 2 > 0 ) ? ' d ' : ' e ' ; return ( pos % 2 > 0 ) ? ' e ' : ' d ' ; } public static void main ( String [ ] args ) { int level = 4 , pos = 2 ; if ( findProffesion ( level , pos ) == ' e ' ) System . out . println ( " Engineer " ) ; else System . out . println ( " Doctor " ) ; } }
import java . io . * ; class GFG { static void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { System . out . print ( ( ( 1 << x ) + ( 1 << y ) ) + " ▁ " ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } } public static void main ( String [ ] args ) { int n = 4 ; printTwoSetBitNums ( n ) ; } }
class GFG { static int rand50 ( ) { return ( int ) ( 10 * Math . random ( ) ) & 1 ; } static int rand75 ( ) { return rand50 ( ) | rand50 ( ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( rand75 ( ) ) ; } } }
class GFG { static void printRepeatingEven ( int arr [ ] , int n ) { long _xor = 0L ; long pos ; for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; _xor ^= pos ; } for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; if ( ! ( ( pos & _xor ) != 0 ) ) { System . out . print ( arr [ i ] + " ▁ " ) ; _xor ^= pos ; } } } public static void main ( String args [ ] ) { int arr [ ] = { 9 , 12 , 23 , 10 , 12 , 12 , 15 , 23 , 14 , 12 , 15 } ; int n = arr . length ; printRepeatingEven ( arr , n ) ; } }
import java . io . * ; class GFG { static int countSetBits ( int x ) { int count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; } static boolean isBleak ( int n ) { for ( int x = 1 ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; } public static void main ( String args [ ] ) { if ( isBleak ( 3 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; if ( isBleak ( 4 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static final int INT_BITS = 32 ; static int maxSubarrayXOR ( int set [ ] , int n ) { int index = 0 ; for ( int i = INT_BITS - 1 ; i >= 0 ; i -- ) { int maxInd = index ; int maxEle = Integer . MIN_VALUE ; for ( int j = index ; j < n ; j ++ ) { if ( ( set [ j ] & ( 1 << i ) ) != 0 && set [ j ] > maxEle ) { maxEle = set [ j ] ; maxInd = j ; } } if ( maxEle == - 2147483648 ) continue ; int temp = set [ index ] ; set [ index ] = set [ maxInd ] ; set [ maxInd ] = temp ; maxInd = index ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != maxInd && ( set [ j ] & ( 1 << i ) ) != 0 ) set [ j ] = set [ j ] ^ set [ maxInd ] ; } index ++ ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= set [ i ] ; return res ; } public static void main ( String arg [ ] ) { int set [ ] = { 9 , 8 , 5 } ; int n = set . length ; System . out . print ( " Max ▁ subset ▁ XOR ▁ is ▁ " ) ; System . out . print ( maxSubarrayXOR ( set , n ) ) ; } }
import java . util . * ; class GFG { static int findXOR ( int Set [ ] , int n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; } public static void main ( String arg [ ] ) { int Set [ ] = { 1 , 2 , 3 } ; int n = Set . length ; System . out . print ( " XOR ▁ of ▁ XOR ' s ▁ of ▁ all ▁ subsets ▁ is ▁ " + findXOR ( Set , n ) ) ; } }
import java . io . * ; class GFG { static int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; } public static void main ( String [ ] args ) { int x = 3 , y = 5 ; System . out . println ( " XOR ▁ is ▁ " + ( myXOR ( x , y ) ) ) ; } }
import java . io . * ; import java . util . * ; import java . math . * ; class GFG { static int N = 2 ; static boolean freivald ( int a [ ] [ ] , int b [ ] [ ] , int c [ ] [ ] ) { int r [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) r [ i ] = ( int ) ( Math . random ( ) ) % 2 ; int br [ ] = new int [ N ] ; Arrays . fill ( br , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) br [ i ] = br [ i ] + b [ i ] [ j ] * r [ j ] ; int cr [ ] = new int [ N ] ; Arrays . fill ( cr , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) cr [ i ] = cr [ i ] + c [ i ] [ j ] * r [ j ] ; int axbr [ ] = new int [ N ] ; Arrays . fill ( axbr , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) axbr [ i ] = axbr [ i ] + a [ i ] [ j ] * br [ j ] ; for ( int i = 0 ; i < N ; i ++ ) if ( axbr [ i ] - cr [ i ] != 0 ) return false ; return true ; } static boolean isProduct ( int a [ ] [ ] , int b [ ] [ ] , int c [ ] [ ] , int k ) { for ( int i = 0 ; i < k ; i ++ ) if ( freivald ( a , b , c ) == false ) return false ; return true ; } public static void main ( String args [ ] ) { int a [ ] [ ] = { { 1 , 1 } , { 1 , 1 } } ; int b [ ] [ ] = { { 1 , 1 } , { 1 , 1 } } ; int c [ ] [ ] = { { 2 , 2 } , { 2 , 2 } } ; int k = 2 ; if ( isProduct ( a , b , c , k ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static float calc_Expectation ( float a [ ] , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; } public static void main ( String args [ ] ) { float expect , n = 6f ; float a [ ] = { 1f , 2f , 3f , 4f , 5f , 6f } ; expect = calc_Expectation ( a , n ) ; System . out . println ( " Expectation ▁ of ▁ array ▁ E ( X ) ▁ is ▁ : ▁ " + expect ) ; } }
class GFG { static void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? Math . min ( l1 , l2 ) : - 1 ; int y = ( r1 != r2 ) ? Math . max ( r1 , r2 ) : - 1 ; System . out . println ( x + " ▁ " + y ) ; } public static void main ( String [ ] args ) { int l1 = 5 , r1 = 10 , l2 = 1 , r2 = 7 ; findPoints ( l1 , r1 , l2 , r2 ) ; } }
class GFG { static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } public static void main ( String [ ] args ) { System . out . println ( fact ( 5 ) ) ; } }
import java . util . * ; class GFG { static void printElements ( int a [ ] , int n ) { Arrays . sort ( a ) ; a = reverse ( a ) ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] != a [ i + 1 ] ) { System . out . print ( a [ i ] + " ▁ occurs ▁ " + cnt + " timesNEW_LINE"); cnt = 1 ; } else cnt += 1 ; } System . out . print ( a [ n - 1 ] + " ▁ occurs ▁ " + cnt + " timesNEW_LINE"); } static int [ ] reverse ( int a [ ] ) { int i , n = a . length , t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 } ; int n = a . length ; printElements ( a , n ) ; } }
class GFG { static boolean checkIndices ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; } public static void main ( String args [ ] ) { int Arr [ ] = { 3 , 2 , 1 , 1 , 4 } ; int N = Arr . length ; if ( checkIndices ( Arr , N ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static void printPairs ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) System . out . println ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " ) ; } public static void main ( String [ ] arg ) { int arr [ ] = { 1 , 5 , 7 , - 1 , 5 } ; int n = arr . length ; int sum = 6 ; printPairs ( arr , n , sum ) ; } }
import java . io . * ; class GFG { static int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = arr . length ; System . out . println ( minSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = arr . length ; System . out . println ( minSum ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static boolean PandigitalProduct_1_9 ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 && isPandigital ( " " + n + i + n / i ) ) return true ; return false ; } public static boolean isPandigital ( String str ) { if ( str . length ( ) != 9 ) return false ; char ch [ ] = str . toCharArray ( ) ; Arrays . sort ( ch ) ; return new String ( ch ) . equals ( "123456789" ) ; } public static void main ( String [ ] args ) { int n = 6952 ; if ( PandigitalProduct_1_9 ( n ) == true ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; } }
import java . util . Arrays ; class GFG { static void printModeMedian ( int a [ ] , int n ) { int [ ] b = new int [ n ] ; int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int t = max + 1 ; int count [ ] = new int [ t ] ; for ( int i = 0 ; i < t ; i ++ ) { count [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { count [ a [ i ] ] ++ ; } int mode = 0 ; int k = count [ 0 ] ; for ( int i = 1 ; i < t ; i ++ ) { if ( count [ i ] > k ) { k = count [ i ] ; mode = i ; } } for ( int i = 1 ; i < t ; i ++ ) { count [ i ] = count [ i ] + count [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { b [ count [ a [ i ] ] - 1 ] = a [ i ] ; count [ a [ i ] ] -- ; } float median ; if ( n % 2 != 0 ) { median = b [ n / 2 ] ; } else { median = ( float ) ( ( b [ ( n - 1 ) / 2 ] + b [ ( n / 2 ) ] ) / 2.0 ) ; } System . out . println ( " median ▁ = ▁ " + median ) ; System . out . println ( " mode ▁ = ▁ " + mode ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 1 , 2 , 7 , 1 , 2 , 5 , 3 , 6 } ; int n = a . length ; printModeMedian ( a , n ) ; } }
import java . util . * ; import java . lang . * ; class GeeksforGeeks { final static int MAX = 26 ; static boolean function ( String str ) { int l = str . length ( ) ; int counter1 [ ] = new int [ MAX ] ; int counter2 [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { counter1 [ i ] = 0 ; counter2 [ i ] = 0 ; } for ( int i = 0 ; i < l / 2 ; i ++ ) counter1 [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = l / 2 ; i < l ; i ++ ) counter2 [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( counter2 [ i ] != counter1 [ i ] ) return true ; } return false ; } public static void main ( String args [ ] ) { String str = " abcasdsabcae " ; if ( function ( str ) ) System . out . print ( " Yes , ▁ both ▁ halves ▁ " + " differ ▁ by ▁ at ▁ least ▁ one ▁ character " ) ; else System . out . print ( " No , ▁ both ▁ halves ▁ " + " do ▁ not ▁ differ ▁ at ▁ all " ) ; } }
import java . util . Arrays ; class GFG { static int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 20 , 30 , 100 , 101 , 102 } ; int N = arr . length ; int K = 3 ; System . out . print ( minDifferenceAmongMaxMin ( arr , N , K ) ) ; } }
class ArrayIndex { static int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 3 , 5 , 2 , 3 , 4 , 3 , 1 , 5 } ; int n = arr . length ; int idxOfEle = 5 ; System . out . println ( getIndexInSortedArray ( arr , n , idxOfEle ) ) ; } }
class GFG { static int getMaxValue ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { return 0 ; } first = second = Integer . MIN_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } if ( second == Integer . MIN_VALUE ) { return 0 ; } else { return second ; } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 1 , 8 } ; int n = arr . length ; System . out . println ( getMaxValue ( arr , n ) ) ; } }
class GFG { static int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = ( a > b ) ? ( ( a > c ) ? a : c ) : ( ( b > c ) ? b : c ) ; int smallest = ( a < b ) ? ( ( a < c ) ? a : c ) : ( ( b < c ) ? b : c ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } return - 1 ; } public static void main ( String [ ] args ) { int a = - 2 , b = - 1 , c = - 4 ; System . out . print ( maximumResult ( a , b , c ) ) ; } }
import java . util . * ; class GFG { static int check ( int n , List < Integer > marks ) { Integer x = Collections . max ( marks ) ; int bonus = 100 - x ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks . get ( i ) + bonus >= 50 ) c += 1 ; } return c ; } public static void main ( String [ ] args ) { int n = 5 ; List < Integer > marks = Arrays . asList ( 0 , 21 , 83 , 45 , 64 ) ; System . out . println ( check ( n , marks ) ) ; } }
import java . io . * ; class GFG { static int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; } public static void main ( String [ ] args ) { int n = 11 , k = 2 ; System . out . println ( find_sum ( n , k ) ) ; } }
import java . util . * ; class Solution { static final int MAX = 10000 ; static int hashTable [ ] = new int [ MAX ] ; static int minOperations ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) hashTable [ arr [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashTable [ arr [ i ] ] != 0 ) { for ( int j = i ; j < n ; j ++ ) if ( arr [ j ] % arr [ i ] == 0 ) hashTable [ arr [ j ] ] = 0 ; res ++ ; } } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 } ; int n = arr . length ; System . out . print ( minOperations ( arr , n ) ) ; } }
import java . util . * ; class GFG { static boolean ifPossible ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 } ; int n = arr . length ; if ( ifPossible ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GfG { static int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } } public static void main ( String [ ] args ) { int a [ ] = { 10 , 30 , 40 , 50 , 20 } ; int k = 3 ; int n = a . length ; int dp [ ] = new int [ n ] ; Arrays . fill ( dp , - 1 ) ; System . out . println ( FindMinimumCost ( 0 , a , n , k , dp ) ) ; } }
class GFG { static final int MAX = 100000 ; static long prefix [ ] = new long [ MAX ] ; static void sieve_modified ( ) { for ( int i = 2 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( int i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; } static long sumEvenFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; } public static void main ( String args [ ] ) { sieve_modified ( ) ; int l = 6 , r = 10 ; System . out . print ( sumEvenFactors ( l , r ) ) ; } }
public class GFG { static final int N = 1000 ; static int find ( int index , int openbrk , int n , int dp [ ] [ ] , int adj [ ] ) { if ( openbrk < 0 ) { return 0 ; } if ( index == n ) { if ( openbrk == 0 ) { return 1 ; } else { return 0 ; } } if ( dp [ index ] [ openbrk ] != - 1 ) { return dp [ index ] [ openbrk ] ; } if ( adj [ index ] == 1 ) { dp [ index ] [ openbrk ] = find ( index + 1 , openbrk + 1 , n , dp , adj ) ; } else { dp [ index ] [ openbrk ] = find ( index + 1 , openbrk + 1 , n , dp , adj ) + find ( index + 1 , openbrk - 1 , n , dp , adj ) ; } return dp [ index ] [ openbrk ] ; } public static void main ( String [ ] args ) { int dp [ ] [ ] = new int [ N ] [ N ] ; int n = 2 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } int adj [ ] = { 1 , 0 , 0 , 0 } ; System . out . print ( find ( 0 , 0 , 2 * n , dp , adj ) ) ; } }
import java . io . * ; import java . lang . * ; public class GFG { static int ans ; static void findMaxValUtil ( int [ ] arr , int n , int num , int maxLimit , int ind ) { if ( ind == n ) { ans = Math . max ( ans , num ) ; return ; } if ( num - arr [ ind ] >= 0 ) { findMaxValUtil ( arr , n , num - arr [ ind ] , maxLimit , ind + 1 ) ; } if ( num + arr [ ind ] <= maxLimit ) { findMaxValUtil ( arr , n , num + arr [ ind ] , maxLimit , ind + 1 ) ; } } static int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) { int ind = 0 ; findMaxValUtil ( arr , n , num , maxLimit , ind ) ; return ans ; } public static void main ( String args [ ] ) { int num = 1 ; int [ ] arr = { 3 , 10 , 6 , 4 , 5 } ; int n = arr . length ; int maxLimit = 15 ; System . out . print ( findMaxVal ( arr , n , num , maxLimit ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static List < Integer > set1 = new ArrayList < Integer > ( ) ; static List < Integer > set2 = new ArrayList < Integer > ( ) ; static void printSets ( ) { int i ; for ( i = 0 ; i < set1 . size ( ) ; i ++ ) { System . out . print ( set1 . get ( i ) + " ▁ " ) ; } System . out . println ( ) ; for ( i = 0 ; i < set2 . size ( ) ; i ++ ) { System . out . print ( set2 . get ( i ) + " ▁ " ) ; } } static boolean findSets ( Integer [ ] arr , int n , int sum1 , int sum2 , int pos ) { if ( pos == n ) { if ( sum1 == sum2 ) { printSets ( ) ; return true ; } else return false ; } set1 . add ( arr [ pos ] ) ; boolean res = findSets ( arr , n , sum1 + arr [ pos ] , sum2 , pos + 1 ) ; if ( res == true ) return res ; set1 . remove ( set1 . size ( ) - 1 ) ; set2 . add ( arr [ pos ] ) ; res = findSets ( arr , n , sum1 , sum2 + arr [ pos ] , pos + 1 ) ; if ( res == false ) if ( set2 . size ( ) > 0 ) set2 . remove ( set2 . size ( ) - 1 ) ; return res ; } static boolean isPartitionPoss ( Integer [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; return findSets ( arr , n , 0 , 0 , 0 ) ; } public static void main ( String args [ ] ) { Integer [ ] arr = { 5 , 5 , 1 , 11 } ; int n = arr . length ; if ( isPartitionPoss ( arr , n ) == false ) { System . out . print ( " - 1" ) ; } } }
class GFG { static int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = Integer . MIN_VALUE ; int prefix_sum [ ] = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; } public static void main ( String [ ] args ) { int arr1 [ ] = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n1 = arr1 . length ; System . out . println ( maximumSumSubarray ( arr1 , n1 ) ) ; int arr2 [ ] = { 4 , - 8 , 9 , - 4 , 1 , - 8 , - 1 , 6 } ; int n2 = arr2 . length ; System . out . println ( maximumSumSubarray ( arr2 , n2 ) ) ; } }
class GFG { static final int DP_s = 9 ; static int getNumMonotone ( int len ) { int [ ] [ ] DP = new int [ len ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 0 ; i < len ; ++ i ) DP [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; } public static void main ( String [ ] args ) { System . out . println ( getNumMonotone ( 10 ) ) ; } }
import java . util . * ; class GFG { static int sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; int i ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( sequence ( n ) ) ; } }
import java . util . Arrays ; import java . util . Collections ; class GFG { static int lis ( int [ ] arr , int n ) { int [ ] mpis = new int [ n ] ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; for ( int k = 0 ; k < mpis . length ; k ++ ) { if ( mpis [ k ] > max ) { max = mpis [ k ] ; } } return max ; } static public void main ( String [ ] args ) { int [ ] arr = { 3 , 100 , 4 , 5 , 150 , 6 } ; int n = arr . length ; System . out . println ( lis ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int Hosoya ( int n , int m ) { if ( ( n == 0 && m == 0 ) || ( n == 1 && m == 0 ) || ( n == 1 && m == 1 ) || ( n == 2 && m == 1 ) ) return 1 ; if ( n > m ) return Hosoya ( n - 1 , m ) + Hosoya ( n - 2 , m ) ; else if ( m == n ) return Hosoya ( n - 1 , m - 1 ) + Hosoya ( n - 2 , m - 2 ) ; else return 0 ; } static void printHosoya ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) System . out . print ( Hosoya ( i , j ) + " ▁ " ) ; System . out . println ( " " ) ; } } public static void main ( String [ ] args ) { int n = 5 ; printHosoya ( n ) ; } }
import java . util . * ; class Eulerian { public static int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; } public static void main ( String [ ] args ) { int n = 3 , m = 1 ; System . out . print ( eulerian ( n , m ) ) ; } }
import java . util . Arrays ; class GFG { static int largestSubset ( int [ ] a , int n ) { int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 3 , 6 , 13 , 17 , 18 } ; int n = a . length ; System . out . println ( largestSubset ( a , n ) ) ; } }
import java . io . * ; class GFG { static int countFriendsPairings ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( countFriendsPairings ( n ) ) ; } }
class GFG { static int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( countFriendsPairings ( n ) ) ; } }
public class LCS_3Strings { static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; } public static void main ( String args [ ] ) { String X = " AGGT12" ; String Y = "12TXAYB " ; String Z = "12XBA " ; int m = X . length ( ) ; int n = Y . length ( ) ; int o = Z . length ( ) ; System . out . println ( " Length ▁ of ▁ LCS ▁ is ▁ " + lcsOf3 ( X , Y , Z , m , n , o ) ) ; } }
import java . io . * ; import java . util . * ; class LRS { static int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; } public static void main ( String [ ] args ) { String str = " aabb " ; System . out . println ( " The ▁ length ▁ of ▁ the ▁ largest ▁ subsequence ▁ that " + " ▁ repeats ▁ itself ▁ is ▁ : ▁ " + findLongestRepeatingSubSeq ( str ) ) ; } }
class GFG { static int numberOfPaths ( int m , int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; } public static void main ( String args [ ] ) { System . out . println ( numberOfPaths ( 3 , 3 ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int factorial ( int N ) { if ( N == 0 N == 1 ) return 1 ; return N * factorial ( N - 1 ) ; } static int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; } public static void main ( String args [ ] ) { int N = 6 ; System . out . println ( nthTerm ( N ) ) ; } }
class GFG { static boolean isFrequencyEqual ( String str , int len ) { if ( len % 2 == 1 ) { return false ; } int i , freq [ ] = new int [ 26 ] ; for ( i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == len / 2 ) { return true ; } } return false ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int len = str . length ( ) ; if ( isFrequencyEqual ( str , len ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class GFG { static final int MAX = 26 ; static int countMinimalReplacements ( char [ ] s ) { int n = s . length ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { cnt += 1 ; if ( i != ( n - 1 ) ) { for ( char it : "012" . toCharArray ( ) ) { if ( it != s [ i + 1 ] && it != s [ i - 1 ] ) { s [ i ] = it ; break ; } } } { for ( char it : "012" . toCharArray ( ) ) { if ( it != s [ i - 1 ] ) { s [ i ] = it ; break ; } } } } } return cnt ; } public static void main ( String [ ] args ) { String s = "201220211" ; System . out . println ( countMinimalReplacements ( s . toCharArray ( ) ) ) ; } }
public class GFG { static int nextIndex ( String str , int start , char c ) { for ( int i = start ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == c ) return i ; } return - 1 ; } static int countSubStrings ( String str ) { int i , n = str . length ( ) ; int countX [ ] = new int [ n ] ; int count = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ' x ' ) count ++ ; countX [ i ] = count ; } int nextIndexX = nextIndex ( str , 0 , ' x ' ) ; int nextIndexY = nextIndex ( str , 0 , ' y ' ) ; count = 0 ; while ( nextIndexX != - 1 && nextIndexY != - 1 ) { if ( nextIndexX > nextIndexY ) { nextIndexY = nextIndex ( str , nextIndexY + 1 , ' y ' ) ; continue ; } else { count += countX [ nextIndexY ] ; nextIndexX = nextIndex ( str , nextIndexX + 1 , ' x ' ) ; } } return count ; } public static void main ( String [ ] args ) { String s = " xyyxx " ; System . out . println ( countSubStrings ( s ) ) ; } }
class GFG { static String minimize ( String str ) { String mstr = " ▁ " ; int l , i , flagchar [ ] = new int [ 26 ] ; char ch ; l = str . length ( ) ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { ch = str . charAt ( i ) ; if ( flagchar [ ch - 97 ] == 0 ) { mstr = mstr + ch ; flagchar [ ch - 97 ] = 1 ; } } } static void replaceMinimizeUtil ( String str ) { String minimizedStr , finalStr = " " ; int i , index , l ; char ch ; l = str . length ( ) ; for ( i = 0 ; i < minimizedStr . length ( ) ; i ++ ) { ch = minimizedStr . charAt ( i ) ; index = ( ch * ch ) % l ; finalStr = finalStr + str . charAt ( index ) ; } System . out . println ( " Final ▁ String : ▁ " + finalStr ) ; } public static void main ( String [ ] args ) { String str = " geeks " ; replaceMinimizeUtil ( str ) ; } }
class LatinCipher { static void cipher ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! Character . isLetter ( str . charAt ( i ) ) && str . charAt ( i ) != ' ▁ ' ) { System . out . println ( " Enter ▁ only ▁ alphabets ▁ and ▁ space " ) ; return ; } } System . out . println ( " Encrypted ▁ Code ▁ using ▁ Latin ▁ Alphabet " ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { System . out . print ( str . charAt ( i ) - ' A ' + 1 + " ▁ " ) ; } else if ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) { System . out . print ( str . charAt ( i ) - ' a ' + 1 + " ▁ " ) ; } if ( str . charAt ( i ) == ' ▁ ' ) System . out . print ( str . charAt ( i ) ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; cipher ( str ) ; } }
import java . util . * ; class GFG { static int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; } public static void main ( String [ ] args ) { int n = 4722 ; System . out . println ( round ( n ) ) ; } }
import java . io . * ; class GFG { static int countOccurrences ( String s , int K ) { int n = s . length ( ) ; int C = 0 , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' a ' ) c1 ++ ; if ( s . charAt ( i ) == ' b ' ) { c2 ++ ; C += c1 ; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; } public static void main ( String [ ] args ) { String S = " abcb " ; int k = 2 ; System . out . println ( countOccurrences ( S , k ) ) ; } }
import java . io . * ; public class GFG { static String findString ( int n , int k ) { String res = " " ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( ' a ' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' a ' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; } static public void main ( String [ ] args ) { int n = 5 , k = 2 ; System . out . println ( findString ( n , k ) ) ; } }
public class GFG { static int isVowel ( char ch ) { ch = Character . toUpperCase ( ch ) ; if ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) return 1 ; else return 0 ; } static int countVowels ( String str , int n ) { if ( n == 1 ) return isVowel ( str . charAt ( n - 1 ) ) ; return countVowels ( str , n - 1 ) + isVowel ( str . charAt ( n - 1 ) ) ; } public static void main ( String args [ ] ) { String str = " abc ▁ de " ; System . out . println ( countVowels ( str , str . length ( ) ) ) ; } }
class Test { static void printRotatedString ( String str ) { int n = str . length ( ) ; StringBuffer sb = new StringBuffer ( str ) ; sb . append ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) System . out . print ( sb . charAt ( i + j ) ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { String str = new String ( " geeks " ) ; printRotatedString ( str ) ; } }
public class GFG { static final int M = 26 ; static int getIdx ( char ch ) { return ( ch - ' a ' ) ; } static boolean allSame ( int freq [ ] , int N ) { int same = 0 ; int i ; for ( i = 0 ; i < N ; i ++ ) { if ( freq [ i ] > 0 ) { same = freq [ i ] ; break ; } } for ( int j = i + 1 ; j < N ; j ++ ) if ( freq [ j ] > 0 && freq [ j ] != same ) return false ; return true ; } static boolean possibleSameCharFreqByOneRemoval ( String str ) { int l = str . length ( ) ; int [ ] freq = new int [ M ] ; for ( int i = 0 ; i < l ; i ++ ) freq [ getIdx ( str . charAt ( i ) ) ] ++ ; if ( allSame ( freq , M ) ) return true ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int i = getIdx ( c ) ; if ( freq [ i ] > 0 ) { freq [ i ] -- ; if ( allSame ( freq , M ) ) return true ; freq [ i ] ++ ; } } return false ; } public static void main ( String args [ ] ) { String str = " xyyzz " ; if ( possibleSameCharFreqByOneRemoval ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class IsDivisible { static boolean check ( String str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' ) ; else evenDigSum += ( str . charAt ( i ) - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; } public static void main ( String [ ] args ) { String str = "76945" ; if ( check ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int hammingDist ( String str1 , String str2 ) { int i = 0 , count = 0 ; while ( i < str1 . length ( ) ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) count ++ ; i ++ ; } return count ; } public static void main ( String [ ] args ) { String str1 = " geekspractice " ; String str2 = " nerdspractise " ; System . out . println ( hammingDist ( str1 , str2 ) ) ; } }
public class GFG { static final int MAX_CHAR = 26 ; static boolean arekAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; } public static void main ( String args [ ] ) { String str1 = " anagram " ; String str2 = " grammar " ; int k = 2 ; if ( arekAnagrams ( str1 , str2 , k ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class CountSubString { int countSubStr ( char str [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; } public static void main ( String [ ] args ) { CountSubString count = new CountSubString ( ) ; String string = "00100101" ; char str [ ] = string . toCharArray ( ) ; int n = str . length ; System . out . println ( count . countSubStr ( str , n ) ) ; } }
import java . io . * ; class GFG { static int count9s ( String number ) { int count = 0 ; int n = number . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = number . charAt ( i ) - '0' ; if ( number . charAt ( i ) == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number . charAt ( j ) - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { System . out . println ( count9s ( "4189" ) ) ; System . out . println ( count9s ( "1809" ) ) ; } }
import java . util . * ; class GFG { public static int minStepsRecur ( int height [ ] , int l , int r , int h ) { if ( l >= r ) return 0 ; int m = l ; for ( int i = l ; i < r ; i ++ ) if ( height [ i ] < height [ m ] ) m = i ; return Math . min ( r - l , minStepsRecur ( height , l , m , height [ m ] ) + minStepsRecur ( height , m + 1 , r , height [ m ] ) + height [ m ] - h ) ; } public static int minSteps ( int height [ ] , int N ) { return minStepsRecur ( height , 0 , N , 0 ) ; } public static void main ( String [ ] args ) { int height [ ] = { 2 , 1 , 2 , 5 , 1 } ; int N = height . length ; System . out . println ( minSteps ( height , N ) ) ; } }
import java . lang . Math ; class cfg { static double ReuleauxArea ( double a ) { if ( a < 0 ) return - 1 ; double A = 0.70477 * Math . pow ( a , 2 ) ; return A ; } public static void main ( String [ ] args ) { double a = 6 ; System . out . println ( ReuleauxArea ( a ) ) ; }
import java . io . * ; class GFG { static double hexagonside ( double a ) { if ( a < 0 ) return - 1 ; double x = ( 0.5176 * a ) ; return x ; } public static void main ( String [ ] args ) { double a = 6 ; System . out . println ( hexagonside ( a ) ) ; } }
class CLG { static float hexagonside ( float a ) { if ( a < 0 ) return - 1 ; float x = a / 3 ; return x ; } public static void main ( String [ ] args ) { float a = 6 ; System . out . println ( hexagonside ( a ) ) ; } }
class GFG { static int findSegment ( int n , int m , int [ ] segment_length ) { double meet_point = ( 1.0 * n ) / 2.0 ; int sum = 0 ; int segment_number = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sum += segment_length [ i ] ; if ( ( double ) sum == meet_point ) { segment_number = - 1 ; break ; } if ( sum > meet_point ) { segment_number = i + 1 ; break ; } } return segment_number ; } public static void main ( String [ ] args ) { int n = 13 ; int m = 3 ; int [ ] segment_length = new int [ ] { 3 , 2 , 8 } ; int ans = findSegment ( n , m , segment_length ) ; System . out . println ( ans ) ; } }
public class GFG { static long countMaxIntersect ( long n ) { return ( n ) * ( n - 1 ) / 2 ; } public static void main ( String args [ ] ) { long n = 8 ; System . out . println ( countMaxIntersect ( n ) ) ; } }
import java . util . * ; class solution { static float surfaceArea ( float a , float b , float h ) { return 5 * a * b + 5 * b * h ; } static float volume ( float b , float h ) { return ( 5 * b * h ) / 2 ; } public static void main ( String arr [ ] ) { float a = 5 ; float b = 3 ; float h = 7 ; System . out . println ( " surface ▁ area = ▁ " + surfaceArea ( a , b , h ) + " , ▁ " ) ; System . out . println ( " volume = ▁ " + volume ( b , h ) ) ; } }
class solution { static int checkpoint ( int h , int k , int x , int y , int a ) { int p = ( int ) Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; } public static void main ( String arr [ ] ) { int h = 0 , k = 0 , x = 2 , y = 1 , a = 4 ; if ( checkpoint ( h , k , x , y , a ) > 0 ) System . out . println ( " Outside " ) ; else if ( checkpoint ( h , k , x , y , a ) == 0 ) System . out . println ( " On ▁ the ▁ parabola " ) ; else System . out . println ( " Inside " ) ; } }
import java . util . * ; class solution { static int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( ( int ) Math . pow ( ( x - h ) , 2 ) / ( int ) Math . pow ( a , 2 ) ) + ( ( int ) Math . pow ( ( y - k ) , 2 ) / ( int ) Math . pow ( b , 2 ) ) ; return p ; } public static void main ( String arr [ ] ) { int h = 0 , k = 0 , x = 2 , y = 1 , a = 4 , b = 5 ; if ( checkpoint ( h , k , x , y , a , b ) > 1 ) System . out . println ( " Outside " ) ; else if ( checkpoint ( h , k , x , y , a , b ) == 1 ) System . out . println ( " On ▁ the ▁ ellipse " ) ; else System . out . println ( " Inside " ) ; } }
public class GFG { public static float circlearea ( double a , double b ) { if ( a < 0 b < 0 ) return - 1 ; float A = ( float ) ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; } public static void main ( String [ ] args ) { float a = 8 , b = 10 ; System . out . println ( circlearea ( a , b ) ) ; } }
class GFG { static float circlearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( float ) ( 3.14 * Math . pow ( l / 2 , 2 ) ) ; else return ( float ) ( 3.14 * Math . pow ( b / 2 , 2 ) ) ; } public static void main ( String [ ] args ) { float l = 4 , b = 8 ; System . out . println ( circlearea ( l , b ) ) ; } }
import java . io . * ; class GFG { static int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( n + " th ▁ Centered " + " ▁ cube ▁ number : ▁ " ) ; System . out . println ( centered_cube ( n ) ) ; n = 10 ; System . out . print ( n + " th ▁ Centered " + " ▁ cube ▁ number : ▁ " ) ; System . out . println ( centered_cube ( n ) ) ; } }
class GFG { static void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( float ) ( x1 + x2 ) / 2 + " , ▁ " + ( float ) ( y1 + y2 ) / 2 ) ; } public static void main ( String arg [ ] ) { int x1 = - 9 , y1 = 3 , x2 = 5 , y2 = - 7 ; center ( x1 , x2 , y1 , y2 ) ; } }
import java . io . * ; class GFG { public static void main ( String [ ] args ) { double side = 3 ; System . out . print ( " Volume ▁ of ▁ octahedron ▁ = ▁ " ) ; System . out . println ( vol_of_octahedron ( side ) ) ; } static double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ; } }
import java . util . * ; import java . lang . * ; class GfG { public static float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.33 * pi * r1 * r2 * r3 ; } public static void main ( String args [ ] ) { float r1 = ( float ) 2.3 , r2 = ( float ) 3.4 , r3 = ( float ) 5.7 ; System . out . println ( " volume ▁ of ▁ ellipsoid ▁ is ▁ : ▁ " + volumeOfEllipsoid ( r1 , r2 , r3 ) ) ; } }
import java . io . * ; class GFG { static double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; } public static void main ( String arg [ ] ) { double side = 4 ; System . out . print ( " Area ▁ of ▁ Regular ▁ Octagon ▁ = ▁ " + areaOctagon ( side ) ) ; } }
class GFG { static double areaCube ( double a ) { return ( a * a * a ) ; } static double surfaceCube ( double a ) { return ( 6 * a * a ) ; } public static void main ( String [ ] args ) { double a = 5 ; System . out . println ( " Area ▁ = ▁ " + areaCube ( a ) ) ; System . out . println ( " Total ▁ surface ▁ area ▁ = ▁ " + surfaceCube ( a ) ) ; } }
class GFG { static double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; } public static void main ( String arg [ ] ) { int r = 2 , x1 = 0 , y1 = 0 ; int x2 = 0 , y2 = 4 ; System . out . print ( ( int ) minRevolutions ( r , x1 , y1 , x2 , y2 ) ) ; } }
public class GFG { final static double eps = ( double ) 1e-6 ; static double getArea ( double base , double hypotenuse ) { double height = Math . sqrt ( hypotenuse * hypotenuse - base * base ) ; return 0.5 * base * height ; } static void printRightAngleTriangle ( int hypotenuse , int area ) { int hsquare = hypotenuse * hypotenuse ; double sideForMaxArea = Math . sqrt ( hsquare / 2.0 ) ; double maxArea = getArea ( sideForMaxArea , hypotenuse ) ; if ( area > maxArea ) { System . out . print ( " Not ▁ possible " ) ; return ; } double low = 0.0 ; double high = sideForMaxArea ; double base = 0 ; while ( Math . abs ( high - low ) > eps ) { base = ( low + high ) / 2.0 ; if ( getArea ( base , hypotenuse ) >= area ) { high = base ; } else { low = base ; } } double height = Math . sqrt ( hsquare - base * base ) ; System . out . println ( Math . round ( base ) + " ▁ " + Math . round ( height ) ) ; } static public void main ( String [ ] args ) { int hypotenuse = 5 ; int area = 6 ; printRightAngleTriangle ( hypotenuse , area ) ; } }
class GFG { static int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = ( int ) Math . sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; } public static void main ( String arg [ ] ) { int r = 5 ; System . out . println ( countLattice ( r ) ) ; } }
class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } public static void main ( String [ ] args ) { int L = 2 ; int P = ( int ) Math . pow ( 10 , 9 ) ; int ans = power ( 325 , L , P ) ; System . out . println ( ans ) ; } }
class GFG { static int MAXN = 30 ; static int countMaxLength ( int N ) { int res ; int pre [ ] = new int [ MAXN ] ; int p = 1 ; pre [ 0 ] = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { p *= 2 ; pre [ i ] = pre [ i - 1 ] + i * p ; } int ind = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { if ( pre [ i ] >= N ) { ind = i ; break ; } } int x = N - pre [ ind - 1 ] ; int y = 2 * ind - 1 ; if ( x >= y ) res = Math . min ( x , y ) ; else res = Math . max ( x , 2 * ( ind - 2 ) + 1 ) ; return res ; } public static void main ( String [ ] args ) { int N = 25 ; System . out . println ( countMaxLength ( N ) ) ; } }
class GFG { static int factorialUsingRecursion ( int n ) { if ( n == 0 ) return 1 ; return n * factorialUsingRecursion ( n - 1 ) ; } static int factorialUsingIteration ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; } public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( " Factorial ▁ of ▁ " + num + " ▁ using ▁ Recursion ▁ is : ▁ " + factorialUsingRecursion ( 5 ) ) ; System . out . println ( " Factorial ▁ of ▁ " + num + " ▁ using ▁ Iteration ▁ is : ▁ " + factorialUsingIteration ( 5 ) ) ; } }
class GFG { static int maxSum ( int arr [ ] , int n , int K ) { int maximum = Integer . MIN_VALUE ; int [ ] sum = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i + K < n ) sum [ i ] = sum [ i + K ] + arr [ i ] ; else sum [ i ] = arr [ i ] ; maximum = Math . max ( maximum , sum [ i ] ) ; } return maximum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 6 , 4 , 7 , 2 } ; int n = arr . length ; int K = 2 ; System . out . print ( maxSum ( arr , n , K ) ) ; } }
class GFG { static void findpair ( int l , int r ) { int c = 0 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { System . out . println ( i + " , ▁ " + j ) ; c = 1 ; break ; } } if ( c == 1 ) break ; } } public static void main ( String args [ ] ) { int l = 1 , r = 10 ; findpair ( l , r ) ; } }
import java . util . * ; class GFG { static boolean check ( int arr [ ] , int N , int K ) { HashSet < Integer > unique = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) unique . add ( arr [ i ] ) ; if ( unique . size ( ) == K ) return true ; return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 3 } ; int N = arr . length ; int K = 3 ; if ( check ( arr , N , K ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int minIndex ( int arr [ ] , int n , int pos ) { int num = arr [ pos ] ; int i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 1 , 1 , 5 , 2 } ; int n = arr . length ; int pos = 4 ; System . out . println ( minIndex ( arr , n , pos ) ) ; } }
import java . util . * ; class GFG { static int findAnswer ( String str1 , String str2 , int n ) { int l = 0 , r = 0 ; int ans = 2 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { r = i ; break ; } } if ( r < l ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else { for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i - 1 ) ) { ans -- ; break ; } } for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i - 1 ) != str2 . charAt ( i ) ) { ans -- ; break ; } } return ans ; } } public static void main ( String args [ ] ) { String str1 = " toy " , str2 = " try " ; int n = str1 . length ( ) ; System . out . println ( findAnswer ( str1 , str2 , n ) ) ; } }
import java . util . * ; class solution { static int findMinDifference ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 4 , 3 , 4 } ; int n = arr . length ; System . out . print ( findMinDifference ( arr , n ) ) ; } }
public class GFG { static int findMinDifference ( int arr [ ] , int n ) { int min , secondMin , max , secondMax ; min = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } else if ( arr [ i ] < min ) { secondMin = min ; min = arr [ i ] ; } else if ( arr [ i ] < secondMin ) { secondMin = arr [ i ] ; } } int diff = Math . min ( max - secondMin , secondMax - min ) ; return diff ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 3 , 4 } ; int n = arr . length ; System . out . println ( findMinDifference ( arr , n ) ) ; } }
import java . io . * ; class GFG { static boolean checkDistinct ( int x ) { int last = x % 10 ; while ( x > 0 ) { if ( x % 10 != last ) return false ; x = x / 10 ; } return true ; } static int findCount ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( checkDistinct ( i ) ) count += 1 ; } return count ; } public static void main ( String [ ] args ) { int L = 10 , R = 50 ; System . out . println ( findCount ( L , R ) ) ; } }
import java . io . * ; class GFG { static int smallest_pair ( int [ ] a , int n ) { int min = Integer . MAX_VALUE , secondMin = Integer . MAX_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( smallest_pair ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int longestsubarray ( int arr [ ] , int n , int k ) { int current_count = 0 ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = Math . max ( current_count , max_count ) ; } return max_count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 11 , 32 , 64 , 88 } ; int n = arr . length ; int k = 8 ; System . out . println ( longestsubarray ( arr , n , k ) ) ; } }
class GFG { static boolean check ( String s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) return true ; return false ; } public static void main ( String [ ] args ) { String s = " xzyyz " ; if ( check ( s ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static int countAnomalies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 7 , 1 , 8 } , k = 5 ; int n = arr . length ; System . out . println ( countAnomalies ( arr , n , k ) ) ; } }
public class GOC1 { static int colMaxDiff ( int mat [ ] [ ] ) { int max_diff = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 } , { 5 , 3 , 5 , 4 , 0 } , { 5 , 6 , 7 , 8 , 9 } , { 0 , 6 , 3 , 4 , 12 } , { 9 , 7 , 12 , 4 , 3 } , } ; System . out . println ( " Max ▁ difference ▁ : ▁ " + colMaxDiff ( mat ) ) ; } }
import java . io . * ; class GFG { static int search ( int ar [ ] , int size ) { int a = 0 , b = size - 1 ; int mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 1 ) ; } public static void main ( String [ ] args ) { int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 8 } ; int size = ar . length ; System . out . println ( " Missing ▁ number : ▁ " + search ( ar , size ) ) ; } }
class GFG { static int deleteElement ( int A [ ] , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; } public static void main ( String args [ ] ) { int A [ ] = new int [ ] { 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 } ; int L = 2 , R = 7 ; int n = A . length ; int res_size = deleteElement ( A , L , R , n ) ; for ( int i = 0 ; i < res_size ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; } }
class GFG { static int findmissing ( int [ ] ar , int N ) { int l = 0 , r = N - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return ( mid + 1 ) ; if ( ar [ mid ] != mid + 1 ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 7 , 8 } ; int N = arr . length ; System . out . println ( findmissing ( arr , N ) ) ; } }
import java . util . * ; class GFG { static int findFirst ( int arr [ ] , int n , int x ) { Arrays . sort ( arr ) ; int ptr = lowerBound ( arr , 0 , n , x ) ; return ( arr [ ptr ] != x ) ? - 1 : ( ptr ) ; } static int lowerBound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) low = middle + 1 ; else high = middle ; } return low ; } public static void main ( String [ ] args ) { int x = 20 , arr [ ] = { 10 , 30 , 20 , 50 , 20 } ; int n = arr . length ; System . out . println ( findFirst ( arr , n , x ) ) ; } }
public class GFG { static int findFirst ( int arr [ ] , int n , int x ) { int count = 0 ; boolean isX = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { isX = true ; } else if ( arr [ i ] < x ) { count ++ ; } } return ( isX == false ) ? - 1 : count ; } public static void main ( String [ ] args ) { int x = 20 , arr [ ] = { 10 , 30 , 20 , 50 , 20 } ; int n = arr . length ; System . out . println ( findFirst ( arr , n , x ) ) ; } }
import java . util . * ; class GFG { public static int findDuplicate ( int [ ] arr ) { int slow = arr [ 0 ] ; int fast = arr [ 0 ] ; do { slow = arr [ slow ] ; fast = arr [ arr [ fast ] ] ; } while ( slow != fast ) ; int ptr1 = arr [ 0 ] ; int ptr2 = slow ; while ( ptr1 != ptr2 ) { ptr1 = arr [ ptr1 ] ; ptr2 = arr [ ptr2 ] ; } return ptr1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 2 , 1 } ; System . out . println ( " " + findDuplicate ( arr ) ) ; System . exit ( 0 ) ; } }
public class GFG { final static int MAX_CHAR = 26 ; static void printGreaterCount ( String str ) { int len = str . length ( ) ; int ans [ ] = new int [ len ] , count [ ] = new int [ MAX_CHAR ] ; for ( int i = len - 1 ; i >= 0 ; i -- ) { count [ str . charAt ( i ) - ' a ' ] ++ ; for ( int j = str . charAt ( i ) - ' a ' + 1 ; j < MAX_CHAR ; j ++ ) { ans [ i ] += count [ j ] ; } } for ( int i = 0 ; i < len ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } } static public void main ( String [ ] args ) { String str = " abcd " ; printGreaterCount ( str ) ; } }
class GFG { static int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) { return - 1 ; } int maxA = Integer . MIN_VALUE , maxB = Integer . MIN_VALUE , maxC = Integer . MIN_VALUE , maxD = Integer . MIN_VALUE ; int minA = Integer . MAX_VALUE , minB = Integer . MAX_VALUE , minC = Integer . MAX_VALUE , minD = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxD = maxC ; maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxD = maxC ; maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) { maxD = maxC ; maxC = arr [ i ] ; } else if ( arr [ i ] > maxD ) { maxD = arr [ i ] ; } if ( arr [ i ] < minA ) { minD = minC ; minC = minB ; minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) { minD = minC ; minC = minB ; minB = arr [ i ] ; } else if ( arr [ i ] < minC ) { minD = minC ; minC = arr [ i ] ; } else if ( arr [ i ] < minD ) { minD = arr [ i ] ; } } int x = maxA * maxB * maxC * maxD ; int y = minA * minB * minC * minD ; int z = minA * minB * maxA * maxB ; return Math . max ( x , Math . max ( y , z ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , - 4 , 3 , - 6 , 7 , 0 } ; int n = arr . length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) System . out . println ( " No ▁ Quadruple ▁ Exists " ) ; else System . out . println ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int countTripletsLessThanL ( int n , int L , int [ ] arr ) { Arrays . sort ( arr ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; } static public void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . length ; int L = 3 ; int ans = countTripletsLessThanL ( n , L , arr ) ; System . out . println ( " Total ▁ Number ▁ of ▁ ways ▁ = ▁ " + ans ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int missingNum ( int arr [ ] , int n ) { List < Integer > list = new ArrayList < > ( arr . length ) ; for ( int i : arr ) { list . add ( Integer . valueOf ( i ) ) ; } int minvalue = Collections . min ( list ) ; ; int xornum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; } public static void main ( String [ ] args ) { int arr [ ] = { 13 , 12 , 11 , 15 } ; int n = arr . length ; System . out . println ( missingNum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int findLastIndex ( String str , Character x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; Character x = ' e ' ; int index = findLastIndex ( str , x ) ; if ( index == - 1 ) System . out . println ( " Character ▁ not ▁ found " ) ; else System . out . println ( " Last ▁ index ▁ is ▁ " + index ) ; } }
import java . io . * ; class GFG { static int findLastIndex ( String str , Character x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == x ) return i ; return - 1 ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; Character x = ' e ' ; int index = findLastIndex ( str , x ) ; if ( index == - 1 ) System . out . println ( " Character ▁ not ▁ found " ) ; else System . out . println ( " Last ▁ index ▁ is ▁ " + index ) ; } }
import java . io . * ; class GFG { static int countMaxSetBits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; } public static void main ( String [ ] args ) { int l = 1 ; int r = 5 ; System . out . println ( countMaxSetBits ( l , r ) ) ; l = 1 ; r = 10 ; System . out . println ( countMaxSetBits ( l , r ) ) ; } }
import java . io . * ; public class GFG { static int findS ( int s ) { int l = 1 , r = ( s / 2 ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; } static public void main ( String [ ] args ) { int s = 15 ; int n = findS ( s ) ; if ( n == - 1 ) System . out . println ( " - 1" ) ; else System . out . println ( n ) ; } }
import java . util . Arrays ; import java . io . * ; class GFG { static void pendulumArrangement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int odd , temp , in , pos ; pos = n - 1 ; if ( n % 2 == 0 ) odd = n - 1 ; else odd = n - 2 ; while ( odd > 0 ) { temp = arr [ odd ] ; in = odd ; while ( in != pos ) { arr [ in ] = arr [ in + 1 ] ; in ++ ; } arr [ in ] = temp ; odd = odd - 2 ; pos = pos - 1 ; } int start = 0 , end = ( n - 1 ) / 2 ; for ( ; start < end ; start ++ , end -- ) { temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 2 , 4 , 55 , 6 , 8 } ; int n = arr . length ; pendulumArrangement ( arr , n ) ; } }
import java . util . Arrays ; class GFG { static int findNumber ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max = arr [ n - 1 ] ; int table [ ] = new int [ ( 2 * max ) + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) table [ i ] = Integer . MAX_VALUE ; int ans = - 1 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] <= i ) { int res = table [ i - arr [ j ] ] ; if ( res != Integer . MAX_VALUE && res + 1 < table [ i ] ) table [ i ] = res + 1 ; } } if ( i > arr [ n - 1 ] && table [ i ] == Integer . MAX_VALUE ) { ans = i ; break ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 7 , 15 } ; int n = arr . length ; System . out . println ( findNumber ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int countPoints ( int n , int m , int a [ ] , int [ ] b , int x , int y ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int j = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; } public static void main ( String args [ ] ) { int x = 1 , y = 4 ; int [ ] a = { 1 , 5 } ; int n = a . length ; int [ ] b = { 1 , 1 , 2 } ; int m = a . length ; System . out . println ( countPoints ( n , m , a , b , x , y ) ) ; } }
import java . util . * ; class GFG { static int minSubarray ( int A [ ] , int n ) { int minValue = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] < minValue ) minValue = A [ i ] ; } int maxValue = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] > maxValue ) maxValue = A [ i ] ; } int pos_min = - 1 , pos_max = - 1 , ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] == minValue ) pos_min = i ; if ( A [ i ] == maxValue ) pos_max = i ; if ( pos_max != - 1 && pos_min != - 1 ) ans = Math . min ( ans , Math . abs ( pos_min - pos_max ) + 1 ) ; } return ans ; } public static void main ( String args [ ] ) { int A [ ] = { 1 , 5 , 9 , 7 , 1 , 9 , 4 } ; int n = A . length ; System . out . println ( minSubarray ( A , n ) ) ; } }
import java . util . Arrays ; import java . io . * ; class GFG { static int countSequences ( int arr [ ] , int n ) { int count = 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 7 , 3 , 5 , 10 } ; int n = arr . length ; System . out . println ( countSequences ( arr , n ) ) ; } }
import java . util . * ; class solution { static long minimumMoves ( int a [ ] , int n ) { long operations = 0 ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) operations += ( long ) Math . abs ( a [ i ] - ( i + 1 ) ) ; return operations ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 3 , 2 } ; int n = arr . length ; System . out . print ( minimumMoves ( arr , n ) ) ; } }
import java . io . * ; class GFG { static void printCase ( int n ) { if ( n <= 2 ) { System . out . print ( - 1 ) ; return ; } for ( int i = n ; i >= 1 ; i -- ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 3 ; printCase ( n ) ; } }
import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; class GFG { static class Pair { int first , second ; public Pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void findMissingNumber ( ArrayList < Pair > ranges , int m ) { Collections . sort ( ranges , new Comparator < Pair > ( ) { public int compare ( Pair first , Pair second ) { if ( first . first == second . first ) { return first . second - second . second ; } return first . first - second . first ; } } ) ; ArrayList < Integer > ans = new ArrayList < > ( ) ; int prev = 0 ; for ( int j = 0 ; j < ranges . size ( ) ; j ++ ) { int start = ranges . get ( j ) . first ; int end = ranges . get ( j ) . second ; for ( int i = prev + 1 ; i < start ; i ++ ) ans . add ( i ) ; prev = end ; } for ( int i = prev + 1 ; i <= m ; i ++ ) ans . add ( i ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { if ( ans . get ( i ) <= m ) System . out . print ( ans . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 2 , M = 6 ; ArrayList < Pair > ranges = new ArrayList < > ( ) ; ranges . add ( new Pair ( 1 , 2 ) ) ; ranges . add ( new Pair ( 4 , 5 ) ) ; findMissingNumber ( ranges , M ) ; } }
import java . util . Arrays ; class GFG { static boolean check ( int n , int k , int [ ] a , int [ ] b ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; boolean fl = false ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { if ( fl == true ) { return false ; } fl = true ; ind = i ; } } if ( ind == - 1 | Math . abs ( a [ ind ] - b [ ind ] ) <= k ) { return true ; } return false ; } public static void main ( String [ ] args ) { int n = 2 , k = 4 ; int [ ] a = { 1 , 5 } ; int b [ ] = { 1 , 1 } ; if ( check ( n , k , a , b ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . Arrays ; class GFG { static int MOD = 1000000007 ; static int SubseqWidths ( int [ ] A , int n ) { Arrays . sort ( A ) ; int [ ] pow2 = new int [ n ] ; pow2 [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; } public static void main ( String [ ] args ) { int [ ] A = new int [ ] { 5 , 6 , 4 , 3 , 8 } ; int n = A . length ; System . out . println ( SubseqWidths ( A , n ) ) ; } }
import java . util . * ; class GFG { public static int maxArrayCover ( int [ ] a , int n , int x ) { Arrays . sort ( a ) ; int cc = 0 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += a [ i ] ; if ( s > x ) { break ; } cc += 1 ; } if ( Arrays . stream ( a ) . sum ( ) == x ) { return n ; } else { if ( cc == n ) { return n - 1 ; } else { return cc ; } } } public static void main ( String [ ] args ) { int n = 3 ; int x = 70 ; int [ ] a = new int [ ] { 10 , 20 , 30 } ; System . out . println ( maxArrayCover ( a , n , x ) ) ; System . exit ( 0 ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int maximumSOP ( int [ ] a , int [ ] b ) { int sop = 0 ; int n = a . length ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) { sop += a [ i ] * b [ i ] ; } return sop ; } public static void main ( String args [ ] ) { int [ ] A = { 1 , 2 , 3 } ; int [ ] B = { 4 , 5 , 1 } ; System . out . println ( maximumSOP ( A , B ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; Arrays . sort ( arr ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { long prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 1 , 1 , 1 , 1 } ; int n = arr . length ; int m = 1 ; System . out . println ( countTriplets ( arr , n , m ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void sort3 ( int arr [ ] , int temp [ ] ) { if ( arr [ 1 ] < arr [ 0 ] ) { temp [ 0 ] = arr [ 0 ] ; arr [ 0 ] = arr [ 1 ] ; arr [ 1 ] = temp [ 0 ] ; } if ( arr [ 2 ] < arr [ 1 ] ) { temp [ 0 ] = arr [ 1 ] ; arr [ 1 ] = arr [ 2 ] ; arr [ 2 ] = temp [ 0 ] ; if ( arr [ 1 ] < arr [ 0 ] ) { temp [ 0 ] = arr [ 0 ] ; arr [ 0 ] = arr [ 1 ] ; arr [ 1 ] = temp [ 0 ] ; } } } public static void main ( String args [ ] ) { int a [ ] = new int [ ] { 10 , 12 , 5 } ; int temp1 [ ] = new int [ 10 ] ; sort3 ( a , temp1 ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void printTriplets ( int arr [ ] , int n , int sum ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( int x = j + 1 ; x <= k ; x ++ ) System . out . println ( arr [ i ] + " , ▁ " + arr [ j ] + " , ▁ " + arr [ x ] ) ; j ++ ; } } } } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 1 , 3 , 4 , 7 } ; int n = arr . length ; int sum = 12 ; printTriplets ( arr , n , sum ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static boolean checkFittingArrays ( int [ ] A , int [ ] B , int N ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; } public static void main ( String [ ] args ) { int A [ ] = { 7 , 5 , 3 , 2 } ; int B [ ] = { 5 , 4 , 8 , 7 } ; int N = A . length ; if ( checkFittingArrays ( A , B , N ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int maximum_toys ( int cost [ ] , int N , int K ) { int count = 0 , sum = 0 ; Arrays . sort ( cost ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; } public static void main ( String [ ] args ) { int K = 50 ; int cost [ ] = { 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 } ; int N = cost . length ; System . out . print ( maximum_toys ( cost , N , K ) ) ; } }
import java . util . * ; class GFG { public static boolean almostSort ( int A [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 3 , 2 , 4 , 6 , 5 } ; int n = A . length ; if ( almostSort ( A , n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
public class MergeTwoSortedArrays { private static int nextGap ( int gap ) { if ( gap <= 1 ) return 0 ; return ( gap / 2 ) + ( gap % 2 ) ; } private static void merge ( int [ ] arr1 , int [ ] arr2 , int n , int m ) { int i , j , gap = n + m ; for ( gap = nextGap ( gap ) ; gap > 0 ; gap = nextGap ( gap ) ) { for ( i = 0 ; i + gap < n ; i ++ ) if ( arr1 [ i ] > arr1 [ i + gap ] ) { int temp = arr1 [ i ] ; arr1 [ i ] = arr1 [ i + gap ] ; arr1 [ i + gap ] = temp ; } for ( j = gap > n ? gap - n : 0 ; i < n && j < m ; i ++ , j ++ ) if ( arr1 [ i ] > arr2 [ j ] ) { int temp = arr1 [ i ] ; arr1 [ i ] = arr2 [ j ] ; arr2 [ j ] = temp ; } if ( j < m ) { for ( j = 0 ; j + gap < m ; j ++ ) if ( arr2 [ j ] > arr2 [ j + gap ] ) { int temp = arr2 [ j ] ; arr2 [ j ] = arr2 [ j + gap ] ; arr2 [ j + gap ] = temp ; } } } } public static void main ( String [ ] args ) { int [ ] a1 = { 10 , 27 , 38 , 43 , 82 } ; int [ ] a2 = { 3 , 9 } ; merge ( a1 , a2 , a1 . length , a2 . length ) ; System . out . print ( " First ▁ Array : ▁ " ) ; for ( int i = 0 ; i < a1 . length ; i ++ ) { System . out . print ( a1 [ i ] + " ▁ " ) ; } System . out . println ( ) ; System . out . print ( " Second ▁ Array : ▁ " ) ; for ( int i = 0 ; i < a2 . length ; i ++ ) { System . out . print ( a2 [ i ] + " ▁ " ) ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; class MergeTwoSorted { public static void mergeArrays ( int [ ] arr1 , int [ ] arr2 , int n1 , int n2 , int [ ] arr3 ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) { if ( arr1 [ i ] < arr2 [ j ] ) arr3 [ k ++ ] = arr1 [ i ++ ] ; else arr3 [ k ++ ] = arr2 [ j ++ ] ; } while ( i < n1 ) arr3 [ k ++ ] = arr1 [ i ++ ] ; while ( j < n2 ) arr3 [ k ++ ] = arr2 [ j ++ ] ; } public static void main ( String [ ] args ) { int [ ] arr1 = { 1 , 3 , 5 , 7 } ; int n1 = arr1 . length ; int [ ] arr2 = { 2 , 4 , 6 , 8 } ; int n2 = arr2 . length ; int [ ] arr3 = new int [ n1 + n2 ] ; mergeArrays ( arr1 , arr2 , n1 , n2 , arr3 ) ; System . out . println ( " Array ▁ after ▁ merging " ) ; for ( int i = 0 ; i < n1 + n2 ; i ++ ) System . out . print ( arr3 [ i ] + " ▁ " ) ; } }
import java . util . * ; class GFG { static int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 n == 0 ) return 0 ; Arrays . sort ( arr ) ; if ( n < m ) return - 1 ; int min_diff = Integer . MAX_VALUE ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 4 , 7 , 9 , 2 , 23 , 25 , 41 , 30 , 40 , 28 , 42 , 30 , 44 , 48 , 43 , 50 } ; int n = arr . length ; System . out . println ( " Minimum ▁ difference ▁ is ▁ " + findMinDiff ( arr , n , m ) ) ; } }
import java . io . * ; class GFG { static int distinctCount ( int arr [ ] , int n ) { int count = n ; int i = 0 , j = n - 1 , sum = 0 ; while ( i < j ) { while ( i != j && arr [ i ] == arr [ i + 1 ] ) { count -- ; i ++ ; } while ( i != j && arr [ j ] == arr [ j - 1 ] ) { count -- ; j -- ; } if ( i == j ) break ; sum = arr [ i ] + arr [ j ] ; if ( sum == 0 ) { count -- ; i ++ ; j -- ; } else if ( sum < 0 ) i ++ ; else j -- ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { - 2 , - 1 , 0 , 1 , 1 } ; int n = arr . length ; System . out . println ( " Count ▁ of ▁ absolute ▁ distinct ▁ values ▁ : ▁ " + distinctCount ( arr , n ) ) ; } }
import java . io . * ; class GFG { static void sortByOneSwap ( int arr [ ] , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] < arr [ i - 1 ] ) { int j = i - 1 ; while ( j >= 0 && arr [ i ] < arr [ j ] ) j -- ; int temp = arr [ i ] ; arr [ i ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; break ; } } } static void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 30 , 20 , 40 , 50 , 60 , 70 } ; int n = arr . length ; System . out . println ( " Given ▁ array ▁ is ▁ " ) ; printArray ( arr , n ) ; sortByOneSwap ( arr , n ) ; System . out . println ( " Sorted ▁ array ▁ is ▁ " ) ; printArray ( arr , n ) ; } }
import java . io . * ; class PancakeSort { static void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } } static int findMax ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; } static int pancakeSort ( int arr [ ] , int n ) { for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) { int mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } return 0 ; } static void printArray ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = arr . length ; pancakeSort ( arr , n ) ; System . out . println ( " Sorted ▁ Array : ▁ " ) ; printArray ( arr , n ) ; } }
class GFG { static String get_maximum ( char [ ] s , int a [ ] ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ; while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = ( char ) ( '0' + a [ s [ j ] - '0' ] ) ; j ++ ; } return String . valueOf ( s ) ; } } return String . valueOf ( s ) ; } public static void main ( String [ ] args ) { String s = "1337" ; int a [ ] = { 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 } ; System . out . println ( get_maximum ( s . toCharArray ( ) , a ) ) ; } }
import java . lang . Math ; public class GfG { static int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . sqrt ( n ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; } public static void main ( String [ ] args ) { int n = 85 ; System . out . println ( countSteps ( n ) ) ; } }
import java . util . Arrays ; class GFG { static int sumArr ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } static int maxSum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < n && k > 0 && arr [ i ] < 0 ) { arr [ i ] *= - 1 ; k -- ; i ++ ; } if ( k % 2 == 1 ) { int min = 0 ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ min ] > arr [ i ] ) min = i ; arr [ min ] *= - 1 ; } return sumArr ( arr , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 5 , 4 , 1 , 3 , 2 } ; int n = arr . length ; int k = 4 ; System . out . println ( maxSum ( arr , n , k ) ) ; } }
class GFG { static int Maxsum ( int c1 , int c2 , int c3 , int c4 ) { int sum = 0 ; int two34 = Math . min ( c2 , Math . min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . min ( c2 , c1 ) * 12 ; return sum ; } public static void main ( String [ ] args ) { int c1 = 5 , c2 = 2 , c3 = 3 , c4 = 4 ; System . out . println ( Maxsum ( c1 , c2 , c3 , c4 ) ) ; } }
import java . io . * ; class GFG { static int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; } public static void main ( String [ ] args ) { int a = 5 , b = 13 , n = 3 ; System . out . println ( findCountOfPairs ( a , b , n ) ) ; } }
class GFG { static void findArray ( int N , int P ) { int ans = ( P * ( P + 1 ) ) / 2 + ( N - P ) ; int arr [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= P ; i ++ ) { arr [ i ] = i ; } for ( int i = P + 1 ; i <= N ; i ++ ) { arr [ i ] = 1 ; } System . out . print ( " The ▁ Minimum ▁ Possible ▁ Sum ▁ is : ▁ " + ans + "NEW_LINE"); System . out . print ( "The Array Elements are: NEW_LINE"); for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 5 , P = 3 ; findArray ( N , P ) ; } }
import java . io . * ; class GFG { static void findIntersection ( int intervals [ ] [ ] , int N ) { int l = intervals [ 0 ] [ 0 ] ; int r = intervals [ 0 ] [ 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { System . out . println ( - 1 ) ; return ; } else { l = Math . max ( l , intervals [ i ] [ 0 ] ) ; r = Math . min ( r , intervals [ i ] [ 1 ] ) ; } } System . out . println ( " [ " + l + " , ▁ " + r + " ] " ) ; } public static void main ( String [ ] args ) { int intervals [ ] [ ] = { { 1 , 6 } , { 2 , 8 } , { 3 , 10 } , { 5 , 8 } } ; int N = intervals . length ; findIntersection ( intervals , N ) ; } }
class GFG { static int cmp ( int a , int b ) { if ( a > b ) return 1 ; else if ( a == b ) return 0 ; else return - 1 ; } static int maxSubarraySize ( int [ ] arr , int n ) { int ans = 1 ; int anchor = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int c = cmp ( arr [ i - 1 ] , arr [ i ] ) ; if ( c == 0 ) anchor = i ; else if ( i == n - 1 || c * cmp ( arr [ i ] , arr [ i + 1 ] ) != - 1 ) { ans = Math . max ( ans , i - anchor + 1 ) ; anchor = i ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 9 , 4 , 2 , 10 , 7 , 8 , 8 , 1 , 9 } ; int n = arr . length ; System . out . println ( maxSubarraySize ( arr , n ) ) ; } }
class GFG { static int ValidPairs ( int arr [ ] , int n ) { int [ ] count = new int [ 121 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] += 1 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) continue ; if ( Math . abs ( arr [ i ] - arr [ j ] ) % 2 == 1 ) continue ; ans += count [ arr [ i ] ] * count [ arr [ j ] ] ; if ( arr [ i ] == arr [ j ] ) ans -= count [ arr [ i ] ] ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 16 , 17 , 18 } ; int n = arr . length ; System . out . println ( ValidPairs ( arr , n ) ) ; } }
import java . lang . * ; import java . util . * ; class GFG { static int minChanges ( int [ ] A , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; } public static void main ( String args [ ] ) { int [ ] A = { 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 } ; int n = A . length ; System . out . print ( minChanges ( A , n ) ) ; } }
class GFG { static void completeSequence ( String s ) { int n = s . length ( ) ; int open = 0 , close = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) open ++ ; else close ++ ; if ( close > open ) { System . out . print ( " IMPOSSIBLE " ) ; return ; } } System . out . print ( s ) ; for ( int i = 0 ; i < open - close ; i ++ ) System . out . print ( " ) " ) ; } public static void main ( String [ ] args ) { String s = " ( ( ) ( ( ) ( " ; completeSequence ( s ) ; } }
class GFG { static void smallestPermute ( int n ) { char res [ ] = new char [ n + 1 ] ; if ( n % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } res [ n - 1 ] = ( char ) ( 48 + n - 2 ) ; res [ n - 2 ] = ( char ) ( 48 + n ) ; res [ n - 3 ] = ( char ) ( 48 + n - 1 ) ; } res [ n ] = ' \0' ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] ) ; } } public static void main ( String [ ] args ) { int n = 7 ; smallestPermute ( n ) ; } }
class GFG { static int minInsertions ( int [ ] H , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; } public static void main ( String [ ] args ) { int [ ] H = new int [ ] { 2 , 4 , 8 , 16 } ; int K = 3 ; int n = H . length ; System . out . println ( minInsertions ( H , n , K ) ) ; } }
class GFG { static int count_minimum_operations ( long n ) { int count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; } public static void main ( String [ ] args ) { long n = 4 ; long ans = count_minimum_operations ( n ) ; System . out . println ( ans ) ; } }
import java . util . * ; class GFG { static void maxSum ( int [ ] a , int n ) { Vector < Integer > l = new Vector < Integer > ( ) ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . add ( i + 1 ) ; else { l . add ( i + 1 ) ; l . add ( i ) ; } } System . out . println ( s ) ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) System . out . print ( l . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 4 ; int a [ ] = { 1 , - 2 , - 3 , 4 } ; maxSum ( a , n ) ; } }
public class GFG { static void LengthLCP ( String x , String y ) { int fr [ ] = new int [ 26 ] ; for ( int i = 0 ; i < b ; i ++ ) { fr [ y . charAt ( i ) - 97 ] += 1 ; } int c = 0 ; for ( int i = 0 ; i < a ; i ++ ) { if ( fr [ x . charAt ( i ) - 97 ] > 0 ) { c += 1 ; fr [ x . charAt ( i ) - 97 ] -= 1 ; } else break ; } System . out . println ( ( c ) ) ; } public static void main ( String args [ ] ) { String x = " here " , y = " there " ; LengthLCP ( x , y ) ; } }
import java . util . * ; class solution { static void CountPair ( int L , int R ) { int x = ( R - L + 1 ) ; System . out . println ( x / 2 + "NEW_LINE"); } public static void main ( String args [ ] ) { int L , R ; L = 1 ; R = 8 ; CountPair ( L , R ) ; } }
class Gfg { public static int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( ( K - P ) * N ) ; } public static void main ( String args [ ] ) { int K , P , N ; K = 4 ; P = 1 ; N = 10 ; System . out . println ( problemsLeft ( K , P , N ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int results ( int n , int k ) { return ( int ) Math . round ( Math . pow ( n , ( 1.0 / Math . pow ( 2.0 , k ) ) ) ) ; } public static void main ( String args [ ] ) { int k = 3 , n = 100000000 ; System . out . print ( " Chocolates ▁ left ▁ after ▁ " + k + " ▁ iterations ▁ are ▁ " + results ( n , k ) ) ; } }
import java . io . * ; class GFG { static int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; } public static void main ( String [ ] args ) { int N = 4 , M = 4 ; System . out . print ( steps ( N , M ) ) ; } }
import java . io . * ; class GFG { static void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) System . out . println ( " No " ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( " Yes ▁ " + days ) ; } } public static void main ( String [ ] args ) { int S = 10 , N = 16 , M = 2 ; survival ( S , N , M ) ; } }
